<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<HostPackage>
		<Host autoClearCommandLineAfterSend="no" HighlightHistory="yes" printCommand="yes" USE_IRE_DRIVER_BUGFIX="no" mUSE_FORCE_LF_AFTER_PROMPT="no" mUSE_UNIX_EOL="no" mNoAntiAlias="no" mEchoLuaErrors="no" runAllKeyMatches="no" AmbigousWidthGlyphsToBeWide="auto" mRawStreamDump="no" mIsLoggingTimestamps="no" logDirectory="" logFileName="" logFileNameFormat="yyyy-MM-dd#HH-mm-ss" mAlertOnNewData="yes" mFORCE_NO_COMPRESSION="no" mFORCE_GA_OFF="no" mFORCE_SAVE_ON_EXIT="yes" mEnableGMCP="yes" mEnableMSSP="yes" mEnableMSDP="yes" mEnableMSP="yes" mEnableMTTS="yes" mEnableMNES="no" mMapStrongHighlight="no" mEnableSpellCheck="yes" mEnableUserDictionary="yes" mUseSharedDictionary="no" mAcceptServerGUI="yes" mAcceptServerMedia="yes" mMapperUseAntiAlias="yes" mMapperShowRoomBorders="yes" mFORCE_MXP_NEGOTIATION_OFF="no" mFORCE_CHARSET_NEGOTIATION_OFF="no" forceNewEnvironNegotiationOff="no" enableTextAnalyzer="no" mRoomSize="0.5" mLineSize="10.0" mBubbleMode="no" mMapViewOnly="yes" mShowRoomIDs="no" mShowPanel="yes" mHaveMapperScript="yes" mEditorAutoComplete="yes" mEditorShowBidi="yes" mEditorTheme="Mudlet" mEditorThemeFile="Mudlet.tmTheme" mThemePreviewItemID="5" mThemePreviewType="trigger" mSearchEngineName="Google" mTimerSupressionInterval="00:00:00.000" mUseProxy="no" mProxyAddress="" mProxyPort="0" mProxyUsername="" mProxyPassword="" mSslTsl="no" mSslIgnoreExpired="no" mSslIgnoreSelfSigned="no" mSslIgnoreAll="no" mAskTlsAvailable="no" mDiscordAccessFlags="2495" mRequiredDiscordUserName="" mRequiredDiscordUserDiscriminator="" mSGRCodeHasColSpaceId="no" mServerMayRedefineColors="no" playerRoomPrimaryColor="#ffff0000" playerRoomSecondaryColor="#ffffffff" playerRoomStyle="0" playerRoomOuterDiameter="120" playerRoomInnerDiameter="70" CompactInputLine="no" CommandLineHistorySaveSize="500" mDoubleClickIgnore="'&quot;" EditorSearchOptions="0" DebugShowAllProblemCodepoints="no" announceIncomingText="yes" advertiseScreenReader="no" caretShortcut="None" blankLineBehaviour="Show" NetworkPacketTimeout="300" ShowIDsInEditor="no">
			<name>PKUXKX</name>
			<mInstalledPackages>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
				<string>autosave</string>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
				<string>2025-04-11#14-26-31</string>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
				<string>2025-04-16#08-25-44</string>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
				<string>autosave</string>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
				<string>2025-04-11#14-26-31</string>
				<string>gui-drop</string>
				<string>run-lua-code</string>
				<string>echo</string>
				<string>deleteOldProfiles</string>
				<string>enable-accessibility</string>
				<string>generic_mapper</string>
			</mInstalledPackages>
			<url>pkuxkx.com</url>
			<serverPackageName>nothing</serverPackageName>
			<serverPackageVersion>-1</serverPackageVersion>
			<port>8081</port>
			<borderTopHeight>0</borderTopHeight>
			<borderBottomHeight>0</borderBottomHeight>
			<borderLeftWidth>0</borderLeftWidth>
			<borderRightWidth>0</borderRightWidth>
			<wrapAt>128</wrapAt>
			<wrapIndentCount>0</wrapIndentCount>
			<mFgColor>#c0c0c0</mFgColor>
			<mBgColor>#000000</mBgColor>
			<mCommandFgColor>#717100</mCommandFgColor>
			<mCommandBgColor>#000000</mCommandBgColor>
			<mCommandLineFgColor>#808080</mCommandLineFgColor>
			<mCommandLineBgColor>#000000</mCommandLineBgColor>
			<mBlack>#000000</mBlack>
			<mLightBlack>#808080</mLightBlack>
			<mRed>#800000</mRed>
			<mLightRed>#ff0000</mLightRed>
			<mBlue>#000080</mBlue>
			<mLightBlue>#0000ff</mLightBlue>
			<mGreen>#008000</mGreen>
			<mLightGreen>#00ff00</mLightGreen>
			<mYellow>#808000</mYellow>
			<mLightYellow>#ffff00</mLightYellow>
			<mCyan>#008080</mCyan>
			<mLightCyan>#00ffff</mLightCyan>
			<mMagenta>#800080</mMagenta>
			<mLightMagenta>#ff00ff</mLightMagenta>
			<mWhite>#c0c0c0</mWhite>
			<mLightWhite>#ffffff</mLightWhite>
			<mDisplayFont>LXGW WenKai Mono,16,-1,5,50,0,0,0,1,0</mDisplayFont>
			<mCommandLineFont>Bitstream Vera Sans Mono,14,-1,5,50,0,0,0,0,0</mCommandLineFont>
			<mCommandSeparator>;</mCommandSeparator>
			<commandLineMinimumHeight>30</commandLineMinimumHeight>
			<mFgColor2>#c0c0c0</mFgColor2>
			<mBgColor2>#000000</mBgColor2>
			<mRoomBorderColor>#c0c0c0</mRoomBorderColor>
			<mRoomCollisionBorderColor>#ffff00</mRoomCollisionBorderColor>
			<mMapInfoBg alpha="120">#969696</mMapInfoBg>
			<mBlack2>#000000</mBlack2>
			<mLightBlack2>#808080</mLightBlack2>
			<mRed2>#800000</mRed2>
			<mLightRed2>#ff0000</mLightRed2>
			<mBlue2>#000080</mBlue2>
			<mLightBlue2>#0000ff</mLightBlue2>
			<mGreen2>#008000</mGreen2>
			<mLightGreen2>#00ff00</mLightGreen2>
			<mYellow2>#808000</mYellow2>
			<mLightYellow2>#ffff00</mLightYellow2>
			<mCyan2>#008080</mCyan2>
			<mLightCyan2>#00ffff</mLightCyan2>
			<mMagenta2>#800080</mMagenta2>
			<mLightMagenta2>#ff00ff</mLightMagenta2>
			<mWhite2>#c0c0c0</mWhite2>
			<mLightWhite2>#ffffff</mLightWhite2>
			<mSpellDic>en_US</mSpellDic>
			<mLineSize>10.0</mLineSize>
			<mRoomSize>0.5</mRoomSize>
			<mapInfoContributor>Short</mapInfoContributor>
			<profileShortcut key="Script editor">Alt+E</profileShortcut>
			<profileShortcut key="Show Map">Alt+M</profileShortcut>
			<profileShortcut key="Compact input line">Alt+L</profileShortcut>
			<profileShortcut key="Preferences">Alt+P</profileShortcut>
			<profileShortcut key="Notepad">Alt+N</profileShortcut>
			<profileShortcut key="Package manager">Alt+O</profileShortcut>
			<profileShortcut key="Module manager">Alt+I</profileShortcut>
			<profileShortcut key="MultiView">Alt+V</profileShortcut>
			<profileShortcut key="Mute all media">Alt+K</profileShortcut>
			<profileShortcut key="Play">Alt+C</profileShortcut>
			<profileShortcut key="Disconnect">Alt+D</profileShortcut>
			<profileShortcut key="Reconnect">Alt+R</profileShortcut>
			<profileShortcut key="Close profile">Alt+W</profileShortcut>
			<profileShortcut key="Toggle Time Stamps">Ctrl+Alt+T</profileShortcut>
			<profileShortcut key="Toggle Replay">Ctrl+Alt+R</profileShortcut>
			<profileShortcut key="Toggle Logging">Ctrl+Alt+L</profileShortcut>
			<profileShortcut key="Toggle Emergency Stop">Ctrl+Alt+S</profileShortcut>
			<stopwatches />
		</Host>
	</HostPackage>
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>generic_mapper</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName>generic_mapper</packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>onNewLine Trigger</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>raiseEvent("onNewLine")</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>4</integer>
				</regexCodePropertyList>
			</Trigger>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>English Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i)^\s*\[\s*Exits:\s*(.*)\]</string>
						<string>^\s*There (?:is|are) \w+ (?:visible|obvious) exit[s]?:\s*(.*)</string>
						<string>^\[?[\s\w]*(?:[Vv]isible|[Oo]bvious) (?:[Pp]ath|[Ee]xit)[s]?(?: is| are)?:?\s*(.*)\]?</string>
						<string>^\s*You see[\w\s]* exit[s]? leading (.*)</string>
						<string>Exits:\s*(.*)</string>
						<string>There are no obvious exits.</string>
						<string>^\s*The (?:only )?obvious exit[s]? (?:is|are):? (.*)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:Alas, )?[Yy]ou can(?:no|')t (?:go|move) .*$</string>
						<string>^The .+ (?:is|seems to be) closed.$</string>
						<string>.+ (?:is not going to|will not) let you pass.$</string>
						<string>^That exit is blocked.$</string>
						<string>^You are blocked by .*$</string>
						<string>^There is no exit in that direction.$</string>
						<string>^The .* is locked.$</string>
						<string>^Alas, you cannot go that way\.\.\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^It is pitch black...</string>
						<string>^It(?:'s| is) too dark</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Forced Move Trigger</name>
					<script>raiseEvent("onForcedMove",matches[2])</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Carefully getting your bearings, you set off (\w+) toward your goal.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>English Multi-Line Exits Trigger</name>
					<script>map.prompt.exits = ""</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>1</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(?i:^(obvious|visible) exits:)</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Exit Line Trigger</name>
						<script>map.prompt.exits = map.prompt.exits .. ", " .. string.trim(matches[2])
setTriggerStayOpen("English Multi-Line Exits Trigger",1)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([\w\s]+)\s*: [\w\s]+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Russian Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*\[\s*Выходы:\s*(.*)\]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Failed Move Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Извини, но ты не можешь туда идти.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Russian Vision Fail Trigger</name>
					<script>raiseEvent("onVisionFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Здесь слишком темно ...</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Chinese Trigger Group</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Exits Trigger</name>
					<script>raiseEvent("onNewRoom",matches[2] or "")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^\s*这里明显的方向有 (.*)。</string>
						<string>^\s*这里明显的出口有 (.*)。</string>
						<string>^\s*这里明显的出口是 (.*)。</string>
						<string>^\s*这里唯一的出口是 (.*)。</string>
						<string>^\s*這裏明顯的出口是 (.*)。</string>
						<string>^\s*這裏唯一的出口是 (.*)。</string>
						<string>^\s*這裏明顯的方向有 (.*)。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Chinese Failed Movement Trigger</name>
					<script>raiseEvent("onMoveFail")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>你又渴又饿，浑身无力，根本就走不动路。</string>
						<string>这个方向没有出路。</string>
						<string>^看来(\w+)不打算让你过去。</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>0</integer>
						<integer>0</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>加内力值</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>打坐完成</name>
				<script>--expandAlias("hb")
if stat.food+0 &lt; 50 then
--if hp_info.food+0 &lt; 100 then
  eat_and_drink()
end
send("dazuo 200")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你运功完毕，深深吸了口气，站了起来</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>气不足</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>sleep</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你现在的气太少了，无法产生内息运行全身经脉</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>补气完成</name>
				<script>--expandAlias("hb")
if stat.food+0 &lt; 50 then
--if hp_info.food+0 &lt; 100 then
  eat_and_drink()
end
send("dazuo 10")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你深深吸了几口气，脸色看起来好多了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>睡醒</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>dazuo 10</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你一觉醒来，精神抖擞地活动了几下手脚。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>睡多</name>
				<script>tempTimer(10, function() send("dazuo 10") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你刚刚睡过一觉, 多睡对身体有害无益</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>慕容</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>发现家贼</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>walk -p;; follow jiazei</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Benboba's murong jiazei</string>
					<string>Gegewudaren's murong jiazei</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>家贼卸下武士刀</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>wield jian</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^慕容世家家贼卸除了你的兵器武士刀</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>家贼死了</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>gz</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^慕容世家家贼死了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>慕容任务完成</name>
				<script>murong_task["is_murong_task_done"] = "initial"</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^仆人在你的耳边悄声说道：为了表达对你的谢意，我已经在你的帐户存了一些辛苦费！</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>任务启动</name>
				<script>--echo("\n~~&gt;捕捉到家贼地址在："..matches[2].."\n")
murong_task["is_murong_task_done"] = "in_progress"
murong_task["murong_target_city"] = matches[2]
murong_task["murong_target_room"] = matches[3]
--echo("----&gt; before set mrf_or_pozhen\n")
mrf_or_pozhen = "mrf"
--echo("===&gt; after set mrf_or_pozhen\n")

expandAlias("mgo")
--echo("----&gt; expandAlias mgo\n")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^仆人叹道：家贼难防，有人偷走了少爷的信件，据传曾在『(.*)的(.*)』附近出现，你去把它找回来吧！$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>任务启动-1</name>
				<script>murong_task["is_murong_task_done"] = "in_progress"
murong_task["current_mrf_location"] = ""
mrf_or_pozhen = "mrf"</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^仆人叹道：家贼难防，有人偷走了少爷的信件，据传曾在以下地点附近出现，你去把它找回来吧！$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>任务失败</name>
				<script>murong_task["is_murong_task_done"] = "initial"</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^由于你没有找回慕容复丢失的信件，被扣除：</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>途中发现家贼</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>walk -p</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>奔波灞发现的 慕容世家家贼</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>家贼卸下玄铁剑</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>wield dao</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^慕容世家家贼卸除了你的兵器玄铁剑</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>捕捉到家贼地址</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>mgo</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^~~&gt;捕捉到家贼地址在：</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>交战-武当</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>气势24</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>pc</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你在攻击中不断积蓄攻势。(气势：24%)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>对手被缠住</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>ps</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^只能见招拆招，疲于应对，不觉已深陷太极剑意之中，无法出招</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>缠被挡住</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>ps</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^只听得「铮」一声清响，剧烈碰撞之下你剑诀为敌所破，无以为继，被迫撤剑收招。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>太极剑 连 CD</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>pz</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>君之「太极剑.*连」尚余</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>对手已经繁忙</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>ps</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你的对手处于繁忙状态，你不需要再用</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>no weapon</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>wield dao</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你手上持有的武器并不能用来发动</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>准备pc</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>pc</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你在攻击中不断积蓄攻势。(气势：12%)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>气势 32</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>pc</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你在攻击中不断积蓄攻势。(气势：32%)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>busy 中...</name>
				<script>tempTimer(1, function () expandAlias("ps") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你刚使完一个绝招，欲要再使，却是有心无力。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>爵位任务</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>名字-年龄</name>
				<script>current_luren["chinese_name"]=multimatches[1][2]
current_luren["full_name"]=string.lower(multimatches[1][3])
current_luren["gender"]=multimatches[2][2]
set_gender_type(multimatches[2][2])
current_luren["age"]=multimatches[2][3]
--showMultimatches()
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>3</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*\s(.*)\((.*)\)</string>
					<string>.*(\w)看起来约(.*)多岁</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>衣服</name>
				<script>--echo("--"..matches[2])
analyze_luren_cloth(matches[2])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*身穿一件(.*)\(</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>鞋子</name>
				<script>--echo("--"..matches[2])
analyze_luren_shoes(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*脚蹬一双(.*)\(</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>身材</name>
				<script>--echo("--&gt;:"..matches[2])
categorize_body(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这是一(.*)的行人</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>消息</name>
				<script>local name = matches[2]
local msg = matches[3]
set_message(name, msg)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(.*)说道：「(.*)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>过滤掉某些行</name>
			<script>if matches[2] ~= "你" then 
  deleteLine()
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>(.*)运功完毕，深深吸了口气，站了起来。</string>
				<string>(.*)开始修炼内力。</string>
				<string>(.*)往.*离开。</string>
				<string>(.*)走了过来</string>
				<string>陆乘风自言自语道</string>
				<string>(.*)的吐出一口鲜血，脸色看起来好多了</string>
				<string>(.*)深深吸了几口气，脸色看起来好多了</string>
				<string>(.*)向陆乘风打听有关.*的消息</string>
				<string>(.*)对陆乘风道</string>
				<string>陆乘风对着(.*)点了点头</string>
				<string>(.*)吐出一口瘀血，脸色看起来好多了。</string>
				<string>你刚做完鉴定任务，先去休息一会吧。</string>
				<string>黄药师自言自语道</string>
				<string>黄药师喃喃道</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>0</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>1</integer>
				<integer>0</integer>
				<integer>0</integer>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>任务地址</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>通用地点触发</name>
				<script>set_xkx_room(matches[2])
--find_one_room(matches[2])
--set_room1(matches[2])
--echo("通用地点触发 ===&gt; find one room: "..matches[2].."\n")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*) - .*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>慕容复</name>
				<script>set_xkx_room("慕容复")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^茶馆</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>破阵-归云庄</name>
				<script>set_xkx_room("归云庄")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>五湖废人</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>扬子津</name>
				<script>set_xkx_room("扬子津")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^扬子津 - \[</string>
					<string>扬子津 -  ★</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>孟津渡对面</name>
				<script>set_xkx_room("孟津渡对面")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是黄河北岸的渡口，东北通向晋阳，渡过黄河就是洛阳了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>义兴</name>
				<script>set_xkx_room("义兴")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>义兴县城 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>无锡</name>
				<script>set_xkx_room("无锡")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>盛巷桥 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>处州府</name>
				<script>set_xkx_room("处州府")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是处州府的中心，四通八达，东面的城隍庙，西面不远的万象山</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>建宁府</name>
				<script>set_xkx_room("建宁府")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是镇安桥南的一处街头，建宁府最繁华的几条街在此汇聚</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>湖州</name>
				<script>set_xkx_room("湖州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是湖州府城北一座热闹的广场，人来人往，络绎不绝</string>
					<string>赵孟頫</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>铅山</name>
				<script>set_xkx_room("铅山")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>南唐保大十一年置县，因永平镇西四里有铅山，遂以山名县</string>
					<string>你到达了铅山县。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>上饶</name>
				<script>set_xkx_room("上饶")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是上饶县城的中央广场，整个县城最繁华的地方</string>
					<string>你到达了上饶县</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>温州</name>
				<script>set_xkx_room("温州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是坐落于温州城中心一座热闹的集市，一棵歪脖子树上挂着各种许愿的纸条</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>江州</name>
				<script>set_xkx_room("江州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是江州的的城中心，可以容纳很多人一起集会的大广场</string>
					<string>你到达了江州</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>雁荡山</name>
				<script>set_xkx_room("雁荡山")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>碧霄峰 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>潮州</name>
				<script>set_xkx_room("潮州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是潮州的中央广场，四条最繁华的大街在此交汇</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>龙泉镇</name>
				<script>set_xkx_room("龙泉镇")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是龙泉镇的一口水井，被镇上居民用了几百年了</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>建康</name>
				<script>set_xkx_room("建康")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> 这里是建康府的城中心，两旁的店铺林立</string>
					<string>中城 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>泉州</name>
				<script>set_xkx_room("泉州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> 泉州是一个安静的港口城市。虽然这里是城中心，</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>武夷山</name>
				<script>set_xkx_room("武夷山")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>九龙窠 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>衢州</name>
				<script>set_xkx_room("衢州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>温方悟</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>提督府</name>
				<script>set_xkx_room("提督府")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这是杭州城的政治军事中心：提督府。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>岳王墓</name>
				<script>set_xkx_room("岳王墓")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>岳飞墓 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>镇江</name>
				<script>set_xkx_room("镇江")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是一个小广场，平时人来人往，热闹非常。几个游客不知道正议论着什么</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>绍兴</name>
				<script>set_xkx_room("绍兴")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>八字桥 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>闽中</name>
				<script>set_xkx_room("闽中")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是福州的城市中心，行人不断从这里经过</string>
					<string>你到达了闽中</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>燕子坞</name>
				<script>set_xkx_room("燕子坞")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>绿衣女郎(Girl)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>嘉兴</name>
				<script>set_xkx_room("嘉兴")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>嘉兴城 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>明州</name>
				<script>set_xkx_room("明州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>鼓楼 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>扬州</name>
				<script>set_xkx_room("扬州")
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>大榕树(Rong shu)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>代州</name>
				<script>set_xkx_room("代州")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> 这里是代州的府前大街，因北面是代州府衙而得名</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>岳阳</name>
				<script>set_xkx_room("岳阳")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是岳阳城的城中心，路上行人摩肩接踵，络绎不绝。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>ferry</name>
				<script>set_xkx_room("ferry")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>&lt;ferry&gt;</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>黄河渡口</name>
				<script>set_xkx_room("孟之经")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^黄河渡口</string>
					<string>赤套渡北渡口</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>归云庄的大厅</name>
				<script>set_xkx_room("归云庄的大厅")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> 这里是归云庄的大厅，是庄主会客的地方</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>桃花岛</name>
				<script>set_xkx_room("桃花岛")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>这里是桃花岛的大厅</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>回疆小镇</name>
				<script>update_location("回疆小镇")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>二位回族妇女</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>梅庄</name>
				<script>cecho("\n&lt;red&gt;===============&gt; 存书==============\n")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>孤山梅庄 -</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>韩世忠</name>
				<script>set_xkx_room("韩世忠")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>韩世忠(</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>到达城市</name>
				<script>set_city(matches[2])</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你到达了(.*)。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>孟之经</name>
				<script>set_xkx_room("孟之经")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>(Meng zhijing)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>加精神</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>吐纳完成</name>
				<script>--expandAlias("hb")
if stat.food+0 &lt; 50 then
--if hp_info.food+0 &lt; 100 then
  eat_and_drink()
end
send("tuna 50")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你吐纳完毕，睁开双眼，站了起来。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>精不足</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>sleep</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你现在精不足，无法修行精力！</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>精神恢复</name>
				<script>--expandAlias("hb")
if stat.food+0 &lt; 50 then
--if hp_info.food+0 &lt; 100 then
  eat_and_drink()
end
send("tuna 10")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你略一凝神，精神看起来好多了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>wake up</name>
				<script>--expandAlias("hb")
if stat.food+0 &lt; 50 then
--if hp_info.food+0 &lt; 100 then
  eat_and_drink()
end
send("tuna 50")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你一觉醒来，精神抖擞地活动了几下手脚。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>睡多</name>
				<script>tempTimer(10, function() send("tuna 10") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你刚刚睡过一觉, 多睡对身体有害无益</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>陆家庄任务</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>陆-占挂</name>
				<script>select_one_gua(matches[2])
send("e;;e;;e;;e")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^陆乘风说道：「格格恶，我为你占得一卦：(.*)。」</string>
					<string>^系统回馈：(.*) = 0</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>开始桃花林任务</name>
				<script>take_one_step()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你来到了一片桃花林里，立刻迷失了方向。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>桃花林任务结束</name>
				<script>tempTimer(2, function() 
  send("leave") 
  tempTimer(2, function() send("w;;w;;w;;") end)
end)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^天色大变，陆乘风给你算的卦也不那么准了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>单步走太快</name>
				<script>tempTimer(1, function() take_one_step() end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你的动作还没有完成，不能移动。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>继续桃花林任务</name>
				<script>increase_step()
tempTimer(2, function() take_one_step() end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你顺利地回到了起点。</string>
					<string>^你充满自信的向前走去，桃花阵看来也不在话下。</string>
					<string>^你渐渐发现，桃林的路径你烂熟于心，对你已不是挑战。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>回到大厅</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>ask lu about job</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>大厅 - </string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>走错</name>
				<script>tempTimer(2, function() restart_zhen() end)
--restart_zhen()</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你胡乱走着，像个没头苍蝇一样，有个声音冷笑：</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="yes" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>鉴定任务</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>s;;s;;na</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你向陆乘风打听有关『job』的消息。</string>
					<string>^陆乘风道：“师父喜爱古玩字画，</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>捡起古玩</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>jianding guwan</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你拣起了一套古玩。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>鉴定完毕</name>
				<script>identify_gudong(matches[2])
send("id")
send("n;;n;;w;;w")
tempTimer(1, function() 
  expandAlias("ggd")
  tempTimer(1, function() send("e;;e") end)
end)
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你发现手中的竟是(.*)。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>map古董id</name>
				<script>--echo("==&gt;"..matches[2]..":"..matches[3])
--^(.*)\s+=\s (\w*)$
map_gudong_to_id(matches[2], matches[3])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(.*)\s+= (.*)$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>捡起字画</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>jianding zihua</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你拣起了一套字画。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>鉴定冷却</name>
				<script>tempTimer(10, function() send("ask lu about job") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你向陆乘风打听有关『job』的消息。</string>
					<string>^陆乘风说道：「你刚做完鉴定任务，先去休息一会吧。」</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>修炼</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand>xiulian bihai-shengong</mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^你从玄幻之境回过神来，顿觉内功修为增进不小。</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>yun-qi</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand>yun qi</mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^你减缓真气运行，让气血运行恢复正常。</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>万安塔</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>发现番邦武士</name>
				<script>--番邦武士 日洛(Ri luo) &lt;战斗中&gt;
echo ("===")
echo("--&gt; "..matches[3])
local name = matches[3]
expandAlias("tan "..name)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>.*番邦武士.*\((.*) (.*)\) &lt;.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>积蓄攻势</name>
			<script>local qishi = matches[2]
-- 桃花到特技
taohua_perform_skills(qishi)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>你在攻击中不断积蓄攻势。\(气势：(.*)%\)</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>交战-桃花岛</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>破阵任务</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>开战大恶</name>
				<script>--echo("==find==")
local name = string.lower(matches[2])
echo("===&gt;"..name)
--expandAlias("tan "..name)
send("kill "..name)
--expandAlias("phf")
expandAlias("ps")
--send("perform sword.xiaohua "..name)

--.*大 恶.*\((.*)\) .*$</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>大 恶.*\((.*)\)</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>领破阵任务</name>
				<script>--echo("===========\n")
--showMultimatches()
mrf_or_pozhen = "pozhen"
local city = multimatches[1][2]
local room = multimatches[1][3]
init_pozhen(city, room)
local dest = pozhen_go()
send(dest)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>1</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你对陆乘风道：“听闻近来有人冒名桃花岛弟子在(.*)的(.*)布下迷阵行恶.*$</string>
					<string>^陆乘风说道：「好吧，这件事就交给你了。」</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>set wimpy</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>set wimpy 50;;unset forced_act</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>赶走冒充桃花岛的恶人之后，你可以回去向陆庄主复命了</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>凌霄看雪</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>凌霄看雪-xingzou snow</name>
				<script>tempTimer(1, function() send("xingzou snow") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你突然发现在路旁的一片积雪上行走(xingzou)似乎可以用来练习轻功</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>凌霄看雪-l snow</name>
				<script>tempTimer(1, function() send("l snow") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>慢慢的，你发现自己可以睁开眼了，只是眼睛似有砂子，疼痛流泪</string>
					<string>雪，雪，还是雪</string>
					<string>你一路走下来，看着脚印回想方才的步法</string>
					<string>洁白的雪地上零星的散落着几朵脚印。</string>
					<string>环顾四周，到处都是白皑皑的积雪。</string>
					<string>你摇摇摆摆走在雪地上，忽然脚底一滑</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>积攒内力</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>回血完成</name>
				<script>dazuo_max()
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你深深吸了几口气，脸色看起来好多了</string>
					<string>你现在气力充沛</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>打坐完成</name>
				<script>yunqi()
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你运功完毕，深深吸了口气，站了起来。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>force_blood_full</name>
				<script>blood_force_full()
--echo("food - water"..stat.water)
if stat.water+0 &lt; 50 or stat.food+0 &lt; 50 then
  eat_and_drink()
end

send("say jiqi completed")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你现在内力接近圆满状态</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>内力枯竭</name>
				<script>if stat.water+0 &lt; 50 or stat.food+0 &lt; 50 then
  eat_and_drink()
end
tempTimer(10, function() expandAlias("start_jiqi") end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string> 你的内力已经枯竭，不能施用内功。</string>
					<string>你的内力不够。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="no" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>释放内力</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>release force</name>
				<script>if stat.neili+0 &gt; 500 then
  tempTimer(0.1, function() 
    release_force()
    send("say release force 1 round") 
  end)
else 
  expandAlias("start_jiqi")  
end
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>release.*force.*1.*round</string>
					<string>jiqi completed</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>基本功夫高了</name>
				<script>basic_skill_is_higher()
echo("===&gt;切换到高级功夫\n")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你的基本功夫比你的高级功夫还高</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>高级功夫高了</name>
				<script>advanced_skill_is_higher()
echo("===&gt; 切换到基本功\n")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你需要提高基本功，不然练得再多也没有用</string>
					<string>你的基本.*的级别还没有.*的级别高，不能通过练习来提高了。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>空手</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand>unwield flute</mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你必须空手才能练习兰花拂穴手。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>0</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>韩世忠</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>启动任务</name>
				<script>showMultimatches()
mrf_or_pozhen="hsz"
local city = multimatches[3][2]
local room = multimatches[3][3]
echo("city =&gt; "..city.." : room =&gt;"..room)
init_hsz(city, room)

local dest = hsz_go()
send(dest)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你向韩世忠打听有关.*</string>
					<string>^韩世忠点了点头.*</string>
					<string>.*我听说有一群异族奸细在(.*)的(.*)附近出没.*</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>兵器被下</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand>wield flute;;wield flute 2</mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^.*卸除了你的兵器.*$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>进副本准备工作</name>
			<script>tempTimer(2, function() 
  expandAlias("shi")
end)
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^你进入了破阵任务副本</string>
				<string>^你进入了韩世忠任务副本</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>test walk</name>
			<script>-- echo("----&gt; {")
-- echo("city = \""..matches[2].."\", ")
-- echo("room = \""..matches[3].."\", ")
-- echo("path = \""..matches[4].."\"")
-- echo("}")

create_city_node(matches[2], matches[3], matches[4]) </script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^│(\w*)\s+◇ (\S*)\s+│(\w*)\s+│$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>继续走</name>
			<script>tempTimer(1, function() send("walk") end)</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>你因为种种原因停了下来，可以用walk继续进行。</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>New trigger</name>
			<script>--display_node_list()</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>客行────┘</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>0</integer>
			</regexCodePropertyList>
		</Trigger>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>孟之经</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>捕捉任务信息</name>
				<script>showMultimatches()
echo("===&gt; 等候地址：" .. multimatches[2][2])
mzj_to_waiting_room(multimatches[2][2])
</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>2</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^你向孟之经打听.*$</string>
					<string>.*你先到(.*)等候.*$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>通传</name>
				<script>tempTimer(1, function() 
  send("ask shiwei about 通传")
end)</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^都统制府侍卫说道：「没有经过通传，任何人等不得擅闯都统治府。</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>准备</name>
				<script>expandAlias("shi")</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>你定睛一看，.*正是你要找的汉奸卖国贼！</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
		</TriggerGroup>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>记录房间文本</name>
			<script>if not mapper then
  return
end

-- 从 matches[2] 取真实的文本
local txt = matches[2] or ""
-- echo("=========== text: "..txt.."=====\n")
-- 如果这一行本来就是空行，就算了
if txt == "" then
  return
end

-- 调试用：先看看是不是真的有东西
--echo("[CAPTURE] [" .. txt .. "]\n")

if not mapper.lastRoomText or mapper.lastRoomText == "" then
  mapper.lastRoomText = txt
else
  mapper.lastRoomText = mapper.lastRoomText .. "\n" .. txt
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string>^(.*)$</string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>1</integer>
			</regexCodePropertyList>
		</Trigger>
		<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>prompt触发器</name>
			<script>if mapper then
  mapper:checkSearchAfterRoomText()
end
</script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList>
				<string></string>
			</regexCodeList>
			<regexCodePropertyList>
				<integer>7</integer>
			</regexCodePropertyList>
		</Trigger>
	</TriggerPackage>
	<TimerPackage>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>study-advanced</name>
			<script>--expandAlias("hb")
send("yun qi")
local level = 50
if stat.food+0 &lt; level or stat.water+0 &lt; level then
  eat_and_drink()
end
--lingwu finger</script>
			<command>do 6 lian parry 1</command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>disable script</name>
			<script>-- status_handler
disableScript("status_handler")</script>
			<command></command>
			<packageName></packageName>
			<time>01:00:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>练dodge的调度</name>
			<script>if hp_info.current_neili &gt; 1400 and hp_info.current_xue &gt; 600 then
  enableScript("study")
  enableTrigger("yun-qi")
  disableTrigger("dazuo-yc")
  echo(" ==&gt; neili &gt; 1400 and xue &gt; 600")
elseif hp_info.current_neili &lt; 400 or hp_info.current_xue &lt; 200 then
  echo(" --&gt; neili &lt; 400 or xue &lt; 600")
  enableTrigger("dazuo-yc")
  disableScript("study")
  disableTrigger("yun-qi")    
  send("dazuo 10")  
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:02:00.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>study - basic</name>
			<script>--expandAlias("hb")
--echo("---==&gt; food: "..stat.food)
--echo("---==&gt; water: "..stat.water)
send("yun jing")
local level = 50
if stat.food+0 &lt; level or stat.water+0 &lt; level then
  eat_and_drink()
end
--lingwu finger</script>
			<command>lingwu sword</command>
			<packageName></packageName>
			<time>00:00:01.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>练dodge</name>
			<script>if stat.food+0 &lt; 50 or stat.water+0 &lt; 50 then
   eat_and_drink()
end

if stat.qi+0 &gt; 900 then
  send("lian dodge 10")
end</script>
			<command></command>
			<packageName></packageName>
			<time>00:00:10.000</time>
		</Timer>
		<Timer isActive="no" isFolder="no" isTempTimer="no" isOffsetTimer="no">
			<name>New timer</name>
			<script></script>
			<command>cai zhuang</command>
			<packageName></packageName>
			<time>00:00:00.900</time>
		</Timer>
	</TimerPackage>
	<AliasPackage>
		<AliasGroup isActive="no" isFolder="yes">
			<name>run-lua-code</name>
			<script></script>
			<command></command>
			<packageName>run-lua-code</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>run lua code</name>
				<script>local f, e = loadstring("return "..matches[2])
if not f then
  f, e = assert(loadstring(matches[2]))
end

local r =
  function(...)
    if not table.is_empty({...}) then
      display(...)
    end
  end
r(f())</script>
				<command></command>
				<packageName></packageName>
				<regex>^lua (.*)$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>echo</name>
			<script></script>
			<command></command>
			<packageName>echo</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>`echo</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
feedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`echo (.+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>`cecho</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
cfeedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`cecho (.+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>`decho</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
dfeedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`decho (.+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>`hecho</name>
				<script>local s = matches[2]

s = string.gsub(s, "%$", "\n")
hfeedTriggers("\n" .. s .. "\n")
echo("\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>`hecho (.+)</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>deleteOldProfiles</name>
			<script></script>
			<command></command>
			<packageName>deleteOldProfiles</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>delete old profiles</name>
				<script>deleteOldProfiles(matches[3], matches[2])

--Syntax examples: "delete old profiles"  -&gt; deletes profiles older than 31 days
--					"delete old maps 10"	-&gt; deletes maps older than 10 days</script>
				<command></command>
				<packageName></packageName>
				<regex>^delete old (profiles|maps|modules)(?: (\d+))?$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>enable-accessibility</name>
			<script></script>
			<command></command>
			<packageName>enable-accessibility</packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>mudlet accessibility on</name>
				<script>echo("Welcome to Mudlet!\n")
echo("Let's adjust a few preferences to improve the visually impaired experience:\n")

setConfig("autoClearInputLine", true)
echo("Text will now be removed from the input line after it was sent ✓\n")
setConfig("showSentText", false)
echo("Text sent to the game will not appear in the main window ✓\n")

setConfig("caretShortcut", "ctrltab")
echo("Shortcut to switch between input line and main window set to Ctrl+Tab. You can also change it to either Tab or F6 in settings.\n")

if getOS() == "windows" then
  setConfig("blankLinesBehaviour", "hide")
  echo("Blank lines will be removed from the output ✓\n")
end

if getOS() == "mac" then
  echo("\nYou're on a mac and VoiceOver will skip reading text when there's lots of it coming in. Would you like to install a third-party TTS plugin to alleviate this issue?\n")
  echo("Type 'mudlet access reader' if so.\n")
  echo("See https://wiki.mudlet.org/w/Accessibility_on_OSX if you'd like to learn more.\n")
end

echo("\nThat's all, enjoy Mudlet!\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^mudlet access(?:ibility)? on$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mudlet accessibility reader</name>
				<script>uninstallPackage"reader"
installPackage"https://github.com/tspivey/mudlet-reader/releases/latest/download/reader.mpackage"</script>
				<command></command>
				<packageName></packageName>
				<regex>^mudlet access(?:ibility)? reader$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="no" isFolder="yes">
			<name>generic_mapper</name>
			<script></script>
			<command></command>
			<packageName>generic_mapper</packageName>
			<regex></regex>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Setup Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Show Alias</name>
					<script>map.showMap()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map show$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Find Map Prompt Alias</name>
					<script>map.find_prompt()</script>
					<command></command>
					<packageName></packageName>
					<regex>^find prompt$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Prompt Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_prompt_pattern(matches[2])
else
  display(map.save.prompt_pattern)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map prompt(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Ignore Alias</name>
					<script>-- USE PATTERNS FOR STRING.GSUB
if matches[2] then
  map.make_ignore_pattern(matches[2])
else
  display(map.save.ignore_patterns)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map ignore(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Move Method Alias</name>
					<script>
if matches[2] then
  map.make_move_method(matches[2])
else
  display(map.save.move_methods)
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map movemethod(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Debug Alias</name>
					<script>map.configs.debug = not map.configs.debug
map.echo("Map debug set to: " .. (map.configs.debug and "on" or "off"))</script>
					<command></command>
					<packageName></packageName>
					<regex>^map debug$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Update Alias</name>
					<script>map.silentUpdate = false
map.updateVersion()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map update$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Config Alias</name>
					<script>-- adjust pattern to allow no argument, if no argument show general help about configs
if not matches[2] then
	cecho(map.help.config)
else
  local startStr, endStr = string.match(matches[2],"(.*) ([%w%.]+)")
  local vals = {'on', 'off', 'true', 'false'}
  local modes = {'lazy','simple','normal','complex'}
  if (table.contains(vals, endStr) or tonumber(endStr)) or (startStr == "mode" and table.contains(modes, endStr)) then
  	map.setConfigs(startStr, endStr)
  else
  	map.setConfigs(matches[2])
  end
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^map config(?: ([\w\s\.]+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Window Config Alias</name>
					<script>map.setConfigs("map_window",matches[3],matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map window (x|y|w|h|origin|shown)(?: ([\w%]+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Translate Config Alias</name>
					<script>map.setConfigs("lang_dirs", {matches[3], matches[4]}, matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map translate (\w+) (\w+) (\w+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Information Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Quick Start Alias</name>
					<script>map.show_help("quick_start")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map basics$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Help Alias</name>
					<script>map.show_help(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map help(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Rooms Alias</name>
					<script>-- map rooms &lt;area&gt; - shows the list of rooms in an area
map.echoRoomList(matches[2] or getRoomArea(map.currentRoom))</script>
					<command></command>
					<packageName></packageName>
					<regex>^map rooms(?: (.+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Areas Alias</name>
					<script>-- area list - shows the known area list
-- functionality already exists in generic_mapper alias 'map areas'

map.echoAreaList()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map areas$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Room Find Alias</name>
					<script>-- rf &lt;name&gt;, room find &lt;name&gt; - searches for a room of a given name

map.roomFind(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:rf|room find) (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Room Look Alias</name>
					<script>-- rl or room look - displays information about the room you're in
-- rl roomID - displays information on a given room ID (ie, rl 34)
-- rl room name  - displays information on a given room, by it's 
--    name (ie, rl tavern of blah)
map.roomLook(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:rl|room look)(?: (.+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Path Alias</name>
					<script>-- showpath roomID - shows you a path from where you are to another room (by it's ID)
-- showpath fromID toID - shows you a path from a given room to another given to 
--                        another room
if not matches[2] and not matches[3] then
  map.echo("Where do you want to showpath to?")
elseif matches[2] and not matches[3] then
  map.echoPath(map.currentRoom, matches[2])
else
  map.echoPath(matches[2], matches[3])
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^showpath(?: (\d+))?(?: (\d+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>List Special Exits Alias</name>
					<script>-- spe list - shows you the list of all known special exists
-- spe list filter - shows you a list of all known special exits, 
--                   filtered by a command (ie. spe list worm warp)
map.listSpecialExits(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^spe list(?: (.+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>List Map Features Alias</name>
					<script>-- feature list - lists all map features created via feature create and the
-- associated room characters

map.listMapFeatures()</script>
					<command></command>
					<packageName></packageName>
					<regex>^feature list$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Regular Use Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Map Me Alias</name>
					<script>map.find_me(nil, nil, nil, true)</script>
					<command></command>
					<packageName></packageName>
					<regex>^map me$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Path Alias</name>
					<script>map.find_path(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map path ([^;]+)(?:\s*;\s*(.+))?</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Recall Alias</name>
					<script>map.set_recall()</script>
					<command></command>
					<packageName></packageName>
					<regex>^map recall$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Character Alias</name>
					<script>map.character = matches[2]</script>
					<command></command>
					<packageName></packageName>
					<regex>^map character (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Map Stop Alias</name>
					<script>raiseEvent("mapStop")
raiseEvent("sysSpeedwalkStopped")</script>
					<command></command>
					<packageName></packageName>
					<regex>^map stop$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Toggle Speedwalk Alias</name>
					<script>map.toggleSpeedwalk(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^mpp(?:\s?(on|off))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Area Lock Alias</name>
					<script>-- arealock, arealock &lt;area&gt; - displays a list of areas you can
-- lock/unlock, can also give it an area name to filter by. If
-- an area is locked the mapper will not attempt to walk through
-- or go through any of the rooms in the area
map.doLockArea(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^arealock(?: (.*))?$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Creation Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Area Alias</name>
					<script>map.set_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set area (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Start Mapping Alias</name>
					<script>map.start_mapping(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^start mapping(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Stop Mapping Alias</name>
					<script>map.stop_mapping()</script>
					<command></command>
					<packageName></packageName>
					<regex>^stop mapping$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Shift Room Alias</name>
					<script>map.shift_room(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^shift (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Portal Alias</name>
					<script>map.set_portal(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add portal (.*)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Show Moves Alias</name>
					<script>map.show_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^show moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Clear Moves Alias</name>
					<script>map.clear_moves()</script>
					<command></command>
					<packageName></packageName>
					<regex>^clear moves$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Door Alias</name>
					<script>map.set_door(matches[2],matches[3],matches[4])</script>
					<command></command>
					<packageName></packageName>
					<regex>^add door (\w+)(?: (none|open|closed|locked))?(?: (yes|no))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Merge Rooms Alias</name>
					<script>map.merge_rooms()</script>
					<command></command>
					<packageName></packageName>
					<regex>^merge rooms$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Map Mode Alias</name>
					<script>map.set_mode(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map mode (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Exit Alias</name>
					<script>map.set_exit(matches[2],matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^set exit (.+) (\d+)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Move A Room Alias</name>
					<script>-- rc or room coords [v&lt;id&gt;] &lt;option&gt;, where option will specify the new
-- location of the room. The room ID is optional, it'll move the current
-- room if you don't provide one.


-- want the current room, but we're lost
if matches[2] == '' and (not map.currentRoom or not map.roomexists(map.currentRoom)) then map.echo("Don't know where we are at the moment.") return end

-- want another room, but it doesn't actually exist
if matches[2] ~= '' and not map.roomexists(matches[2]) then map.echo("v"..matches[2].." doesn't exist.") return end

local m = matches[3]
local rid, rname = (matches[2] ~= "" and matches[2] or map.currentRoom),
  (matches[2] ~= "" and getRoomName(matches[2]) or getRoomName(map.currentRoom))
local x,y,z

local function set() -- small func to set things
  setRoomCoordinates(rid, x, y, z)
  map.echo(string.format("%s (%d) is now at %dx, %dy, %dz.\n", rname, rid, x,y,z))
  centerview(rid)
end

-- let's be flexible and allow several ways if giving an arg
-- rc x y z
x,y,z = string.match(m, "(%-?%d+) (%-?%d+) (%-?%d+)")
if x then
  set(); return
end

-- rc xx? yy? zz?
x,y,z = string.match(m, "(%-?%d+)x"), string.match(m, "(%-?%d+)y"), string.match(m, "(%-?%d+)z")
if x or y or z then
  -- merge w/ old coords if any are missing
  local ox, oy, oz = getRoomCoordinates(rid)
  x = x or ox; y = y or oy; z = z or oz
  set(); return
end

-- rc left/west, right/east, ...
local ox, oy, oz = getRoomCoordinates(rid)
local has = table.contains
for w in string.gmatch(m, "%a+") do
  if has({"west", "left", "w", "l"}, w) then
    x = (x or ox) - 1; y = (y or oy); z = (z or oz)
  elseif has({"east", "right", "e", "r"}, w) then
    x = (x or ox) + 1; y = (y or oy); z = (z or oz)
  elseif has({"north", "top", "n", "t"}, w) then
    x = (x or ox); y = (y or oy) + 1; z = (z or oz)
  elseif has({"south", "bottom", "s", "b"}, w) then
    x = (x or ox); y = (y or oy) - 1; z = (z or oz)
  elseif has({"northwest", "topleft", "nw", "tl"}, w) then
    x = (x or ox) - 1; y = (y or oy) + 1; z = (z or oz)
  elseif has({"northeast", "topright", "ne", "tr"}, w) then
    x = (x or ox) + 1; y = (y or oy) + 1; z = (z or oz)
  elseif has({"southeast", "bottomright", "se", "br"}, w) then
    x = (x or ox) + 1; y = (y or oy) - 1; z = (z or oz)
  elseif has({"southwest", "bottomleft", "sw", "bl"}, w) then
    x = (x or ox) - 1; y = (y or oy) - 1; z = (z or oz)
  elseif has({"up", "u"}, w) then
    x = (x or ox); y = (y or oy); z = (z or oz) + 1
  elseif has({"down", "d"}, w) then
    x = (x or ox); y = (y or oy); z = (z or oz) - 1
  end

end
if x then set(); return end

map.echo([[Where do you want to move the room to?
  You can use direct coordinates or relative directions.]])</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:rc|room coords) (?:v(\d+) )?(.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Delete A Room Alias</name>
					<script>-- rld or room delete &lt;option&gt; - where option is the location or ID of the room
-- you'd like to delete

-- want the current room, but we're lost
if not matches[2] and (not map.currentRoom or not map.roomexists(map.currentRoom)) then map.echo("Don't know where we are at the moment.") return end

-- want another room, but it doesn't exist
if matches[2] and tonumber(matches[2]) and not map.roomexists(matches[2]) then map.echo("v"..matches[2].." doesn't exist.") return end

-- or a relative one
if matches[2] and not tonumber(matches[2]) and not map.relativeroom(map.currentRoom, matches[2]) then map.echo("There is no room "..matches[2].. " of us.") return end

local rid = (not matches[2] and map.currentRoom or (tonumber(matches[2]) or map.relativeroom(map.currentRoom, matches[2])))

local n = getRoomName(rid)
deleteRoom(rid)
map.echo(string.format("Deleted the %s (%d) room.\n", (n ~= "" and n or "''"), rid))
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:rld|room delete) ?(\w+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Room Weight Alias</name>
					<script>-- rw &lt;optional room ID or direction&gt; &lt;weight&gt;, where option is the location
-- or ID of the room whose weight you'd like to change.

local weight = tonumber(matches[3]), room
if matches[2] == '' then room = map.currentRoom
else
  room = tonumber(matches[2]) or map.relativeroom(map.currentRoom, matches[2])
end

if not room or not map.roomexists(room) then
  map.echo("Sorry - which room do you want to set the weight on? I don't know where you are at the moment, if you want to do the current room.")
  return
end

if not weight then
  map.echo("What weight do you want to set on #"..room.."?")
end

local oldweight = getRoomWeight(room)
setRoomWeight(room, weight)

if weight &gt; oldweight then
  map.echo("Increased the room weight on #"..room.." ("..getRoomName(room)..") by "..(weight-oldweight).." to "..weight.." - making it less desirable to travel through.")
elseif weight &lt; oldweight then
  map.echo("Decreased the room weight on #"..room.." ("..getRoomName(room)..") by "..(oldweight-weight).." to "..weight.." - making it more desirable to travel through.")
else
  map.echo("The room weight on #"..room.." ("..getRoomName(room)..") is already "..weight..".")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^rw(?: (\w+))? (\d+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set Exit Weight Alias</name>
					<script>-- rwe &lt;optional room ID, otherwise current&gt; &lt;weight&gt; &lt;exit&gt;, where the weight
-- is a positive number (default for exits is 0). Setting a higher weight will
-- make the exit be less likely to be used.

local room = (matches[2] ~= "" and tonumber(matches[2]) or map.currentRoom)

local weight, exit = tonumber(matches[3]), matches[4]

if not roomExists(room) then map.echo("Room "..room.." doesn't exist. It has to before we can set weights on exits.") return end

setExitWeight(room, exit, weight)

map.echo(string.format("Set the weight on the %d room going %s to %s. If it's a two-way exit, please set the reverse exit as well.", room, exit, weight))</script>
					<command></command>
					<packageName></packageName>
					<regex>^rwe(?: (\d+))? (\d+) (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Create a Link Between Two Rooms Alias</name>
					<script>-- rlk or room link &lt;option&gt; [one] - where option will specify the room and exit
-- to link with. You can also tack on 'one' at the end to make it be a one-way link


-- need the current room, but we're lost
if not map.currentRoom or not map.roomexists(map.currentRoom) then map.echo("Don't know where we are at the moment.") return end

-- make sure the dir is valid
local dir = map.anytolong(matches[3])
if not dir then map.echo(matches[3].." isn't a valid normal exit.") return end

-- if we don't give a room number, then we want to auto-locate an appropriate room nearby.
local otherroom
if matches[2] == "" then
  local w = matches[3]
  local ox, oy, oz, x,y,z = getRoomCoordinates(map.currentRoom)
  local has = table.contains
  if has({"west", "left", "w", "l"}, w) then
    x = (x or ox) - 1; y = (y or oy); z = (z or oz)
  elseif has({"east", "right", "e", "r"}, w) then
    x = (x or ox) + 1; y = (y or oy); z = (z or oz)
  elseif has({"north", "top", "n", "t"}, w) then
    x = (x or ox); y = (y or oy) + 1; z = (z or oz)
  elseif has({"south", "bottom", "s", "b"}, w) then
    x = (x or ox); y = (y or oy) - 1; z = (z or oz)
  elseif has({"northwest", "topleft", "nw", "tl"}, w) then
    x = (x or ox) - 1; y = (y or oy) + 1; z = (z or oz)
  elseif has({"northeast", "topright", "ne", "tr"}, w) then
    x = (x or ox) + 1; y = (y or oy) + 1; z = (z or oz)
  elseif has({"southeast", "bottomright", "se", "br"}, w) then
    x = (x or ox) + 1; y = (y or oy) - 1; z = (z or oz)
  elseif has({"southwest", "bottomleft", "sw", "bl"}, w) then
    x = (x or ox) - 1; y = (y or oy) - 1; z = (z or oz)
  elseif has({"up", "u"}, w) then
    x = (x or ox); y = (y or oy); z = (z or oz) + 1
  elseif has({"down", "d"}, w) then
    x = (x or ox); y = (y or oy); z = (z or oz) - 1
  end

  local carea = getRoomArea(map.currentRoom)
  if not carea then map.echo("Don't know what area are we in.") return end

  otherroom = select(2, next(getRoomsByPosition(carea,x,y,z)))

  if not otherroom then
    map.echo("There isn't a room to the "..w.." that I see - try with an exact room id.") return
  end

else
  if not map.roomexists(matches[2]) then -- check that an explicit other room ID is valid
    map.echo("A room with id "..matches[2].. " doesn't exist.") return
  else
    otherroom = tonumber(matches[2])
  end
end

if map.setExit(map.currentRoom, otherroom, matches[3]) then
  if not matches[4] then map.setExit(otherroom, map.currentRoom, map.ranytolong(matches[3])) end

  map.echo(string.format("Linked %s (%d) to %s (%d) via a %s%s exit.",
    (getRoomName(map.currentRoom) ~= "" and getRoomName(map.currentRoom) or "''"), map.currentRoom, (getRoomName(otherroom) ~= "" and getRoomName(otherroom) or "''"), otherroom, (matches[4] and "one-way " or ''), matches[3]))
else
  map.echo("Couldn't create an exit.")
end
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:rlk|room link) ?(\d+)? (\w+)( one)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Delete a Link Alias</name>
					<script>-- urlk or room unlink &lt;direction&gt; - where direction will specify the direction
-- of the exit to unlink. This function will unlink exits both ways, or one way
-- if there is no incoming exit. 


-- need the current room, but we're lost
if not map.currentRoom or not map.roomexists(map.currentRoom) then map.echo("Don't know where we are at the moment.") return end

-- make sure the dir is valid
local dir = map.anytolong(matches[2])
if not dir then map.echo(matches[2].." isn't a valid normal exit.") return end

-- gone already?
if not getRoomExits(map.currentRoom)[dir] then map.echo(dir.." link doesn't exist already.") end

-- locate the room on the other end, so we can unlink it from there as well if necessary
local otherroom
if getRoomExits(getRoomExits(map.currentRoom)[dir])[map.ranytolong(dir)] then
  otherroom = getRoomExits(map.currentRoom)[dir]
end

if map.setExit(map.currentRoom, -1, dir) then
  if otherroom then
    if map.setExit(otherroom, -1, map.ranytolong(dir)) then
      map.echo(string.format("Deleted the %s exit from %s (%d).",
        dir, getRoomName(map.currentRoom), map.currentRoom))
     else map.echo("Couldn't delete the incoming exit.") end
  else
    map.echo(string.format("Deleted the one-way %s exit from %s (%d).",
      dir, getRoomName(map.currentRoom), map.currentRoom))
  end
else
  map.echo("Couldn't delete the outgoing exit.")
end
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:urlk|room unlink) (\w+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add/delete Doors Alias</name>
					<script>-- rd &lt;optional room ID, or current if none&gt; &lt;direction&gt; &lt;door status&gt;
-- Direction can be one of the following: e,s,w,n,ne,se,sw,ne. 
-- Door status can be open or o, closed or c, locked or l, clear or gone.
-- To delete a room, use clear or gone. Setting doors is one-way - to set
-- two-way doors, use the alias from the opposite direction.

local room = (matches[2] ~= "" and tonumber(matches[2]) or map.currentRoom)

local direction, status = matches[3], matches[4]

if not roomExists(room) then map.echo("Room "..room.." doesn't exist. It has to before we can make doors in it.") return end

local validdirs = {'e', 's', 'w', 'n', 'ne', 'se', 'sw', 'nw', 'in', 'out', 'up', 'down'}

if not table.contains(validdirs, direction) then
  map.echo("Can't make a door in the '"..direction.."' direction - available choices are:\n  "..table.concat(validdirs, ', '))
  return
end

local statusnum

if status == "" or status == "open" or status == "o" then
  statusnum = 1
elseif status == "closed" or status ==  "c" then
  statusnum = 2
elseif status == "locked" or status ==  "l" then
  statusnum = 3
elseif status == "clear" or status == "gone" then
  statusnum = 0
end

if not statusnum then map.echo("Unrecognized option - a door can be open, closed, locked or gone.") return end

setDoor(room, direction, statusnum)

if statusnum == 0 then
  map.echo("OK, door removed.")
else
  map.echo("OK, door added/adjusted.")
end</script>
					<command></command>
					<packageName></packageName>
					<regex>^rd(?: (\d+))? (\w+)(?: (\w+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Set a Room Character Alias</name>
					<script>-- rcc &lt;character&gt; or rcc &lt;character&gt; &lt;room ID&gt; - where the character is one 
-- letter/number/symbol.

local room = matches[3] or map.currentRoom
room = tonumber(room) or map.relativeroom(map.currentRoom, room)
if not room or not map.roomexists(room) then
  map.echo("Sorry - which room do you want to put this character in? I don't know where you are at the moment, if you want to do the current room.")
  return
end

local char = matches[2]

if char == "clear" then
  setRoomChar(room, ' ')
  map.echo("Cleared the character from "..room.." ("..getRoomName(room)..")")
else
  setRoomChar(room, char)
  map.echo("Set the "..char:sub(1,1).." character on "..room.." ("..getRoomName(room)..")")
end
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^rcc ([^ ]+)(?: (\w+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add a Special Exit Alias</name>
					<script>-- spe &lt;other room&gt; &lt;command&gt; or exit special &lt;other room&gt; &lt;command&gt;, where other
-- room will specify the room to link with, and command the command to us to get
-- to that room.

-- spe clear and spe list match on this
if matches[2] == "clear" or matches[2] == "list" then return end

-- need the current room, but we're lost
if not map.currentRoom or not map.roomexists(map.currentRoom) then map.echo("Don't know where we are at the moment.") return end

local otherroom = tonumber(matches[2]) or map.relativeroom(map.currentRoom, matches[2])

-- need the another room, but it doesn't actually exist
if not otherroom or not map.roomexists(otherroom) then map.echo(matches[2].." doesn't exist.") return end

addSpecialExit(map.currentRoom, tonumber(otherroom), matches[3])
addSpecialExit(map.currentRoom, tonumber(otherroom), matches[3])
map.echo(string.format("Added special exit with command '%s' to %s (%d).", matches[3], getRoomName(otherroom), otherroom))
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:spe|exit special) (\w+) (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add a Special Exit From One Remote Room To Another Alias</name>
					<script>-- spev &lt;from room&gt; &lt;to room&gt; &lt;command&gt; - This different than spe, which allows
-- you to link only the current room to another room - this command doesn't
-- require you to be in the starting room. 

local room1, room2 = tonumber(matches[2]), tonumber(matches[3])

if not room1 or not map.roomexists(room1) then
  map.echo("Room #"..matches[2].." doesn't exist - create it first, or make sure you got the room ID right?")
  return
end

if not room2 or not map.roomexists(room2) then
  map.echo("Room #"..matches[3].." doesn't exist - create it first, or make sure you got the room ID right?")
  return
end

addSpecialExit(room1, room2, matches[4])
map.echo(string.format("Added special exit with command '%s' to from %s (%d) to %s (%d).", matches[4], getRoomName(room1), room1, getRoomName(room2), room2))</script>
					<command></command>
					<packageName></packageName>
					<regex>^spev (\d+) (\d+) (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Clear All Special Exits Alias</name>
					<script>-- spe clear &lt;option&gt; or exit special clear &lt;option&gt; - where option is the
-- location or the ID of the room you'd like to clear all special exits in. 

-- want the current room, but we're lost
if not matches[2] and (not map.currentRoom or not map.roomexists(map.currentRoom)) then map.echo("Don't know where we are at the moment.") return end

-- want another room, but it doesn't exist
if matches[2] and tonumber(matches[2]) and not map.roomexists(matches[2]) then map.echo("v"..matches[2].." doesn't exist.") return end

-- or a relative one
if matches[2] and not tonumber(matches[2]) and not map.relativeroom(map.currentRoom, matches[2]) then map.echo("There is no room "..matches[2].. " of us.") return end

local rid = (not matches[2] and map.currentRoom or (tonumber(matches[2]) or map.relativeroom(map.currentRoom, matches[2])))

clearSpecialExits(rid)
map.echo(string.format("Cleared all special exits in %s (%d).\n", getRoomName(rid), rid))</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:spe clear|exit special clear) ?(\w+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Move Room To Another Area Alias</name>
					<script>-- room area &lt;different area&gt; - will move the current room to another area you're in

map.roomArea(matches[2], matches[3])</script>
					<command></command>
					<packageName></packageName>
					<regex>^room area (?:v(\d+) )?(.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add a Room Label Alias</name>
					<script>-- room label &lt;optional another room ID&gt; &lt;optional foreground color&gt; &lt;optional background color&gt; my message

map.roomLabel(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^room label (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>View/delete Area Labels Alias</name>
					<script>-- area labels &lt;area name&gt; - will show the labels in the given area
map.areaLabels(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^area labels ?(.+)?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Create An Area Alias</name>
					<script>-- area add &lt;area name&gt; - will create a new area and automatically give it an ID.

local t = getAreaTable(); local tr = {}; for k,v in pairs(t) do tr[v] = k end
local newid = table.maxn(tr) + 1

setAreaName( newid, matches[2] )
map.echo(string.format("Created new area %s (%d)", matches[2], newid))
centerview(map.currentRoom)</script>
					<command></command>
					<packageName></packageName>
					<regex>^area add (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Delete An Area Alias</name>
					<script>-- area delete &lt;area name&gt; - will delete the given area

map.deleteArea(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^area delete (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Cancel Area Deletion Alias</name>
					<script>-- cancel area deletion - stop area deletion. This will not restore deleted rooms,
-- merely pauses the process.

if not map.deletingarea then map.echo("I wasn't deleting any areas already.") return end

local areaname = map.deletingarea.areaname
map.deletingarea = nil

map.echo("Stopped deleting rooms in the '"..areaname.."'. The area is partially missing its rooms now, you'll want to restart the process to finish it.")</script>
					<command></command>
					<packageName></packageName>
					<regex>^cancel area deletion$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Rename An Area Alias</name>
					<script>-- area rename &lt;new area name&gt; - will rename the current area you're in to the new name
map.renameArea(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^area rename (.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Create Map Feature Alias</name>
					<script>-- feature create &lt;feature&gt; [char &lt;room character&gt;] - will create a new map
-- feature for use on rooms. You can also optionally add a character mark to
-- the feature, which will be set when a map feature is added to a room. 
-- Note: Map feature names are not allowed to contain numbers. 

map.createMapFeature(matches[2]:trim(), (matches[3] and matches[3]:trim()))</script>
					<command></command>
					<packageName></packageName>
					<regex>^feature create (.+?)(?: char (.+))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Add Map Feature To Room Alias</name>
					<script>-- room create feature [v&lt;room id&gt;] &lt;feature&gt;* or *rcf [v&lt;room id&gt;] &lt;feature&gt;
-- adds a created map feature to the room. If the map feature is associated with
-- a character mark, it will be set on the room and existing marks get overwritten.
-- The room number to add the feature to can be given with the optional argument
-- (note that there is no space between the v and the ID). 

map.roomCreateMapFeature(matches[3], matches[2] == "" and map.currentRoom or tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:room create feature|rcf) (?:v(\d+) )?(.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Delete Map Feature From Room Alias</name>
					<script>-- room delete feature [v&lt;room id&gt;] &lt;feature&gt;* or *rdf [v&lt;room id&gt;] &lt;feature&gt;
-- removes a map feature from the room. If the map feature is associated with
-- a character mark and its set on the room, a random character mark from the
-- other map features on the room is chosen to replace it. The room number to
-- delete the feature from can be given with the optional argument (note that
-- there is no space between the v and the ID). 

map.roomDeleteMapFeature(matches[3], matches[2] == "" and map.currentRoom or tonumber(matches[2]))</script>
					<command></command>
					<packageName></packageName>
					<regex>^(?:room delete feature|rdf) (?:v(\d+) )?(.+)$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Delete Map Feature Alias</name>
					<script>-- feature delete &lt;feature&gt;* deletes a map feature and removes it from all rooms

map.deleteMapFeature(matches[2]:trim())</script>
					<command></command>
					<packageName></packageName>
					<regex>^feature delete (.+)$</regex>
				</Alias>
			</AliasGroup>
			<AliasGroup isActive="yes" isFolder="yes">
				<name>Map Sharing Aliases</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex></regex>
				<Alias isActive="yes" isFolder="no">
					<name>Save Map Alias</name>
					<script>if saveMap(getMudletHomeDir() .. "/map.dat") then
  map.echo("Map saved.\n")
else
  map.echo("Error.  Map NOT saved.\n")
end
				</script>
					<command></command>
					<packageName></packageName>
					<regex>^map save$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Load Map Alias</name>
					<script>map.load_map(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map load(?: (.*))?$</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Import Map Area Alias</name>
					<script>map.import_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map import (.*)</regex>
				</Alias>
				<Alias isActive="yes" isFolder="no">
					<name>Export Map Area Alias</name>
					<script>map.export_area(matches[2])</script>
					<command></command>
					<packageName></packageName>
					<regex>^map export (.*)</regex>
				</Alias>
			</AliasGroup>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>hb brief</name>
			<script></script>
			<command>hpbrief</command>
			<packageName></packageName>
			<regex>^hb$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>杂项</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>回血</name>
				<script></script>
				<command>yun recover</command>
				<packageName></packageName>
				<regex>^yc$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回气</name>
				<script></script>
				<command>yun regenerate</command>
				<packageName></packageName>
				<regex>^yr$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>最大打坐</name>
				<script></script>
				<command>dazuo max</command>
				<packageName></packageName>
				<regex>^dm$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>get all</name>
				<script>tempTimer(1, function() 
  expandAlias("gc2")
  tempTimer(1, function() 
    expandAlias("gc3")
    tempTimer(1, function() expandAlias("gc4") end)
  end)
end)


</script>
				<command>get all from corpse</command>
				<packageName></packageName>
				<regex>^gc$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>抄经</name>
				<script></script>
				<command>ask sengren about job;;node walk sms_sjy</command>
				<packageName></packageName>
				<regex>^chaojing$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>抄经返回</name>
				<script></script>
				<command>node walk sjy_sms</command>
				<packageName></packageName>
				<regex>^jing_back$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>疗伤</name>
				<script></script>
				<command>yun heal</command>
				<packageName></packageName>
				<regex>^yh$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>上装</name>
				<script>  send("wear cloth")
  send("wear head")
  send("wear waist")
  send("wear wrists")
  send("wear surcoat")
  send("wear hands")
  send("wear armor")
  send("wear ring")
  send("wear necklace")
  send("wield flute")

  </script>
				<command></command>
				<packageName></packageName>
				<regex>^install_all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>加力</name>
				<script></script>
				<command>yun powerup;;yun qi</command>
				<packageName></packageName>
				<regex>^yp$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>get all</name>
				<script></script>
				<command>get all</command>
				<packageName></packageName>
				<regex>^ga$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gz</name>
				<script></script>
				<command>get xin from corpse;;get gold from corpse;;get silver from corpse</command>
				<packageName></packageName>
				<regex>^gz$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>node walk</name>
				<script>send("node walk "..matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^# (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回兰</name>
				<script></script>
				<command>yun inspire</command>
				<packageName></packageName>
				<regex>^yi$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>walk-p</name>
				<script></script>
				<command>walk -p</command>
				<packageName></packageName>
				<regex>^wp$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>cancel任务</name>
				<script>job_fail()</script>
				<command></command>
				<packageName></packageName>
				<regex>^fail$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>任务完成</name>
				<script>job_done()</script>
				<command></command>
				<packageName></packageName>
				<regex>^done$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>要任务</name>
				<script>ask_job()</script>
				<command></command>
				<packageName></packageName>
				<regex>^job$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>kill</name>
				<script>send("kill "..matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^k (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>jifa all</name>
				<script></script>
				<command></command>
				<packageName></packageName>
				<regex>^jfall$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>jifa all</name>
				<script></script>
				<command>jifa strike luoying-zhang;;jifa sword yuxiao-jian;;jifa force bihai-shengong;;jifa hand fuxue-shou;;jifa finger tanzhi-shentong;;jifa dodge luoying-shenfa</command>
				<packageName></packageName>
				<regex>^jifa all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gc2</name>
				<script></script>
				<command>get all from corpse 2</command>
				<packageName></packageName>
				<regex>^gc2$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gc3</name>
				<script></script>
				<command>get all from corpse 3</command>
				<packageName></packageName>
				<regex>^gc3$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gc4</name>
				<script></script>
				<command>get all from corpse 4</command>
				<packageName></packageName>
				<regex>^gc4$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>gc1</name>
				<script></script>
				<command>get all from corpse</command>
				<packageName></packageName>
				<regex>^gc1$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>捡石头</name>
				<script></script>
				<command>get stone from corpse</command>
				<packageName></packageName>
				<regex>^gstone$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>慕容</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>杀贼</name>
				<script>expandAlias("kill jiazei")
--expandAlias("pft jiazei")</script>
				<command></command>
				<packageName></packageName>
				<regex>^kz$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mback</name>
				<script>send(murong_task["current_mrf_location"])</script>
				<command></command>
				<packageName></packageName>
				<regex>^mback$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>拜庄</name>
				<script></script>
				<command>ask girl about 拜庄;;enter boat</command>
				<packageName></packageName>
				<regex>^baizhuang$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>murong go</name>
				<script>if murong_task["murong_target_city"] == "衢州" then
  send("node walk mrf_qz1")
elseif murong_task["murong_target_city"] == "温州府" then
  send("node walk mrf_wenz")
elseif murong_task["murong_target_city"] == "上饶" then
  send("node walk mrf_sr")
elseif murong_task["murong_target_city"] == "临安府" then
  send("node walk mrf_hz")
elseif murong_task["murong_target_city"] == "义兴县" then
  send("node walk mrf_yx")
elseif murong_task["murong_target_city"] == "南昌" then
  send("node walk mrf_nc")
elseif murong_task["murong_target_city"] == "嘉兴" then
  send("node walk mrf_jx")  
  
elseif murong_task["murong_target_city"] == "处州府" then
  send("node walk mrf_czf1")  
elseif murong_task["murong_target_city"] == "姑苏慕容" then
  send("node walk mrf_gsmr")   
elseif murong_task["murong_target_city"] == "岳王墓" then
  send("node walk mrf_yfm")  
elseif murong_task["murong_target_city"] == "建宁府" then
  send("node walk mrf_jn")  
elseif murong_task["murong_target_city"] == "建康府北城" then
  send("node walk mrf_jk")  
elseif murong_task["murong_target_city"] == "建康府南城" then
  send("node walk mrf_cym")  
  
elseif murong_task["murong_target_city"] == "归云庄" then
  send("node walk mrf_gyz")  
elseif murong_task["murong_target_city"] == "明州" then
  send("node walk mrf_mz")   
elseif murong_task["murong_target_city"] == "杭州提督府" then
  send("node walk mrf_tdf")  
elseif murong_task["murong_target_city"] == "武夷山" then
  send("node walk mrf_wuyi")  
elseif murong_task["murong_target_city"] == "江州" then
  send("node walk mrf_jz")  
elseif murong_task["murong_target_city"] == "泉州" then
  send("node walk mrf_qz")  
  
elseif murong_task["murong_target_city"] == "湖州" then
  send("node walk mrf_hzf")  
elseif murong_task["murong_target_city"] == "潮州" then
  send("node walk mrf_cz")   
elseif murong_task["murong_target_city"] == "绍兴府" then
  send("node walk mrf_sx")  
elseif murong_task["murong_target_city"] == "西湖" then
  send("node walk mrf_xhab")  
elseif murong_task["murong_target_city"] == "铜官山" then
  send("node walk mrf_tgz")  
elseif murong_task["murong_target_city"] == "镇江" then
  send("node walk mrf_zj")    
  
elseif murong_task["murong_target_city"] == "闽中" then
  send("node walk mrf_fz") 
elseif murong_task["murong_target_city"] == "雁荡山" then
  send("node walk mrf_yds")   
elseif murong_task["murong_target_city"] == "龙泉镇" then
  send("node walk mrf_lqz") 
elseif murong_task["murong_target_city"] == "雁荡山" then
  send("node walk mrf_yds")   
  
elseif murong_task["murong_target_city"] == "桃花岛" then
  send("node walk mrf_mz")  
  elseif murong_task["murong_target_city"] == "无锡" then
  send("node walk mrf_wx") 
               
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^mgo$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>where</name>
				<script>if mrf_or_pozhen == "mrf" then
  echo("mrf: --&gt; "..murong_task["murong_target_city"]..":"..murong_task["murong_target_room"])
elseif mrf_or_pozhen == "pozhen" then
  echo("pozhen: --&gt; "..pozhen_task.city..":"..pozhen_task.room)
else if mrf_or_pozhen == "hsz" then
  echo("pozhen: --&gt; ".._task.city..":".._task.room)
end
end  
  </script>
				<command></command>
				<packageName></packageName>
				<regex>^where$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>Test script</name>
			<script>mapper:debugCurrentRegion()
mapper:debugAllRooms()</script>
			<command></command>
			<packageName></packageName>
			<regex>^testscript$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>爵位任务</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>add luren</name>
				<script>add_to_luren_set()</script>
				<command></command>
				<packageName></packageName>
				<regex>^addlr$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>clear luren set</name>
				<script>clear_luren_set()
echo("--done!--\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^cluren$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>请求任务</name>
				<script></script>
				<command>ask shaoyin about 任务信息</command>
				<packageName></packageName>
				<regex>^jjob$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>处理路人</name>
				<script>local target = matches[2]
send("l "..target)
tempTimer(2, function()
  add_to_luren_set()
  tempTimer(2, function()
    send("ask "..target.." about 消息")
  end) 
end)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^ll (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>补消息</name>
				<script>--echo("--&gt;:"..matches[2])
--echo("++&gt;:"..matches[3])

if matches[2] and matches[3] then
  set_message(matches[2], matches[3])
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^bu (.*)\s+(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>领赏</name>
				<script></script>
				<command>ask shaoyin about 领赏</command>
				<packageName></packageName>
				<regex>^jdone$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>指认</name>
				<script>if matches[2] then
  send("ask "..matches[2].." about 盗贼")
end</script>
				<command></command>
				<packageName></packageName>
				<regex>^zr\s(.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>结果</name>
				<script>get_result()</script>
				<command></command>
				<packageName></packageName>
				<regex>^jresult$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>人工分析</name>
				<script>identify_all_luren_with_true_clue()
identify_all_luren_with_opposite_clue()</script>
				<command></command>
				<packageName></packageName>
				<regex>^jshougong$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>back_to_somewhere</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>回扬州</name>
				<script>back_to_yangzhou()</script>
				<command></command>
				<packageName></packageName>
				<regex>^byz$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>扬州去江边</name>
				<script></script>
				<command>s;;s;;s;;s;;su;;se;;su;;e;;ask guan about jiang</command>
				<packageName></packageName>
				<regex>^jiangbian$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回杭州</name>
				<script>back_to_hz()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bhz$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回破阵</name>
				<script>back_to_pozhen()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bp$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回长安</name>
				<script>back_to_changan()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bca$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回洛阳</name>
				<script>back_to_luoyang()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bly$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>交花</name>
				<script>back_to_hua()</script>
				<command></command>
				<packageName></packageName>
				<regex>^hua$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>back to key room</name>
				<script>back_to_key_room()</script>
				<command></command>
				<packageName></packageName>
				<regex>^back$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回韩世忠</name>
				<script>back_to_hsz()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bh$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>回孟之经</name>
				<script>back_to_mzj()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bmeng$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>back to mrf</name>
				<script>back_to_mrf()</script>
				<command></command>
				<packageName></packageName>
				<regex>^bmr$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>陆家庄</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>交古董</name>
				<script>send("give lu "..lujiazhuang.gudong_id)</script>
				<command></command>
				<packageName></packageName>
				<regex>^ggd$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>普通任务</name>
				<script></script>
				<command>unset forced_act;;jiali 0;;ask lu about job</command>
				<packageName></packageName>
				<regex>^quest$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>pozhen</name>
				<script>keep_back_path()</script>
				<command>yp;;zhanbu -maze</command>
				<packageName></packageName>
				<regex>^zhen$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>桃花岛</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>拂穴</name>
				<script></script>
				<command>perform hand.fuxue</command>
				<packageName></packageName>
				<regex>^phf$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>软猬甲</name>
				<script>send("e;;n;;w;;ask cheng about 黄蓉;;e;;s;;w")
tempTimer(1, function() 
  send("w;;w;;s;;s")
  tempTimer(2, function() 
    send("ask gu about 蓉姐姐;;n;;n;;w;;nu;;ed;;enter door")
    tempTimer(3, function() send("ask huang about 软猬甲;;out;;wu;;sd;;e;;e;;e") end)
  end)
end)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^rwj$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>弹指</name>
				<script>send("perform finger.tan "..matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^tan (.*)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>弹贼</name>
				<script>expandAlias("pft jiazei")</script>
				<command></command>
				<packageName></packageName>
				<regex>^tt$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>箫花</name>
				<script></script>
				<command>perform sword.xiaohua</command>
				<packageName></packageName>
				<regex>^ps$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>start jiqi</name>
			<script>start_jiqi()</script>
			<command></command>
			<packageName></packageName>
			<regex>^start_jiqi$</regex>
		</Alias>
		<Alias isActive="no" isFolder="no">
			<name>new_dir</name>
			<script>go_dir(matches[1])
--mapper:go(matches[1])</script>
			<command></command>
			<packageName></packageName>
			<regex>^(e|s|w|n|u|d|ne|nw|sw|se|eu|ed|su|sd|wu|wd|nu|nd|enter|out|neu|ned|nwu|nwd|swu|swd|seu|sed)$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>save map</name>
			<script>save_maps()</script>
			<command></command>
			<packageName></packageName>
			<regex>^save_map$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>load map</name>
			<script>load_maps()</script>
			<command></command>
			<packageName></packageName>
			<regex>^load_map$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>梅庄</name>
			<script></script>
			<command>knock gate 4;;knock gate 2;;knock gate 5;;knock gate 3</command>
			<packageName></packageName>
			<regex>^mei$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>装石子</name>
			<script></script>
			<command>put shi zi in lupi dai</command>
			<packageName></packageName>
			<regex>^shi$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>曼陀小路</name>
			<script></script>
			<command>n;;w;;s;;s;;e;;e;;w</command>
			<packageName></packageName>
			<regex>^xiaolu$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>曼陀小路回</name>
			<script></script>
			<command>e;;s;;n;;w;;n;;n;;e;;s;;e</command>
			<packageName></packageName>
			<regex>^xiaoluhui$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>临安小院</name>
			<script></script>
			<command>say 红花老祖本姓朱 为救苍生下凡来</command>
			<packageName></packageName>
			<regex>^xiaoyuan$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>迷魂阵</name>
			<script></script>
			<command>e;;n;;w;;s;;w;;e;;e;;e;;n</command>
			<packageName></packageName>
			<regex>^mihun$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>去梅庄</name>
			<script></script>
			<command>w;;nw;;n;;e;;s;;se;;sw</command>
			<packageName></packageName>
			<regex>^tomei$</regex>
		</Alias>
		<Alias isActive="yes" isFolder="no">
			<name>梅庄回</name>
			<script></script>
			<command>ne;;nw;;n;;w;;s;;se;;e</command>
			<packageName></packageName>
			<regex>^meihui$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>万安塔</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>进塔</name>
				<script></script>
				<command>ask ke about 进塔</command>
				<packageName></packageName>
				<regex>^wanan$</regex>
			</Alias>
		</AliasGroup>
		<Alias isActive="yes" isFolder="no">
			<name>short_cut</name>
			<script>short_cut_to(matches[2])</script>
			<command></command>
			<packageName></packageName>
			<regex>^@ (.*)$</regex>
		</Alias>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>test group</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>display key room</name>
				<script>display_key_room()</script>
				<command></command>
				<packageName></packageName>
				<regex>^show_krm$</regex>
			</Alias>
		</AliasGroup>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>地图相关</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>显示回去路径</name>
				<script>show_back_path()</script>
				<command></command>
				<packageName></packageName>
				<regex>^show_back$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>显示key room</name>
				<script>display_key_room()</script>
				<command></command>
				<packageName></packageName>
				<regex>^show_kroom$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>跑图</name>
				<script>mapper.start()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^map draw$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>保存地图</name>
				<script>local name = matches[2] or "mapper_map"
mapper.save(getMudletHomeDir() .. "/maps/"..name..".lua")</script>
				<command></command>
				<packageName></packageName>
				<regex>^msave(?:\s+(\S+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>加载地图</name>
				<script>local name = matches[2]
nav.loadMap(name)
-- 会加载 &lt;配置目录&gt;/maps/wuxi1.lua
</script>
				<command></command>
				<packageName></packageName>
				<regex>^mload(?:\s+(\S+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>mgoto</name>
				<script>nav.gotoToken(matches[2])
</script>
				<command></command>
				<packageName></packageName>
				<regex>^goto (\S+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>暂停测绘</name>
				<script>mapper.mappingEnabled = false
cecho("\n&lt;yellow&gt;[Mapper] 测绘已暂停。\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^map off$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>继续测绘</name>
				<script>mapper.mappingEnabled = true
cecho("\n&lt;green&gt;[Mapper] 测绘已恢复。\n")</script>
				<command></command>
				<packageName></packageName>
				<regex>^map on$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>reset 地图</name>
				<script>mapper.resetRuntimeMap()</script>
				<command></command>
				<packageName></packageName>
				<regex>^map reset$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>显示单个房间数据</name>
				<script>mapper.showRoom()
</script>
				<command></command>
				<packageName></packageName>
				<regex>^show room$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>显示两个房间之间的路径</name>
				<script>local a = matches[2]
local b = matches[3]
nav.pathCommand(a, b)
</script>
				<command></command>
				<packageName></packageName>
				<regex>^path\s+(\S+)\s*(\S*)$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>gui-drop</name>
			<packageName>gui-drop</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>workaround for add</name>
				<packageName></packageName>
				<script>-- Once Geyser.add2 is in this is not needed anymore
local addwrapper = Adjustable.Container.add
function Adjustable.Container:add(window, cons)
  addwrapper(self, window, cons)
  if self.hidden then
    tempTimer(0, function() self:hide() end)
  end
  if self.auto_hidden then
    tempTimer(0, function() self:hide(true) end)
  end
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createDropManager</name>
				<packageName></packageName>
				<script>GUIDropManager = GUIDropManager or {}
GUIDropImages = GUIDropImages or {}
function GUIDropManager.createDropManager()
    GUIDropManager.script = "--GUIDropManager\n"
    
    local labelscript = [[%s = %s or Geyser.Label:new({name = "%s", x="%s", y="%s", width="%s", height="%s"%s}, %s)
    %s:setStyleSheet("border-image: url(%s);")
    %s.imgName = "%s"
    %s:setDropImg()
    
    ]]
    local containerscript = [[%s = %s or Adjustable.Container:new({name = "%s", x = "%s", y = "%s", width = "%s", height = "%s", lockStyle = "full", padding = 0, noLimit = true%s%s}%s)
    
    ]]
    local function createFname(imgName)
        return [["..getMudletHomeDir().."/GUIDropImages/]].. imgName
    end
    for k,v in pairs(GUIDropImages) do
        
        if v.type == "adjustablecontainer" then
            local container = ""
            local containervar = ""
            local locked = ""
            if v.windowname ~= "main" then
                container = v.containervar or getKeyFrom(v.container, ".container")
                if not container then
                    container = "Geyser.windowList."..v.windowname.."Container.windowList."..v.windowname
                end
                containervar = [[, containervar = "]]..container..[["]]
                v.containervar = container
                container = ", "..container
            end
            if v.locked then
                locked = ", locked = true"
            end
            GUIDropManager.script = GUIDropManager.script..string.format(containerscript, v.name, v.name, v.name, v.x, v.y, v.width, v.height, locked, containervar, container)
        end
        
    end
    
    
    for k,v in pairs(GUIDropImages) do    
        if v.type == "label" then
            v.fname = v.fname or createFname(v.imgName)
            local clickthrough = ""
            if v.clickthrough then
                clickthrough = ", clickthrough = true"
            end
            GUIDropManager.script = GUIDropManager.script..string.format(labelscript, v.name, v.name, v.name, v.x, v.y, v.width, v.height, clickthrough, v.container.container.name, v.name, v.fname, v.name, v.imgName, v.container.container.name)
        end    
    end
    
    if not setScript("GUIDropManager", GUIDropManager.script, 2) then
        display(setScript("GUIDropManager", GUIDropManager.script, 2))
    end
    
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Global Variable Functions</name>
				<packageName></packageName>
				<script>function GUIDropManager.getKeyFrom(value, exclude, depth, table, iteration)
    exclude = exclude or false
    depth = depth or 3
    table = table or _G
    local tempTable = {}
    iteration = iteration or 1
    if iteration &gt; depth then
        return nil, "key not found"
    end
    for k,v in pairs(table) do
        if type(v) == "table" and k ~= "_G" then
            for k1,v1 in pairs(v) do
                tempTable[k.."."..k1] = v1
            end
        end
        if v == value and not string.find(k, exclude) then
            return k
        end
    end
    return GUIDropManager.getKeyFrom(value, exclude, depth, tempTable, iteration + 1)    
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>createDropScript</name>
				<packageName></packageName>
				<script>function GUIDropManager.createDropScript()
    if exists("GUIDropManager", "script") == 0 then
        permGroup("GUIDropManager", "script")
    end
    if exists("GUIDropManager", "script") &lt; 2 then
        permScript("GUIDropManager", "GUIDropManager","--GUIDropManager Script")
        enableScript("GUIDropManager")
        echo("DropScript created!")
    end
    GUIDropManager.createDropManager()
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ImageDrop</name>
				<packageName></packageName>
				<script>function GUIDropManager.ImageDrop(event, fname, suffix, posx, posy, consoleName)
    Adjustable.Container:saveAll()
    local acceptable_suffix = {"png", "jpg", "bmp", "jpeg"}
    
    if not table.contains(acceptable_suffix, suffix) then
        return
    end
    local main_width, main_height = getMainWindowSize()
    local image_width, image_height = getImageSize(fname)
    
    if not image_width then 
        return 
    end
    local image_ratio = image_height / image_width
    if image_width &gt; main_width-50 or image_height &gt; main_height-50 then
        image_height = main_height-50
        image_width = (main_height-50) / image_ratio
    end
    
    posx = math.max(0, posx - (image_width/10))
    posy = math.max(0, posy - (image_height/10))
    local imgName = fname:match("([^%/]+)%..+$")
    
    if not (io.exists(getMudletHomeDir() .. "/GUIDropImages/")) then
        lfs.mkdir(getMudletHomeDir() .. "/GUIDropImages/")
    end
    
    --copy file to my profile location
    local imgLocation = getMudletHomeDir() .. "/GUIDropImages/".. imgName.. ".".. suffix
    local infile = io.open(fname, "rb")
    if not (io.exists(imgLocation)) then 
        local instr = infile:read("*ab")
        infile:close()
        local outfile = io.open(imgLocation, "wb")
        outfile:write(instr)
        outfile:close()
    end
    
    local acontainer
    if consoleName == "main" then
        acontainer = Geyser
    else
        acontainer = Geyser.windowList[consoleName.."Container"].windowList[consoleName]
    end
    --convert filename to be a feasible variablename
    local containername = string.gsub(imgName,"[^_%w]","")
    --if filename is only composed of number convert it
    if not containername:match("%D+") then
        containername = "defaultName"
    end
    
    --Check if image exists already and create new containername by adding +1 to the name
    if GUIDropImages[containername] or _G[containername] then 
        while GUIDropImages[containername] or _G[containername] do
            counter = containername:match("%d+$")
            if counter ~= nil then     
                containername = containername:sub(1,-(string.len(counter)+1))
            end
            counter = counter or 0
            counter = counter + 1
            containername = containername..counter
        end
    end
    
    containername = containername
    local labelname = containername.."Label"
    
    GUIDropImages[containername] = Adjustable.Container:new({name="GUIDropImages."..containername, lockStyle = "full", padding = 0, noLimit = true, autoLoad = false, autoSave = false} , acontainer)
    GUIDropImages[containername]:move(posx, posy)
    GUIDropImages[containername]:resize(image_width, image_height)
    GUIDropImages[containername]:setPercent(true, true)
    GUIDropImages[labelname] = Geyser.Label:new({name = "GUIDropImages."..labelname, x=0, y=0, width="100%", height="100%", clickthrough = true}, GUIDropImages[containername])
    
    GUIDropImages[labelname].fname = [["..getMudletHomeDir().."/GUIDropImages/]].. imgName .. ".".. suffix
    GUIDropImages[labelname].imgName = imgName .. ".".. suffix
    GUIDropManager.createDropScript()
end
registerAnonymousEventHandler("sysDropEvent", "GUIDropManager.ImageDrop")</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>AdjustableContainer Additions</name>
				<packageName></packageName>
				<script>local function deleteImage(s) 
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")] = nil  
    GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")] = nil
    table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, s.name))
    Adjustable.Container.all[s.name] = nil
    if io.exists(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua") then
        os.remove(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua")
    end    
    s:hide()
end

local function convertToLabel(s)
    local labelscript = [[%s = %s or Geyser.Label:new({name = "%s", x="%s", y="%s", width="%s", height="%s"}%s)
    %s:setStyleSheet("border-image: url(%s);")
    ]]
    local container = GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")]
    local labelname = string.gsub(s.name.."Label", "GUIDropImages%.","")
    GUIDropImages[labelname]:changeContainer(container.container)
    GUIDropImages[labelname]:move(container.x, container.y)
    GUIDropImages[labelname]:resize(container.width, container.height)
    
    if exists("GUIDropManager", "script") == 0 then
        permGroup("GUIDropManager", "script")
    end
    
    if exists("GUIDropLabels", "script") == 0 then
        permScript("GUIDropLabels", "GUIDropManager","--GUIDropLabels Script")
        enableScript("GUIDropLabels")
        echo("LabelScript created!")
    end
    
    if container.containervar then
        container.containervar = ","..container.containervar
    else
        container.containervar = ""
    end
    
    local label = GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")]
    labelname = labelname:sub(1,-6)
    labelscript = string.format(labelscript, labelname, labelname, labelname, label.x, label.y, label.width, label.height, container.containervar, labelname, [["..getMudletHomeDir().."/GUIDropImages/]].. label.imgName)
    
    appendScript("GUIDropLabels", labelscript)
    
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")]:hide()
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")] = nil
    GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")] = nil
    table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, s.name))
    Adjustable.Container.all[s.name] = nil
    if io.exists(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua") then
        os.remove(getMudletHomeDir().."/AdjdustableContainer/"..s.name..".lua")
    end  
end


function Adjustable.Container:setDropImg()
    if self.dropImg then
        return
    end
    
    self.dropImg = true
    self.adjLabelstyle =[[
    QLabel::hover{ background-color: rgba(0,0,0,0%); border: 1px solid grey;}
    QLabel::!hover{ background-color: rgba(0,0,0,0%);}]]
    if not self.locked then
        self.adjLabel:setStyleSheet(self.adjLabelstyle)
    else
        self.adjLabel:setStyleSheet([[border:0;]])
    end
    self:setTitle(" ")
    self.minimizeLabel:raise()
    self.exitLabel:raise()
    
    self:newCustomItem("setAbsolute", function(s) s:setAbsolute(true, true) self:save() end)
    self:newCustomItem("setPercent",  function(s) s:setPercent(true, true)  self:save() end)
    self:newCustomItem("deleteImage", function(s) deleteImage(s) GUIDropManager.createDropManager() Adjustable.Container:saveAll() end)
    self:newCustomItem("convertToLabel",  function(s) convertToLabel(s) GUIDropManager.createDropManager() Adjustable.Container:saveAll() end)
    self:newCustomItem("saveAll",  function(s) Adjustable.Container:saveAll() end)
    self:newCustomItem("loadAll",  function(s) Adjustable.Container:saveAll() end)
    self:newCustomItem("updateScript",  function(s) Adjustable.Container:saveAll() GUIDropManager.createDropManager() end)
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>deleteOldProfiles</name>
			<packageName>deleteOldProfiles</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>deleteOldProfiles script</name>
				<packageName></packageName>
				<script>function deleteOldProfiles(keepdays_arg, delete_folder)
  --[[
  Deletes old profiles/maps/modules in the "current"/"map"/"moduleBackups" folders of the Mudlet home directory.
  The following files are NOT deleted:
  - Files newer than the amount of days specified as an argument to deleteOldProfiles(), or 31 days if not specified.
  - One file for every month before that. Specifically: The first available file of every month prior to this.
  Setting the second argument to true will delete maps instead of profiles. (e.g. deleteOldProfiles(10, true))
  --]]

  -- Ensure correct value is passed for second argument
  assert(type(delete_folder) == "string", "Wrong type for delete_folder; expected string, got " .. type(delete_folder))
  assert(table.contains({"profiles", "maps", "modules"}, delete_folder), "delete_folder must be profiles, maps or modules")

  local keepdays = tonumber(keepdays_arg) or 31
  local profile_table = {}
  local used_last_mod_months = {}
  local slash = (string.char(getMudletHomeDir():byte()) == "/") and "/" or "\\"
  local delnum = 0

  local to_folder = {
    profiles = "current",
    maps = "map",
  }

  local dirpath = delete_folder == "modules"
    and getMudletHomeDir()..slash..".."..slash..".."..slash.."moduleBackups"
    or getMudletHomeDir()..slash..to_folder[delete_folder]

  -- Traverse the profiles folder and create a table of files:
  for filename in lfs.dir(dirpath) do
    if filename~="." and filename~=".." then
      profile_table[#profile_table+1] = {
        name = filename,
        last_mod = lfs.attributes(dirpath..slash..filename, "modification")
      }
    end
  end

  -- Sort the table according to last modification date from old to new:
  table.sort(profile_table, function (a,b) return a.last_mod &lt; b.last_mod end)

  echo(string.format(
    "\nDeleting old %s. Files newer than %d days and one for every month before that will be kept.",
    delete_folder,
    keepdays
  ))

  for i, v in ipairs(profile_table) do
    local days = math.floor(os.difftime(os.time(), v.last_mod) / 86400)
    local last_mod_month = os.date("%Y/%m", v.last_mod)
    if days &gt; keepdays then
      -- For profiles older than X days, check if we already kept a table for this month:
      if not table.contains(used_last_mod_months, last_mod_month) then
        -- If not, do nothing and mark this month as "kept".
        used_last_mod_months[#used_last_mod_months+1] = last_mod_month
      else
        -- Otherwise remove the file:
        local success, errorstring = os.remove(dirpath..slash..v.name)
        if success then
          delnum = delnum + 1
        else
          cecho("\n&lt;red&gt;ERROR: "..errorstring)
        end
      end
    end
  end

  echo(string.format("\nDeletion complete. %d/%d files were removed successfully.", delnum, #profile_table))
end
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>generic_mapper</name>
			<packageName>generic_mapper</packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Map Script</name>
				<packageName></packageName>
				<script>-- Jor'Mox's Generic Map Script
-- the script self-updates, changing this value will bring an update to all installations
-- make sure versions.lua has the latest version in it
local version = "2.1.7"

    -- look into options for non-standard door usage for speedwalk
    -- come up with aliases to set translations and custom exits, add appropriate help info

mudlet = mudlet or {}
mudlet.mapper_script = true
map = map or {}

map.help = {[[
    &lt;cyan&gt;Generic Map Script&lt;reset&gt;

    This script allows for semi-automatic mapping using the included triggers.
    While different games can have dramatically different ways of displaying
    information, some effort has been put into giving the script a wide range of
    potential patterns to look for, so that it can work with minimal effort in
    many cases. The script locates the room name by searching up from the
    detected exits line until a prompt is found or it runs out of text to
    search, clearing saved text each time a prompt is detected or a movement
    command is sent, with the room name being set to the last line of text
    found. An accurate prompt pattern is necessary for this to work well, and
    sometimes other text can end up being shown between the prompt and the room
    name, or on the same line as the room name, which can be handled by
    providing appropriate patterns telling the script to ignore that text. Below
    is an overview of the included commands and important events that this
    script uses to work. Additional information on each command or event is
    available in individual help files.

    &lt;cyan&gt;Fundamental Commands:&lt;reset&gt;
        These are commands used to get the mapper functional on a basic level.

        &lt;link: show&gt;map show&lt;/link&gt; - Displays or hides a map window.
        &lt;link: quick start&gt;map basics&lt;/link&gt; - Shows a quick-start guide with some basic information to
            help get the script working.
        &lt;link: 1&gt;map help [command name]&lt;/link&gt; - Shows either this help file or the help file for the
            command given.
        &lt;link: find prompt&gt;find prompt&lt;/link&gt; - Instructs the script to look for a prompt that matches
            a known pattern.
        &lt;link: prompt&gt;map prompt &lt;pattern&gt;&lt;/link&gt; - Provides a specific pattern to the script that
            matches your prompt, uses &lt;urllink: https://www.lua.org/pil/20.2.html&gt;Lua string-library patterns&lt;/urllink&gt;.
        &lt;link: ignore&gt;map ignore &lt;pattern&gt;&lt;/link&gt; - Provides a specific pattern for the script to
            ignore, uses &lt;urllink: https://www.lua.org/pil/20.2.html&gt;Lua string-library patterns&lt;/urllink&gt;.
        &lt;link: movemethod&gt;map movemethod &lt;word&gt;&lt;/link&gt; - Adds a movement method for the script to
            look for when mapping.
        &lt;link: debug&gt;map debug&lt;/link&gt; - Toggles on debug mode, in which extra messages are shown with
            the intent of assisting in troubleshooting getting the script setup.
        &lt;link: me&gt;map me&lt;/link&gt; - Locates the user on the map, if possible.
        &lt;link: path&gt;map path &lt;room name&gt; [; area name]&lt;/link&gt; - Finds a walking path to the named
            room, in the named area if specified.
        &lt;link: character&gt;map character &lt;name&gt;&lt;/link&gt; - Sets a given name as the current character for
            the purposes of the script, used for different prompt patterns and
            recall locations.
        &lt;link: recall&gt;map recall&lt;/link&gt; - Sets the current room as the recall location of the
            current character
        &lt;link: config&gt;map config &lt;configuration&gt; [value]&lt;/link&gt; - Sets or toggles the given
            configuration either turning it on or off, if no value is given, or sets it to the given
            value.
        &lt;link: window&gt;map window &lt;configuration&gt; [value]&lt;/link&gt; - Sets the given configuration for the
            map window to the given value.
        &lt;link: translate&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;&lt;/link&gt;
        &lt;link: translate&gt;&lt;translated short direction&gt;&lt;/link&gt; - Sets the provided translations for the
            given english direction word.

    &lt;cyan&gt;Map Information Commands:&lt;reset&gt;
        These commands show detailed information about your current map.

        &lt;link: areas&gt;map areas&lt;/link&gt; - Shows a list of all areas, with links to show a list of
            rooms in the area.
        &lt;link: rooms&gt;map rooms &lt;area name&gt;&lt;/link&gt; - Shows a list of rooms in the named area.
        &lt;link: room_find&gt;room find|rf &lt;room name&gt;&lt;/link&gt; - Searches for a room of a given name.
        &lt;link: room_look&gt;room look|rl [roomID]&lt;/link&gt; - Displays detailed information about a room.
        &lt;link: showpath&gt;showpath &lt;roomID&gt;&lt;/link&gt; - Shows you a path from your current location to the
            roomID.
        &lt;link: showpath&gt;showpath &lt;fromID&gt; &lt;toID&gt;&lt;/link&gt; - Shows you a path from a given location to
            another location.
        &lt;link: spe_list&gt;spe list [filter]&lt;/link&gt; - Display a list of all known special exits.
        &lt;link: feature_list&gt;feature list&lt;/link&gt; - Lists all map features created via feature create and
            the associated room characters.

    &lt;cyan&gt;Map Creation Commands:&lt;reset&gt;
        These are commands used in the process of actually creating a map.

        &lt;link: start mapping&gt;start mapping [area name]&lt;/link&gt; - Starts adding content to the map, using
            either the area of the room the user is currently in or the area
            name provided.
        &lt;link: stop mapping&gt;stop mapping&lt;/link&gt; - Stops adding content to the map.
        &lt;link: area_add&gt;area add &lt;area name&gt;&lt;/link&gt; - Creates a new area.
        &lt;link: area_delete&gt;area delete &lt;area name&gt;&lt;/link&gt; - Deletes a given area and all rooms within.
        &lt;link: area_cancel&gt;cancel area deletion&lt;/link&gt; - Pauses deletion of an area.  This will NOT
            restore delete rooms.
        &lt;link: area_rename&gt;area rename &lt;new area name&gt;&lt;/link&gt; - Renames the current area you're in.
        &lt;link: set area&gt;set area &lt;area name&gt;&lt;/link&gt; - Moves the current room to the named area.
        &lt;link: mode&gt;map mode &lt;lazy, simple, normal or complex&gt;&lt;/link&gt; - Sets the mapping mode, which
            defines how new rooms are added to the map.
        &lt;link: add door&gt;add door &lt;direction&gt; [door status] [one way]&lt;/link&gt; - Creates a door in
            the given direction, with the given status(default closed), in both
            directions, unless a one-direction door is specified.
        &lt;link: add portal&gt;add portal [-f] &lt;entry command&gt;&lt;/link&gt; - Creates a portal in the current room,
            using the given command for entry.
        &lt;link: shift&gt;shift &lt;direction&gt;&lt;/link&gt; - Moves the current room on the map in the given direction.
        &lt;link: merge rooms&gt;merge rooms&lt;/link&gt; - Combines overlapping rooms that have the same name into
            a single room.
        &lt;link: clear moves&gt;clear moves&lt;/link&gt; - Clears the list of movement commands maintained by the
            script.
        &lt;link: set exit&gt;set exit &lt;direction&gt; &lt;roomID&gt;&lt;/link&gt; - Creates a one-way exit in the given
            direction to the room with the specified roomID, can also be used with portals.
        &lt;link: arealock&gt;arealock [area name]&lt;/link&gt; - Displays a list of areas you can lock/unlock.
        &lt;link: room_coords&gt;room coords|rc [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;/link&gt; - Move a room to new map coordinates.
        &lt;link: room_delete&gt;room delete|rld &lt;direction|roomID&gt;&lt;/link&gt; - Delete a room given a direction or roomID.
        &lt;link: room_weight&gt;rw [direction|roomID] &lt;weight&gt;&lt;/link&gt; - Set a room weight given a direction or roomID.
        &lt;link: room_weight_exit&gt;rwe [roomID] &lt;weight&gt; &lt;exit&gt;&lt;/link&gt; - Set the weight of a given exit in
            the current room, or optional roomID.
        &lt;link: room_link&gt;room link|rlk &lt;direction&gt; [one]&lt;/link&gt; - Create a link to a room given a direction.
            Optional 'one' to create a one-way link.
        &lt;link: room_unlink&gt;room unlink|urlk &lt;direction&gt;&lt;/link&gt; - Delete a link in the specified direction.
        &lt;link: room_door&gt;rd [roomID] &lt;direction&gt; &lt;open|closed|locked|clear&gt;&lt;/link&gt; - Create or delete a door
            from the current room, or optional location.
        &lt;link: room_character&gt;rcc &lt;character&gt; [roomID]&lt;/link&gt; - Assign a single character, letter or
            number to the current room, or optional location.
        &lt;link: exit_special&gt;exit special|spe &lt;direction|roomID&gt; &lt;command&gt;&lt;/link&gt; - Add a special exit
            to a room.
        &lt;link: spev&gt;spev &lt;fromID&gt; &lt;toID&gt; &lt;command&gt;&lt;/link&gt; - Add a special exit to two remote rooms.
        &lt;link: spe_clear&gt;exit special clear|spe clear &lt;direction|roomID&gt;&lt;/link&gt; - Delete a special exit.
        &lt;link: room_area&gt;room area [v&lt;roomID&gt;] &lt;area name&gt;&lt;/link&gt; - Moves a room to the given area.
        &lt;link: room_label&gt;room label [roomID] [fgColor] [bgColor] &lt;message&gt;&lt;/link&gt; - Adds a label to a room.
        &lt;link: area_labels&gt;area labels &lt;area name&gt;&lt;/link&gt; - Display all labels in a given area with an
            option to delete.
        &lt;link: feature_create&gt;feature create &lt;feature&gt; [char &lt;room character&gt;]&lt;/link&gt; - Create a new
            global map feature.
        &lt;link: room_feature_create&gt;room create feature|rcf [v&lt;room id&gt;] &lt;feature&gt;&lt;/link&gt; - Adds a map
            feature to the current room, or optional location.
        &lt;link: room_feature_delete&gt;room delete feature|rdf [v&lt;room id&gt;] &lt;feature&gt;&lt;/link&gt; - Removes a
            map feature from the current room or optional location.
        &lt;link: feature_delete&gt;feature delete &lt;feature&gt;&lt;/link&gt; - Deletes a global map feature and
            removes it from all rooms.

    &lt;cyan&gt;Sharing and Backup Commands:&lt;reset&gt;

        &lt;link: save&gt;map save&lt;/link&gt; - Creates a backup of the map.
        &lt;link: load&gt;map load &lt;remote address&gt;&lt;/link&gt; - Loads a map backup, or a map file from a
            remote address.
        &lt;link: export&gt;map export &lt;area name&gt;&lt;/link&gt; - Creates a file from the named area that can
            be shared.
        &lt;link: import&gt;map import &lt;area name&gt;&lt;/link&gt; - Loads an area from a file.

    &lt;cyan&gt;Mapping Events:&lt;reset&gt;
        These events are used by triggers to direct the script's behavior.

        &lt;link: onNewRoom&gt;onNewRoom&lt;/link&gt; - Signals that a room has been detected, optional exits
            argument.
        &lt;link: onMoveFail&gt;onMoveFail&lt;/link&gt; - Signals that an attempted move failed.
        &lt;link: onForcedMove&gt;onForcedMove&lt;/link&gt; - Signals that the character moved without a command
            being entered, required direction argument.
        &lt;link: onRandomMove&gt;onRandomMove&lt;/link&gt; - Signals that the character moved in an unknown
            direction without a command being entered.
        &lt;link: onVisionFail&gt;onVisionFail&lt;/link&gt; - Signals that the character moved but some or all of
            the room information was not able to be gathered.

    &lt;cyan&gt;Key Variables:&lt;reset&gt;
        These variables are used by the script to keep track of important
            information.

        &lt;yellow&gt;map.prompt.room&lt;reset&gt; - Can be set to specify the room name.
        &lt;yellow&gt;map.prompt.exits&lt;reset&gt; - Can be set to specify the room exits.
        &lt;yellow&gt;map.prompt.hash&lt;reset&gt; - Can be set to specify the room hash.
            Notice: if you set this, mapper will only find room by
            getRoomIDbyHash(hash)
        &lt;yellow&gt;map.character&lt;reset&gt; - Contains the current character name.
        &lt;yellow&gt;map.save.recall&lt;reset&gt; - Contains a table of recall roomIDs for all
            characters.
        &lt;yellow&gt;map.save.prompt_pattern&lt;reset&gt; - Contains a table of prompt patterns for all
            characters.
        &lt;yellow&gt;map.save.ignore_patterns&lt;reset&gt; - Contains a table of patterns of text the
            script ignores.
        &lt;yellow&gt;map.configs&lt;reset&gt; - Contains a number of different options that can be set
            to modify script behavior.
        &lt;yellow&gt;map.currentRoom&lt;reset&gt; - Contains the roomID of the room your character is
            in, according to the script.
        &lt;yellow&gt;map.currentName&lt;reset&gt; - Contains the name of the room your character is in,
            according to the script.
        &lt;yellow&gt;map.currentExits&lt;reset&gt; - Contains a table of the exits of the room your
            character is in, according to the script.
        &lt;yellow&gt;map.currentArea&lt;reset&gt; - Contains the areaID of the area your character is
            in, according to the script.
]]}
map.help.save = [[
    &lt;cyan&gt;Map Save&lt;reset&gt;
        syntax: &lt;yellow&gt;map save&lt;reset&gt;

        This command creates a copy of the current map and stores it in the
        profile folder as map.dat. This can be useful for creating a backup
        before adding new content, in case of problems, and as a way to share an
        entire map at once.
]]
map.help.load = [[
    &lt;cyan&gt;Map Load&lt;reset&gt;
        syntax: &lt;yellow&gt;map load &lt;optional download address&gt;&lt;reset&gt;

        This command replaces the current map with the map stored as map.dat in
        the profile folder. Alternatively, if a download address is provided, a
        map is downloaded from that location and loaded to replace the current
        map. If no filename is given with the download address, the script tries
        to download map.dat. If a filename is given it MUST end with .dat.
]]
map.help.show = [[
    &lt;cyan&gt;Map Show&lt;reset&gt;
        syntax: &lt;yellow&gt;map show&lt;reset&gt;

        This command shows a map window, as specified by the window configs set
        via the &lt;link: window&gt;map window command&lt;/link&gt;. It isn't necessary to use this method to
        show a map window to use this script, any map window will work.
]]
map.help.export = [[
    &lt;cyan&gt;Map Export&lt;reset&gt;
        syntax: &lt;yellow&gt;map export &lt;area name&gt;&lt;reset&gt;

        This command creates a file containing all the informatino about the
        named area and stores it in the profile folder, with a file name based
        on the area name. This file can then be imported, allowing for easy
        sharing of single map areas. The file name will be the name of the area
        in all lower case, with spaces replaced with underscores, and a .dat
        file extension.
]]
map.help.import = [[
    &lt;cyan&gt;Map Import&lt;reset&gt;
        syntax: &lt;yellow&gt;map import &lt;area name&gt;&lt;reset&gt;

        This command imports a file from the profile folder with a name matching
        the name of the file, and uses it to create an area on the map. The area
        name used can be capitalized or not, and may have either spaces or
        underscores between words. The actual area name is stored within the
        file, and is not set by the area name used in this command.
]]
map.help.start_mapping = [[
    &lt;cyan&gt;Start Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;start mapping [area name]&lt;reset&gt;

        This command instructs the script to add new content to the map when it
        is seen. When first used, an area name is mandatory, so that an area is
        created for new rooms to be placed in. If used with an area name while
        the map shows the character within a room on the map, that room will be
        moved to be in the named area, if it is not already in it. If used
        without an area name, the room is not moved, and mapping begins in the
        area the character is currently located in.
]]
map.help.stop_mapping = [[
    &lt;cyan&gt;Stop Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;stop mapping&lt;reset&gt;

        This command instructs the script to stop adding new content until
        mapping is resumed at a later time. The map will continue to perform
        other functions.
]]
map.help.find_prompt = [[
    &lt;cyan&gt;Find Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;find prompt&lt;reset&gt;

        This command instructs the script to begin searching newly arriving text
        for something that matches one of its known prompt patterns. If one is
        found, that pattern will be set as the current prompt pattern. This
        should typically be the first command used to set up this script with a
        new profile. If your prompt appears after using this command, but there
        is no message saying that the prompt has been found, it will be
        necessary to use the map prompt command to manually set a pattern.
]]
map.help.prompt = [[
    &lt;cyan&gt;Map Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;map prompt &lt;prompt pattern&gt;&lt;reset&gt;

        This command manually sets a prompt pattern for the script to use.
        Because of the way this script works, the prompt pattern should match
        the entire prompt, so that if the text matching the pattern were
        removed, the line with the prompt would be blank. The patterns must be
        of the type used by the Lua string library. If you are unsure about what
        pattern to use, seek assistance on the Mudlet Forums or the Mudlet
        Discord channel.
]]
map.help.debug = [[
    &lt;cyan&gt;Map Debug&lt;reset&gt;
        syntax: &lt;yellow&gt;map debug&lt;reset&gt;

        This command toggles the map script's debug mode on or off when it is
        used. Debug mode provides some extra messages to help with setting up
        the script and identifying problems to help with troubleshooting. If you
        are getting assistance with setting up this script, using debug mode may
        make the process faster and easier.
]]
map.help.ignore = [[
    &lt;cyan&gt;Map Ignore&lt;reset&gt;
        syntax: &lt;yellow&gt;map ignore &lt;ignore pattern&gt;&lt;reset&gt;

        This command adds the given pattern to a list the script maintains to
        help it locate the room name. Any text that might appear after a command
        is sent to move and before the room name appears, or after the prompt
        and before the room name if several movement commands are sent at once,
        should have an ignore pattern added for it.

        If the given pattern is already in the list of ignore patterns, that
        pattern will be removed from the list.

        Example: &lt;yellow&gt;map ignore ^You are hungry%.$&lt;reset&gt; - match exactly one line
                 &lt;yellow&gt;map ignore ^The clock strikes %d+%.$&lt;reset&gt; - match a number
                 &lt;yellow&gt;map ignore ^You walk %a+%.$&lt;reset&gt; - match a word, e.g. east
]]
map.help.movemethod = [[
    &lt;cyan&gt;Move Method&lt;reset&gt;
        syntax: &lt;yellow&gt;map movemethod &lt;movement word&gt;&lt;reset&gt;

        This command will add a movement method for the script to look for
        when moving between rooms. If your game has methods such as "walk north",
        "swim south" or similar, add "walk" or "swim" as necessary. For single
        room movement only.

        If the given method is already in the list of movement methods, that
        method will be removed from the list.
]]
map.help.areas = [[
    &lt;cyan&gt;Map Areas&lt;reset&gt;
        syntax: &lt;yellow&gt;map areas&lt;reset&gt;

        This command displays a linked list of all areas in the map. When
        clicked, the rooms in the selected area will be displayed, as if the
        'map rooms' command had been used with that area as an argument.
]]
map.help.rooms = [[
    &lt;cyan&gt;Map Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;map rooms &lt;area name&gt;&lt;reset&gt;

        This command shows a list of all rooms in the area, with the roomID and
        the room name, as well as a count of how many rooms are in the area
        total. Note that the area name argument is not case sensitive.
]]
map.help.set_area = [[
    &lt;cyan&gt;Set Area&lt;reset&gt;
        syntax: &lt;yellow&gt;set area &lt;area name&gt;&lt;reset&gt;

        This command move the current room into the named area, creating the
        area if needed.
]]
map.help.mode = [[
    &lt;cyan&gt;Map Mode&lt;reset&gt;
        syntax: &lt;yellow&gt;map mode &lt;lazy, simple, normal, or complex&gt;&lt;reset&gt;

        This command changes the current mapping mode, which determines what
        happens when new rooms are added to the map.

        In lazy mode, connecting exits aren't checked and a room is only added if
        there isn't an adjacent room with the same name.

        In simple mode, if an adjacent room has an exit stub pointing toward the
        newly created room, and the new room has an exit in that direction,
        those stubs are connected in both directions.

        In normal mode (default), the newly created room is connected to the room you left
        from, so long as it has an exit leading in that direction.

        In complex mode, none of the exits of the newly connected room are
        connected automatically when it is created.
]]
map.help.add_door = [[
    &lt;cyan&gt;Add Door&lt;reset&gt;
        syntax: &lt;yellow&gt;add door &lt;direction&gt; [none|open|closed|locked] [yes|no]&lt;reset&gt;

        This command places a door on the exit in the given direction, or
        removes it if "none" is given as the second argument. The door status is
        set as given by the second argument, default "closed". The third
        argument determines if the door is a one-way door, default "no".
]]
map.help.add_portal = [[
    &lt;cyan&gt;Add Portal&lt;reset&gt;
        syntax: &lt;yellow&gt;add portal [-f] &lt;entry command&gt;&lt;reset&gt;

        This command creates a special exit in the current room that is entered
        by using the given entry command. The given entry command is then sent,
        moving to the destination room. If the destination room matches an
        existing room, the special exit will link to that room, and if not a new
        room will be created. If the optional "-f" argument is given, a new room
        will be created for the destination regardless of if an existing room
        matches the room seen when arriving at the destination.
]]
map.help.shift = [[
    &lt;cyan&gt;Shift&lt;reset&gt;
        syntax: &lt;yellow&gt;shift &lt;direction&gt;&lt;reset&gt;

        This command moves the current room one step in the direction given, on
        the map.
]]
map.help.merge_rooms = [[
    &lt;cyan&gt;Merge Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;merge rooms&lt;reset&gt;

        This command combines all rooms that share the same coordinates and the
        same room name into a single room, with all of the exits preserved and
        combined.
]]
map.help.clear_moves = [[
    &lt;cyan&gt;Clear Moves&lt;reset&gt;
        syntax: &lt;yellow&gt;clear moves&lt;reset&gt;

        This command clears the script's queue of movement commands, and is
        intended to be used after you attempt to move while mapping but the
        movement is prevented in some way that is not caught and handled by a
        trigger that raises the onMoveFail event.
]]
map.help.set_exit = [[
    &lt;cyan&gt;Set Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;set exit &lt;direction&gt; &lt;destination roomID&gt;&lt;reset&gt;

        This command sets the exit in the current room in the given direction to
        connect to the target room, as specified by the roomID. This is a
        one-way connection.
]]
map.help.onnewroom = [[
    &lt;cyan&gt;onNewRoom Event&lt;reset&gt;

        This event is raised to inform the script that a room has been detected.
        When raised, a string containing the exits from the detected room should
        be passed as a second argument to the raiseEvent function, unless those
        exits have previously been stored in map.prompt.exits.
]]
map.help.onmovefail = [[
    &lt;cyan&gt;onMoveFail Event&lt;reset&gt;

        This event is raised to inform the script that a move was attempted but
        the character was unable to move in the given direction, causing that
        movement command to be removed from the script's movement queue.
]]
map.help.onforcedmove = [[
    &lt;cyan&gt;onForcedMove Event&lt;reset&gt;

        This event is raised to inform the script that the character moved in a
        specified direction without a command being entered. When raised, a
        string containing the movement direction must be passed as a second
        argument to the raiseEvent function.

        The most common reason for this event to be raised is when a character
        is following someone else.
]]
map.help.onrandommove = [[
    &lt;cyan&gt;onRandomMove Event&lt;reset&gt;

        This event is raised to inform the script that the character has moved
        in an unknown direction. The script will compare the next room seen with
        rooms that are adjacent to the current room to try to determine the best
        match for where the character has gone.

        In some situations, multiple options are equally viable, so mistakes may
        result. The script will automatically keep verifying positioning with
        each step, and automatically correct the shown location on the map when
        possible.
]]
map.help.onvisionfail = [[
    &lt;cyan&gt;onVisionFail Event&lt;reset&gt;

        This event is raised to inform the script that some or all of the room
        information was not able to be gathered, but the character still
        successfully moved between rooms in the intended direction.
]]
map.help.onprompt = [[
    &lt;cyan&gt;onPrompt Event&lt;reset&gt;

        This event can be raised when using a non-conventional setup to trigger
        waiting messages from the script to be displayed. Additionally, if
        map.prompt.exits exists and isn't simply an empty string, raising this
        event will cause the onNewRoom event to be raised as well. This
        functionality is intended to allow people who have used the older
        version of this script to use this script instead, without having to
        modify the triggers they created for it.
]]
map.help.me = [[
    &lt;cyan&gt;Map Me&lt;reset&gt;
        syntax: &lt;yellow&gt;map me&lt;reset&gt;

        This command forces the script to look at the currently captured room
        name and exits, and search for a potentially matching room, moving the
        map if applicable. Note that this command is generally never needed, as
        the script performs a similar search any time the room name and exits
        don't match expectations.
]]
map.help.path = [[
    &lt;cyan&gt;Map Path&lt;reset&gt;
        syntax: &lt;yellow&gt;map path &lt;room name&gt; [; area name]&lt;reset&gt;

        This command tries to find a walking path from the current room to the
        named room. If an area name is given, only rooms within that area that
        is given are checked. Neither the room name nor the area name are case
        sensitive, but otherwise an exact match is required. Note that a
        semicolon is required between the room name and area name, if an area
        name is given, but spaces before or after the semicolon are optional.

        Example: &lt;yellow&gt;map path main street ; newbie town&lt;reset&gt;
]]
map.help.character = [[
    &lt;cyan&gt;Map Character&lt;reset&gt;
        syntax: &lt;yellow&gt;map character &lt;name&gt;&lt;reset&gt;

        This command tells the script what character is currently being used.
        Setting a character is optional, but recall locations and prompt
        patterns are stored by character name, so using this command allows for
        easy switching between different setups. The name given is stored in
        map.character. The name is a case sensitive exact match. The value of
        map.character is not saved between sessions, so this must be set again
        if needed each time the profile is opened.
]]
map.help.recall = [[
    &lt;cyan&gt;Map Recall&lt;reset&gt;
        syntax: &lt;yellow&gt;map recall&lt;reset&gt;

        This command tells the script that the current room is the recall point
        for the current character, as stored in map.character. This information
        is stored in map.save.recall[map.character], and is remembered between
        sessions.
]]
map.help.config = [[
    &lt;cyan&gt;Map Config&lt;reset&gt;
        syntax: &lt;yellow&gt;map config &lt;setting&gt; &lt;optional value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below.
        If no value is given, and the setting is either 'on' or 'off', then the
        value is switched. When naming a setting, spaces can be used in place of
        underscores. Details of what options are available and what each one
        does are provided.

        &lt;yellow&gt;speedwalk_delay&lt;reset&gt; - When using the speedwalk function of the script,
            this is the amount of time the script waits after either sending
            a command or, if speedwalk_wait is set, after arriving in a new
            room, before the next command is sent. This may be any number 0
            or higher.

        &lt;yellow&gt;speedwalk_wait&lt;reset&gt; - When using the speedwalk function of the script,
            this indicates if the script waits for your character to move
            into a new room before sending the next command. This may be true
            or false.

        &lt;yellow&gt;speedwalk_random&lt;reset&gt; - When using the speedwalk function of the script
            with a speedwalk_delay value, introduces a randomness to the wait
            time by adding some amount up to the speedwalk_delay value. This
            may be true or false.

        &lt;yellow&gt;stretch_map&lt;reset&gt; - When adding a new room that would overlap an existing
            room, if this is set the map will stretch out to prevent the
            overlap, with all rooms further in the direction moved getting
            pushed one further in that direction. This may be true or false.

        &lt;yellow&gt;max_search_distance&lt;reset&gt; - When mapping, this is the maximum number of
            rooms that the script will search in the movement direction for a
            matching room before deciding to create a new room. This may be
            false, or any positive whole number. This can also be set to 0,
            which is the same as setting it to false.

        &lt;yellow&gt;search_on_look&lt;reset&gt; - When this is set, using the "look" command causes
            the map to verify your position using the room name and exits
            seen following using the command. This may be true or false.

        &lt;yellow&gt;clear_lines_on_send&lt;reset&gt; - When this is set, any time a command is sent,
            any lines stored from the game used to search for the room name
            are cleared. This may be true or false.

        &lt;yellow&gt;mode&lt;reset&gt; - This is the default mapping mode on startup, and defines how
            new rooms are added to the map. May be "lazy", "simple",
            "normal" or "complex".

        &lt;yellow&gt;download_path&lt;reset&gt; - This is the path that updates are downloaded from.
            This may be any web address where the versions.lua and
            generic_mapper.xml files can be downloaded from.

        &lt;yellow&gt;prompt_test_patterns&lt;reset&gt; - This is a table of default patterns checked
            when using the "find prompt" command. The patterns in this table
            should start with a '^', and be written to be used with the Lua
            string library. Most importantly, '%' is used as the escape
            character instead of '\' as in trigger regex patterns.

        &lt;yellow&gt;custom_exits&lt;reset&gt; - This is a table of custom exit directions and their
            relevant extra pieces of info. Each entry should have the short
            direction as the keyword for a table containing first the long
            direction, then the long direction of the reverse of this
            direction, and then the x, y, and z change in map position
            corresponding to the movement. As an example: us = {'upsouth',
            'downnorth', 0, -1, 1}

        &lt;yellow&gt;custom_name_search&lt;reset&gt; - When this is set, instead of running the default
            function name_search, a user-defined function called
            'mudlet.custom_name_search' is used instead. This may be true or false.

        &lt;yellow&gt;use_translation&lt;reset&gt; - When this is set, the lang_dirs table is used to
            translate movement and status commands in some other language
            into the English used by the script. This may be true or false.

        &lt;yellow&gt;debug&lt;reset&gt; - When this is set, the script will start in debug mode. This
            may be true or false.
]]
map.help.window = [[
    &lt;yellow&gt;Map Window&lt;reset&gt;
        syntax: &lt;yellow&gt;map window &lt;setting&gt; &lt;value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below,
        which determine the appearance and positioning of the map window when
        the 'map show' command is used. Details of what options are available
        and what each one does are provided.

        &lt;yellow&gt;x&lt;reset&gt; - This is the x position of the map window, and should be a
            positive number of pixels or a percentage of the screen width.

        &lt;yellow&gt;y&lt;reset&gt; - This is the y position of the map window, and should be a
            positive number of pixels or a percentage of the screen height.

        &lt;yellow&gt;w&lt;reset&gt; - This is the width of the map window, and should be a positive
            number of pixels or a percentage of the screen width.

        &lt;yellow&gt;h&lt;reset&gt; - This is the height of the map window, and should be a positive
            number of pixels or a percentage of the screen height.

        &lt;yellow&gt;origin&lt;reset&gt; - This is the corner from which the window position is
            measured, and may be 'topright', 'topleft', 'bottomright', or
            'bottomleft'.

        &lt;yellow&gt;shown&lt;reset&gt; - This determines if the map window is shown immediately upon
            connecting to the game. This may be true or false. If you intend
            to have some other script control the map window, this should be
            set to false.
]]
map.help.translate = [[
    &lt;yellow&gt;Map Translate&lt;reset&gt;
        syntax: &lt;yellow&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;
            &lt;translated short direction&gt;&lt;reset&gt;

        This command sets direction translations for the script to use, either
        for commands entered to move around, or listed exits the game shows when
        you enter a room. Available directions: north, south, east, west,
        northwest, northeast, southwest, southeast, up, down, in, and out.
        Also you can customize special commands sent to mud like 'look'.
]]
map.help.quick_start = [[
    &lt;link: quick_start&gt;map basics&lt;/link&gt; (quick start guide)
    ----------------------------------------

    Mudlet Mapper works in tandem with a script, and this generic mapper script needs
    to know 2 things to work:
      - &lt;dim_grey&gt;room name&lt;reset&gt; $ROOM_NAME_STATUS ($ROOM_NAME)
      - &lt;dim_grey&gt;exits&lt;reset&gt;     $ROOM_EXITS_STATUS ($ROOM_EXITS)

    1. &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt;
       If both room name and exits are good, you can start mapping! Give it the
       area name you're currently in, usually optional but required for the first one.
    2. &lt;link: find prompt&gt;find prompt&lt;/link&gt;
       Room name or exits aren't recognised? Try this command then. It will make
       the script start looking for a prompt using several standard prompt
       patterns. If a prompt is found, you will be notified, if not, you will
       need to set a prompt pattern yourself using &lt;link: prompt&gt;map prompt&lt;/link&gt;.
       Reach out to the &lt;urllink: https://discord.gg/kuYvMQ9&gt;Mudlet community&lt;/urllink&gt; for help, we'd be happy to help
       you figure it out!
    3. &lt;link: debug&gt;map debug&lt;/link&gt;
       This toggles debug mode. When on, messages will be displayed showing what
       information is captured and a few additional error messages that can help
       with getting the script fully compatible with your game.
    4. &lt;link: 1&gt;map help&lt;/link&gt;
       This will bring up a more detailed help file, starting with the available
       help topics.
]]
map.help.room_find = [[
    &lt;cyan&gt;Room Find&lt;reset&gt;
        syntax: &lt;yellow&gt;room find &lt;room name&gt;&lt;reset&gt;
                &lt;yellow&gt;rf &lt;room name&gt;&lt;reset&gt;

        This command will search all rooms and return a list of matches.
]]
map.help.room_look = [[
    &lt;cyan&gt;Room Look&lt;reset&gt;
        syntax: &lt;yellow&gt;room look [roomID]&lt;reset&gt;
                &lt;yellow&gt;rl [roomID]&lt;reset&gt;

        This command will display detailed information about the current room.
        Optionally a roomID can be provided.
]]
map.help.showpath = [[
    &lt;cyan&gt;Showpath&lt;reset&gt;
        syntax: &lt;yellow&gt;showpath &lt;roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;showpath &lt;fromID&gt; &lt;toID&gt;&lt;reset&gt;

        This command displays a path from your current room to the roomID specified.
        If two roomID's are specifed it will display a path from a remote room to another room.
]]
map.help.spe_list = [[
    &lt;cyan&gt;Special Exits List&lt;reset&gt;
        syntax: &lt;yellow&gt;spe list [filter]&lt;reset&gt;

        This command displays a list of all known special exits.  You can alternatively provide an
        optional filter to return a list containing those words.

        Example: &lt;yellow&gt;spe list worm warp&lt;reset&gt;
]]
map.help.feature_list = [[
    &lt;cyan&gt;Feature List&lt;reset&gt;
        syntax: &lt;yellow&gt;feature list&lt;reset&gt;

        This command displays a list of all map features created via feature create and the associated room characters.
]]
map.help.area_add = [[
    &lt;cyan&gt;Area Add&lt;reset&gt;
        syntax: &lt;yellow&gt;area add &lt;area name&gt;&lt;reset&gt;

        This command will create a new area and automatically give it an ID.

        Example: &lt;yellow&gt;area add My City&lt;reset&gt; - create a new area called My City
]]
map.help.area_delete = [[
    &lt;cyan&gt;Area Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;area delete &lt;area name&gt;&lt;reset&gt;

        This command will delete the given area. If the area is really big
        (thousands of rooms), deleting it at once would take a really long
        while and freeze your Mudlet while doing so. To combat the unpleasant
        experience, the script breaks up area deletion into batches of rooms
        (100 by default). While this still heavily impacts Mudlets performance,
        it allows you to see a progress meter of how far it has gotten and gives
        you an ability to pause it at any time by doing 'cancel area deletion'.

        Example: &lt;yellow&gt;area delete My City&lt;reset&gt; - delete an area called My City
]]
map.help.area_cancel = [[
    &lt;cyan&gt;Cancel Area Deletion&lt;reset&gt;
        syntax: &lt;yellow&gt;cancel area deletion&lt;reset&gt;

        This comand will stop an area deletion that has started. This will NOT
        restore deleted rooms - it merely pauses the process, so you can resume
        it with 'area delete' later on. You can type this in while Mudlet is
        deleting an area - it'll take a short while for letters to show up, but
        they will eventually.
]]
map.help.area_rename = [[
    &lt;cyan&gt;Area Rename&lt;reset&gt;
        syntax: &lt;yellow&gt;area rename &lt;name&gt;&lt;reset&gt;

        This command will rename the current area you're in to the new name.

        Example: &lt;yellow&gt;area rename My City&lt;reset&gt; - call the area you're in My City from now on

]]
map.help.arealock = [[
    &lt;cyan&gt;Arealock&lt;reset&gt;
        syntax: &lt;yellow&gt;arealock [filter]&lt;reset&gt;

        This command displays a list of areas you can lock/unlock, you can also
        give it an area name to filter by. If an area is locked the mapper will
        not attempt to speedwalk or go through any of the rooms in the area.

        Example: &lt;yellow&gt;arealock City&lt;reset&gt;
]]
map.help.room_coords = [[
    &lt;cyan&gt;Room Coordinates&lt;reset&gt;
        syntax: &lt;yellow&gt;room coords [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;reset&gt;
                &lt;yellow&gt;rc [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;reset&gt;

        This command will move a room to the new map coordinates. x,y and z will
        specify the new location of the room. The room ID is optional, it'll move
        the current room if you don't provide one.

        Example: &lt;yellow&gt;rc nw&lt;reset&gt; - move the room to be nw of the current location
                 &lt;yellow&gt;rc v34 w&lt;reset&gt; - move the room ID 34 west, note the letter 'v' in the command
                 &lt;yellow&gt;rc 1 -5 10&lt;reset&gt; - move the current room to those exact coordinates
                 &lt;yellow&gt;rc v12 8 3 -8&lt;reset&gt; - move the room #12 to 8x, 3y and -8z
                 &lt;yellow&gt;rc 14x 5y&lt;reset&gt; - move the current room to be at 14x and 5y, but the
                    same z-level you're on. You can include all three of x, y, z coordinates
                    or only one as you wish
]]
map.help.room_delete = [[
    &lt;cyan&gt;Room Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;room delete &lt;direction|roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;rld &lt;direction|roomID&gt;&lt;reset&gt;

        This command will delete a room given a relative direction or roomID.

        Example: &lt;yellow&gt;rld&lt;reset&gt; - current room, will delete the room you're currently in
                 &lt;yellow&gt;rld n&lt;reset&gt; - relative direction, will delete the room that's north of you
                 &lt;yellow&gt;rld 513&lt;reset&gt; - using roomID, will delete the room with ID 513
]]
map.help.room_weight = [[
    &lt;cyan&gt;Room Weight&lt;reset&gt;
        syntax: &lt;yellow&gt;room weight [direction|roomID] &lt;weight&gt;&lt;reset&gt;
                &lt;yellow&gt;rw [direction|roomID] &lt;weight&gt;&lt;reset&gt;

        This command updates the weight of a room, making it more or less
        desirable to travel through.  Direction or roomID is optional and
        defaults to the current room.

        Example: &lt;yellow&gt;rw 10&lt;reset&gt; - will set the room weight of the room you're standing in to 10
                 &lt;yellow&gt;rw n 4&lt;reset&gt; - relative direction, will set the room weight of the room that's
                    to the north of you to four
                 &lt;yellow&gt;rw 2343 2&lt;reset&gt; - using roomID, will set the room weight of room 2343 to 2
]]
map.help.room_weight_exit = [[
    &lt;cyan&gt;Room Weight Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;rwe [roomID] &lt;weight&gt; &lt;exit&gt;&lt;reset&gt;

        This command updates the weight of a room exit, where weight is a
        positive number (default for exits is 0). Setting a higher weight will
        make the exit be less likely to be used. The exit can be a cardinal
        direction of either n,e,s,w,ne,se,sw,ne,up,down,in,out or the exact
        special exit text (including the script: part). This alias sets a weight
        one way only, so if you want to set it both ways, use it on the opposite
        side as well. Use 'rl' to check exit weights.

        Example: &lt;yellow&gt;rwe 1 n&lt;reset&gt; -  will set the weight of the exit north to 1
                 &lt;yellow&gt;rwe 2434 0 e&lt;reset&gt; - will reset the exit weight of an east exit that
                    leads out from the 2434 room
]]
map.help.room_link = [[
    &lt;cyan&gt;Room Link&lt;reset&gt;
        syntax: &lt;yellow&gt;room link [roomID] &lt;direction&gt; [one]&lt;reset&gt;
                &lt;yellow&gt;rlk [roomID] &lt;direction&gt; [one]&lt;reset&gt;

        This command will link a room given a direction and optional roomID.
        You can also add 'one' at the end of the command to make it be a one-way
        link.

        Example: &lt;yellow&gt;rlk n&lt;reset&gt; - relative direction, will link if exists
                    a room to the north of this one to your current location
                 &lt;yellow&gt;rlk 351 n&lt;reset&gt; - exact roomID and direction, will
                    link the current room to room #351 via a north exit
                 &lt;yellow&gt;rlk n one&lt;reset&gt; - will make an exit north one-way
]]
map.help.room_unlink = [[
    &lt;cyan&gt;Room Unlink&lt;reset&gt;
        syntax: &lt;yellow&gt;room unlink &lt;direction&gt;&lt;reset&gt;
                &lt;yellow&gt;urlk &lt;direction&gt;&lt;reset&gt;

                Unlink a room given a direction.  This function will unlink
                exits both ways, or one way if there is no incoming exit.

        Example: &lt;yellow&gt;urlk nw&lt;reset&gt; - relative direction, will unlink to the
                    northwest, and from the northwest room to the southeast
]]
map.help.room_door = [[
    &lt;cyan&gt;Room Door&lt;reset&gt;
        syntax: &lt;yellow&gt;rd [roomID] &lt;direction&gt; &lt;open|closed|locked|clear&gt;&lt;reset&gt;

                Will create a door from the current room to a direction
                specified.  Door status can be open or o, closed or c, locked or
                l, clear or gone. To delete a room, use clear or gone. Setting
                doors is one-way - to set two-way doors, use the alias from the
                opposite direction.


        Example: &lt;yellow&gt;rd n&lt;reset&gt; - add a one-way door north from the current room
                 &lt;yellow&gt;rd 23 w closed&lt;reset&gt; - add a closed door leading west in room 23
                 &lt;yellow&gt;rd n clear&lt;reset&gt; - remove the door to the north from the current
                    room on this side only
]]
map.help.room_character = [[
    &lt;cyan&gt;Room Character&lt;reset&gt;
        syntax: &lt;yellow&gt;rcc &lt;character|clear&gt; [roomID]&lt;reset&gt;

        This command will assign a single character, letter or number to the
        current room, or an optional given room.  Using clear will remove any
        characters.

        Example: &lt;yellow&gt;rcc $&lt;reset&gt; - put the dollar sign in the current room 
                    (e.g. to indicate a shop or bank)
                 &lt;yellow&gt;rcc C 234&lt;reset&gt; - put the letter C onto room 234
                 &lt;yellow&gt;rcc clear&lt;reset&gt; - remove any letter from the current
                 room
]]
map.help.exit_special = [[
    &lt;cyan&gt;Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;exit special &lt;direction|roomID&gt; &lt;command&gt;&lt;reset&gt;
                &lt;yellow&gt;spe &lt;direction|roomID&gt; &lt;command&gt;&lt;reset&gt;

        This command will link two rooms via custom or special exit/script.

        Example: &lt;yellow&gt;spe n push rock&lt;reset&gt; - relative direction, will go to
                    the room that's north of you by doing 'push rock'
                 &lt;yellow&gt;spe 125 pull lever&lt;reset&gt; - will go to room 125 from the
                    current one by pulling a lever

        You can also specify a script to do code for you, by starting the exit
        command with script.

        Example: &lt;yellow&gt;spe 125 script: sendAll("pull lever", "enter gate")&lt;reset&gt;


]]
map.help.spev = [[
    &lt;cyan&gt;Remote Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;spev &lt;fromID&gt; &lt;toID&gt; &lt;command&gt;&lt;reset&gt;

        This command will add a special exit between two remote rooms.

        Example: &lt;yellow&gt;spe 125 560 push rock&lt;reset&gt; - will link room 125 to room 560 with
                    the command 'push rock'
]]
map.help.spe_clear = [[
    &lt;cyan&gt;Clear Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;exit special clear &lt;direction|roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;spe clear &lt;direction|roomID&gt;&lt;reset&gt;

        This command will clear all special exits from the current, relative or
        given roomID.

        Example: &lt;yellow&gt;spe clear&lt;reset&gt; - delete all special exits in the room you're currently in
                 &lt;yellow&gt;spe clear n&lt;reset&gt; - delete all special exits in the room that's north of you
                 &lt;yellow&gt;spe clear 513&lt;reset&gt; - delete all special exits in room #513
]]
map.help.room_area = [[
    &lt;cyan&gt;Room Area&lt;reset&gt;
        syntax: &lt;yellow&gt;room area [v&lt;roomID&gt;] &lt;area name|areaID&gt;&lt;reset&gt;

        This command moves the current room to another area or a given optional
        room.

        Example: &lt;yellow&gt;room area My New Area&lt;reset&gt; - move the room you're in to 'My New Area'.
                 &lt;yellow&gt;room area v123 My New Area&lt;reset&gt; - move room 123 to My New Area
                 &lt;yellow&gt;room area 44&lt;reset&gt; - move the current room to the area ID 44
]]
map.help.room_label = [[
    &lt;cyan&gt;Room Label&lt;reset&gt;
        syntax: &lt;yellow&gt;room label [roomID] [fgColor] [bgColor] &lt;message&gt;&lt;reset&gt;

        This command adds a label to the current or specified room.  Foreground
        and background color are optional.

        Example: &lt;yellow&gt;room label My Label&lt;reset&gt; - adds a 'My Label' label to the current room
                 &lt;yellow&gt;room label 342 My Label&lt;reset&gt; - adds a label to room #342
                 &lt;yellow&gt;room label green My Label&lt;reset&gt; - adds a green label with a transparent
                    background to the current room
                 &lt;yellow&gt;room label green black My Label&lt;reset&gt; - adds a label with a green
                    foreground and black background to the current room
                 &lt;yellow&gt;room label 34 green black My Label&lt;reset&gt; - adds a label with a green
                    foreground and black background to room #34
]]
map.help.area_labels = [[
    &lt;cyan&gt;Area Labels&lt;reset&gt;
        syntax: &lt;yellow&gt;area labels &lt;area name&gt;&lt;reset&gt;

        This command displays all labels in a given area, with a link to delete.

        Example: &lt;yellow&gt;area label My Area&lt;reset&gt;
]]
map.help.feature_create = [[
    &lt;cyan&gt;Feature Create&lt;reset&gt;
        syntax: &lt;yellow&gt;feature create &lt;feature&gt; [char &lt;room character&gt;]&lt;reset&gt;

        This command will create a new map feature for use on rooms. You can
        also optionally add a character mark to the feature, which will be set
        when a map feature is added to a room. Note: Map feature names are not
        allowed to contain numbers.

        Example: &lt;yellow&gt;feature create A Nexus Point char N&lt;reset&gt; - creates a new feature
                    'A Nexus Point' with an assigned room character 'N'
]]
map.help.room_feature_create = [[
    &lt;cyan&gt;Room Create Feature&lt;reset&gt;
        syntax: &lt;yellow&gt;room create feature [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;
                &lt;yellow&gt;rcf [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;

        This command will add a created map feature to the room. If the map
        feature is associated with a character mark, it will be set on the room
        and existing marks get overwritten. The room number to add the feature
        to can be given with the optional argument (note: there is no space
        between the v and the ID).

        Example: &lt;yellow&gt;rcf A Nexus Point&lt;reset&gt; - add the feature 'A Nexus Point' to
                    the current room
                 &lt;yellow&gt;rcf v123 A Nexus Point&lt;reset&gt; - add the feature 'A Nexus Point'
                    to room #123
]]
map.help.room_feature_delete = [[
    &lt;cyan&gt;Room Delete Feature&lt;reset&gt;
        syntax: &lt;yellow&gt;room delete feature [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;
                &lt;yellow&gt;rdf [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;

        This command removes a map feature from the room. If the map feature is
        associated with a character mark and its set on the room, a random
        character mark from the other map features on the room is chosen to
        replace it. The room number to delete the feature from can be given with
        the optional argument (note: there is no space between the v and the
        ID).

        Example: &lt;yellow&gt;rdf v123 A Nexus Point&lt;reset&gt; - removes the feature 'A Nexus Point'
                    from the room #123
]]
map.help.feature_delete = [[
    &lt;cyan&gt;Feature Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;feature delete &lt;feature&gt;&lt;reset&gt;

        This command deletes a global map feature and removes it from all rooms.

        Example: &lt;yellow&gt;feature delete A Nexus Point&lt;reset&gt; - removes the global feature
                    'A Nexus Point' and removes it from all rooms
]]



map.character = map.character or ""
map.prompt = map.prompt or {}
map.save = map.save or {}
map.save.recall = map.save.recall or {}
map.save.prompt_pattern = map.save.prompt_pattern or {}
map.save.ignore_patterns = map.save.ignore_patterns or {}
map.save.move_methods = map.save.move_methods or {}
map.silentUpdate = map.silentUpdate or true

local oldstring = string
local string = utf8
string.format = oldstring.format
string.trim = oldstring.trim
string.starts = oldstring.starts
string.split = oldstring.split
string.ends = oldstring.ends


local profilePath = getMudletHomeDir()
profilePath = profilePath:gsub("\\","/")

map.defaults = {
    mode = "normal", -- can be lazy, simple, normal, or complex
    stretch_map = true,
    search_on_look = true,
    speedwalk_delay = 1,
    speedwalk_wait = true,
    speedwalk_random = true,
    max_search_distance = 1,
    clear_lines_on_send = true,
    map_window = {
        x = 0,
        y = 0,
        w = "30%",
        h = "40%",
        origin = "topright",
        shown = false,
    },
    prompt_test_patterns = {"^%[?%a*%]?&lt;.*&gt;", "^%[.*%]%s*&gt;", "^%w*[%.?!:]*&gt;", "^%[.*%]", "^[Hh][Pp]:.*&gt;"},
    custom_exits = {},  -- format: short_exit = {long_exit, reverse_exit, x_dif, y_dif, z_dif}
                        -- ex: { us = {"upsouth", "downnorth", 0, -1, 1}, dn = {"downnorth", "upsouth", 0, 1, -1} }
    custom_name_search = false,
    use_translation = true,
    lang_dirs = {n = 'n', ne = 'ne', nw = 'nw', e = 'e', w = 'w', s = 's', se = 'se', sw = 'sw',
        u = 'u', d = 'd', ["in"] = 'in', out = 'out', north = 'north', northeast = 'northeast',
        east = 'east', west = 'west', south = 'south', southeast = 'southeast', southwest = 'southwest',
        northwest = 'northwest', up = 'up', down = 'down', l = 'l', look = 'look',
        ed = 'ed', eu = 'eu', eastdown = 'eastdown', eastup = 'eastup',
        nd = 'nd', nu = 'nu', northdown = 'northdown', northup = 'northup',
        sd = 'sd', su = 'su', southdown = 'southdown', southup = 'southup',
        wd = 'wd', wu = 'wu', westdown = 'westdown', westup = 'westup',
    },
    debug = false,
    download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper",
}

local move_queue, lines = {}, {}
local find_portal, vision_fail, room_detected, random_move, force_portal, find_prompt, downloading, walking, help_shown
local mt = getmetatable(map) or {}

local exitmap = {
    n = 'north',    ne = 'northeast',   nw = 'northwest',   e = 'east',
    w = 'west',     s = 'south',        se = 'southeast',   sw = 'southwest',
    u = 'up',       d = 'down',         ["in"] = 'in',      out = 'out',
    l = 'look',
    ed = 'eastdown',    eu = 'eastup',  nd = 'northdown',   nu = 'northup',
    sd = 'southdown',   su = 'southup', wd = 'westdown',    wu = 'westup',
}

local short = {}
for k,v in pairs(exitmap) do
    short[v] = k
end

local stubmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    northup = 13,   southdown = 14,     southup = 15,       northdown = 16,
    eastup = 17,    westdown = 18,      westup = 19,        eastdown = 20,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
    [13] = "northup", [14] = "southdown", [15] = "southup", [16] = "northdown",
    [17] = "eastup", [18] = "westdown", [19] = "westup",    [20] = "eastdown",
}

local coordmap = {
    [1] = {0,1,0},      [2] = {1,1,0},      [3] = {-1,1,0},     [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},     [7] = {1,-1,0},     [8] = {-1,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},    [11] = {0,0,0},     [12] = {0,0,0},
    [13] = {0,1,1},     [14] = {0,-1,-1},   [15] = {0,-1,1},    [16] = {0,1,-1},
    [17] = {1,0,1},     [18] = {-1,0,-1},   [19] = {-1,0,1},    [20] = {1,0,-1},
}

local reverse_dirs = {
    north = "south", south = "north", west = "east", east = "west", up = "down",
    down = "up", northwest = "southeast", northeast = "southwest", southwest = "northeast",
    southeast = "northwest", ["in"] = "out", out = "in",
    northup = "southdown", southdown = "northup", southup = "northdown", northdown = "southup",
    eastup = "westdown", westdown = "eastup", westup = "eastdown", eastdown = "westup",
}

local wait_echo = {}
local mapper_tag = "&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;"
local debug_tag = "&lt;255,165,0&gt;(&lt;200,120,0&gt;debug&lt;255,165,0&gt;): &lt;255,255,255&gt;"
local err_tag = "&lt;255,0,0&gt;(&lt;178,34,34&gt;error&lt;255,0,0&gt;): &lt;255,255,255&gt;"

local function config()
    local defaults = map.defaults
    local configs = map.configs or {}
    local path = profilePath.."/map downloads"
    if not io.exists(path) then lfs.mkdir(path) end
    -- load stored configs from file if it exists
    if io.exists(path.."/configs.lua") then
        table.load(path.."/configs.lua",configs)
    end
    -- overwrite default values with stored config values
    configs = table.update(defaults, configs)
    map.configs = configs
    map.configs.translate = {}
    for k, v in pairs(map.configs.lang_dirs) do
        map.configs.translate[v] = k
    end
    -- incorporate custom exits
    for k,v in pairs(map.configs.custom_exits) do
        exitmap[k] = v[1]
        reverse_dirs[v[1]] = v[2]
        short[v[1]] = k
        local count = #coordmap + 1
        coordmap[count] = {v[3],v[4],v[5]}
        stubmap[count] = v[1]
        stubmap[v[1]] = count
    end
    -- update to the current download path
    if map.configs.download_path == "https://raw.githubusercontent.com/JorMox/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
        map.configs.download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper"
    end

    -- setup metatable to store sensitive values
    local protected = {"mapping", "currentRoom", "currentName", "currentExits", "currentArea",
        "prevRoom", "prevName", "prevExits", "mode", "version"}
    mt = getmetatable(map) or {}
    mt.__index = mt
    mt.__newindex = function(tbl, key, value)
            if not table.contains(protected, key) then
                rawset(tbl, key, value)
            else
                error("Protected Map Table Value")
            end
        end
    mt.set = function(key, value)
            if table.contains(protected, key) then
                mt[key] = value
            end
        end
    setmetatable(map, mt)
    map.set("mode", configs.mode)
    map.set("version", version)

    local saves = {}
    if io.exists(path.."/map_save.dat") then
        table.load(path.."/map_save.dat",saves)
    end
    saves.prompt_pattern = saves.prompt_pattern or {}
    saves.ignore_patterns = saves.ignore_patterns or {}
    saves.move_methods = saves.move_methods or {}
    saves.recall = saves.recall or {}
    map.save = saves

    if map.configs.map_window.shown then
        map.showMap(true)
    end
end

local function parse_help_text(text)
  text = text:gsub("%$ROOM_NAME_STATUS", (map.currentName and map.currentName ~= "") and '✔️' or '❌')
  text = text:gsub("%$ROOM_NAME", map.currentName or '')

  text = text:gsub("%$ROOM_EXITS_STATUS", (not map.currentExits or table.is_empty(map.currentExits)) and '❌' or '✔️')
  text = text:gsub("%$ROOM_EXITS", map.currentExits and table.concat(map.currentExits, ' ') or '')

  return text
end

function map.show_help(cmd)
    if cmd and cmd ~= "" then
        if cmd:starts("map ") then cmd = cmd:sub(5) end
        cmd = cmd:lower():gsub(" ","_")
        if not map.help[cmd] then
            map.echo("No help file on that command.")
        end
    else
        cmd = 1
    end

    for w in parse_help_text(map.help[cmd]):gmatch("[^\n]*\n") do
        local url, target = rex.match(w, [[&lt;(url)?link: ([^&gt;]+)&gt;]])
        -- lrexlib returns a non-capture as 'false', so determine which variable the capture went into
        if target == nil then target = url end
        if target then
            local before, linktext, _, link, _, after, ok = rex.match(w,
                          [[(.*)&lt;((url)?link): [^&gt;]+&gt;(.*)&lt;\/(url)?link&gt;(.*)]], 0, 'm')
            -- could not get rex.match to capture the newline - fallback to string.match
            local _, _, after = w:match("(.*)&lt;u?r?l?link: [^&gt;]+&gt;(.*)&lt;/u?r?l?link&gt;(.*)")

            cecho(before)
            fg("yellow")
            setUnderline(true)
            if linktext == "urllink" then
                echoLink(link, [[openWebPage("]]..target..[[")]], "Open webpage", true)
            elseif target ~= "1" then
                echoLink(link,[[map.show_help("]]..target..[[")]],"View: map help " .. target,true)
            else
                echoLink(link,[[map.show_help()]],"View: map help",true)
            end
            setUnderline(false)
            resetFormat()
            if after then cecho(after) end
        else
            cecho(w)
        end
    end
    echo("\n")
end

local bool_configs = {'stretch_map', 'search_on_look', 'speedwalk_wait', 'speedwalk_random',
    'clear_lines_on_send', 'debug', 'custom_name_search', 'use_translation'}
-- function intended to be used by an alias to change config values and save them to a file for later
function map.setConfigs(key, val, sub_key)
    if val == "off" or val == "false" then
        val = false
    elseif val == "on" or val == "true" then
        val = true
    end
    local toggle = false
    if val == nil or val == "" then toggle = true end
    key = key:gsub(" ","_")
    if tonumber(val) then val = tonumber(val) end
    if not toggle then
        if key == "map_window" then
            if map.configs.map_window[sub_key] then
                map.configs.map_window[sub_key] = val
                map.echo(string.format("Map config %s set to: %s", sub_key, tostring(val)))
            else
                map.echo("Unknown map config.",false, true)
            end
        elseif key =="lang_dirs" then
            sub_key = exitmap[sub_key] or sub_key
            if map.configs.lang_dirs[sub_key] then
                local long_dir, short_dir = val[1],val[2]
                if #long_dir &lt; #short_dir then long_dir, short_dir = short_dir, long_dir end
                map.configs.lang_dirs[sub_key] = long_dir
                map.configs.lang_dirs[short[sub_key]] = short_dir
                map.echo(string.format("Direction/command %s, abbreviated as %s, now interpreted as %s.", long_dir, short_dir, sub_key))
                map.configs.translate = {}
                for k, v in pairs(map.configs.lang_dirs) do
                    map.configs.translate[v] = k
                end
            else
                map.echo("Invalid direction/command.", false, true)
            end
        elseif key == "prompt_test_patterns" then
            if not table.contains(map.configs.prompt_test_patterns) then
                table.insert(map.configs.prompt_test_patterns, val)
                map.echo("Prompt pattern added to list: " .. val)
            else
                table.remove(map.configs.prompt_test_patterns, table.index_of(map.configs.prompt_test_patterns, val))
                map.echo("Prompt pattern removed from list: " .. val)
            end
        elseif key == "custom_exits" then
            if type(val) == "table" then
                for k, v in pairs(val) do
                    map.configs.custom_exits[k] = v
                    map.echo(string.format("Custom Exit short direction %s, long direction %s",k,v[1]))
                    map.echo(string.format("    set to: x: %s, y: %s, z: %s, reverse: %s",v[3],v[4],v[5],v[2]))
                end
            else
                map.echo("Custom Exit config must be in the form of a table.", false, true)
            end
        elseif map.configs[key] ~= nil then
            map.configs[key] = val
            map.echo(string.format("Config %s set to: %s", key, tostring(val)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    elseif toggle then
        if (type(map.configs[key]) == "boolean" and table.contains(bool_configs, key)) then
            map.configs[key] = not map.configs[key]
            map.echo(string.format("Config %s set to: %s", key, tostring(map.configs[key])))
        elseif key == "map_window" and sub_key == "shown" then
            map.configs.map_window.shown = not map.configs.map_window.shown
            map.echo(string.format("Map config %s set to: %s", "shown", tostring(map.configs.map_window.shown)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    end
    table.save(profilePath.."/map downloads/configs.lua",map.configs)
    config()
end

local function show_err(msg,debug)
    map.echo(msg,debug,true)
    error(msg,2)
end

local function print_echoes(what, debug, err)
    moveCursorEnd("main")
    local curline = getCurrentLine()
    if curline ~= "" then echo("\n") end
    decho(mapper_tag)
    if debug then decho(debug_tag) end
    if err then decho(err_tag) end
    cecho(what)
    echo("\n")
end

local function print_wait_echoes()
    for k,v in ipairs(wait_echo) do
        print_echoes(v[1],v[2],v[3])
    end
    wait_echo = {}
end

function map.echo(what, debug, err, wait)
    if debug and not map.configs.debug then return end
    what = tostring(what) or ""
    if wait then
        table.insert(wait_echo,{what, debug, err})
        return
    end
    print_wait_echoes()
    print_echoes(what, debug, err)
end

local function set_room(roomID)
    -- moves the map to the new room
    if map.currentRoom ~= roomID then
        map.set("prevRoom", map.currentRoom)
        map.set("currentRoom", roomID)
    end
    if getRoomName(map.currentRoom) ~= map.currentName then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        map.set("currentName", getRoomName(map.currentRoom))
        map.set("currentExits", getRoomExits(map.currentRoom))
        -- check handling of custom exits here
        for i = 13,#stubmap do
            map.currentExits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
        end
    end
    map.set("currentArea", getRoomArea(map.currentRoom))
    centerview(map.currentRoom)
    raiseEvent("onMoveMap", map.currentRoom)
end

local function add_door(roomID, dir, status)
    -- create or remove a door in the designated direction
    -- consider options for adding pickable and passable information
    dir = exitmap[dir] or dir
    if not table.contains(exitmap,dir) then
        error("Add Door: invalid direction.",2)
    end
    if type(status) ~= "number" then
        status = assert(table.index_of({"none","open","closed","locked"},status),
            "Add Door: Invalid status, must be none, open, closed, or locked") - 1
    end
    local exits = getRoomExits(roomID)
    -- check handling of custom exits here
    if not exits[dir] then
        setExitStub(roomID,stubmap[dir],true)
    end
    -- check handling of custom exits here
    if not table.contains({'u','d'},short[dir]) then
        setDoor(roomID,short[dir],status)
    else
        setDoor(roomID,dir,status)
    end
end

local function check_doors(roomID,exits)
    -- looks to see if there are doors in designated directions
    -- used for room comparison, can also be used for pathing purposes
    if type(exits) == "string" then exits = {exits} end
    local statuses = {}
    local doors = getDoors(roomID)
    local dir
    for k,v in pairs(exits) do
        dir = short[k] or short[v]
        if table.contains({'u','d'},dir) then
            dir = exitmap[dir]
        end
        if not doors[dir] or doors[dir] == 0 then
            return false
        else
            statuses[dir] = doors[dir]
        end
    end
    return statuses
end

local function find_room(name, area)
    -- looks for rooms with a particular name, and if given, in a specific area
    local rooms = searchRoom(name)
    if type(area) == "string" then
        local areas = getAreaTable() or {}
        for k,v in pairs(areas) do
            if string.lower(k) == string.lower(area) then
                area = v
                break
            end
        end
        area = areas[area] or nil
    end
    for k,v in pairs(rooms) do
        if string.lower(v) ~= string.lower(name) then
            rooms[k] = nil
        elseif area and getRoomArea(k) ~= area then
            rooms[k] = nil
        end
    end
    return rooms
end

local function getRoomStubs(roomID)
    -- turns stub info into table similar to exit table
    local stubs = getExitStubs(roomID)
    if type(stubs) ~= "table" then stubs = {} end
    -- check handling of custom exits here
    local tmp
    for i = 13,#stubmap do
        tmp = tonumber(getRoomUserData(roomID,"stub "..stubmap[i])) or tonumber(getRoomUserData(roomID,"stub"..stubmap[i])) -- for old version
        if tmp then table.insert(stubs,tmp) end
    end

    local exits = {}
    for k,v in pairs(stubs) do
        exits[stubmap[v]] = 0
    end
    return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
    -- makes a connection between rooms
    -- can make backwards connection without a check
    local match = false
    if not ID1 and ID2 and dir1 then
        error("Connect Rooms: Missing Required Arguments.",2)
    end
    dir2 = dir2 or reverse_dirs[dir1]
    -- check handling of custom exits here
    if stubmap[dir1] &lt;= 12 then
        setExit(ID1,ID2,stubmap[dir1])
    else
        addSpecialExit(ID1, ID2, dir1)
        setRoomUserData(ID1,"exit " .. dir1,ID2)
    end
    if stubmap[dir1] &gt; 12 then
        -- check handling of custom exits here
        setRoomUserData(ID1,"stub "..dir1, stubmap[dir1])
    end
    local doors1, doors2 = getDoors(ID1), getDoors(ID2)
    local dstatus1, dstatus2 = doors1[short[dir1]] or doors1[dir1], doors2[short[dir2]] or doors2[dir2]
    if dstatus1 ~= dstatus2 then
        if not dstatus1 then
            add_door(ID1,dir1,dstatus2)
        elseif not dstatus2 then
            add_door(ID2,dir2,dstatus1)
        end
    end
    if map.mode ~= "complex" then
        local stubs = getRoomStubs(ID2)
        if stubs[dir2] then match = true end
        if (match or no_check) then
            -- check handling of custom exits here
            if stubmap[dir1] &lt;= 12 then
                setExit(ID2,ID1,stubmap[dir2])
            else
                addSpecialExit(ID2, ID1, dir2)
                setRoomUserData(ID2,"exit " .. dir2,ID1)
            end
            if stubmap[dir2] &gt; 12 then
                -- check handling of custom exits here
                setRoomUserData(ID2,"stub "..dir2, stubmap[dir2])
            end
        end
    end
end

local function check_room(roomID, name, exits, onlyName)
    -- check to see if room name or/and exits match expectations
    if not roomID then
        error("Check Room Error: No ID",2)
    end
    -- check with room hash id
    if map.prompt.hash then
        if map.prompt.hash == getRoomHashByID(roomID) then
            return true
        else
            return false
        end
    end

    if name ~= getRoomName(roomID) then return false end

    -- used in mode "lazy" to match only the room name
    if onlyName then return true end

    local t_exits = table.union(getRoomExits(roomID),getRoomStubs(roomID))
    -- check handling of custom exits here
    for i = 13,#stubmap do
        t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID,"exit " .. stubmap[i])) or (tonumber(getRoomUserData(roomID,"stub " .. stubmap[i])) and 0) or (tonumber(getRoomUserData(roomID,"stub" .. stubmap[i])) and 0) -- for old version
    end
    for k,v in ipairs(exits) do
        if short[v] and not table.contains(t_exits,v) then return false end
        t_exits[v] = nil
    end
    return table.is_empty(t_exits) or check_doors(roomID,t_exits)
end

local function stretch_map(dir,x,y,z)
    -- stretches a map to make room for just added room that would overlap with existing room
    local dx,dy,dz
    if not dir then return end
    for k,v in pairs(getAreaRooms(map.currentArea)) do
        if v ~= map.currentRoom then
            dx,dy,dz = getRoomCoordinates(v)
            if dx &gt;= x and string.find(dir,"east") then
                dx = dx + 1
            elseif dx &lt;= x and string.find(dir,"west") then
                dx = dx - 1
            end
            if dy &gt;= y and string.find(dir,"north") then
                dy = dy + 1
            elseif dy &lt;= y and string.find(dir,"south") then
                dy = dy - 1
            end
            if dz &gt;= z and string.find(dir,"up") then
                dz = dz + 1
            elseif dz &lt;= z and string.find(dir,"down") then
                dz = dz - 1
            end
            setRoomCoordinates(v,dx,dy,dz)
        end
    end
end

local function create_room(name, exits, dir, coords)
    -- makes a new room with captured name and exits
    -- links with other rooms as appropriate
    -- links to adjacent rooms in direction of exits if in simple mode
    if map.mapping then
        name = map.sanitizeRoomName(name)
        map.echo("New Room: " .. name,false,false,(dir or find_portal or force_portal) and true or false)
        local newID = createRoomID()
        addRoom(newID)
        setRoomArea(newID, map.currentArea)
        setRoomName(newID, name)
        if map.prompt.hash then
            setRoomIDbyHash(newID, map.prompt.hash)
        end
        for k,v in ipairs(exits) do
            if stubmap[v] then
                if stubmap[v] &lt;= 12 then
                    setExitStub(newID, stubmap[v], true)
                else
                    -- add special char to prompt special exit
                    if string.find(v, "up") or string.find(v, "down") then
                        setRoomChar(newID, "◎")
                    end
                    -- check handling of custom exits here
                    setRoomUserData(newID, "stub "..v,stubmap[v])
                end
            end
        end
        if dir then
            connect_rooms(map.currentRoom, newID, dir)
        elseif find_portal or force_portal then
            addSpecialExit(map.currentRoom, newID, (find_portal or force_portal))
            setRoomUserData(newID,"portals",tostring(map.currentRoom)..":"..(find_portal or force_portal))
        end
        setRoomCoordinates(newID,unpack(coords))
        local pos_rooms = getRoomsByPosition(map.currentArea,unpack(coords))
        if not (find_portal or force_portal) and map.configs.stretch_map and table.size(pos_rooms) &gt; 1 then
            set_room(newID)
            stretch_map(dir,unpack(coords))
        end
        if map.mode == "simple" then
            local x,y,z = unpack(coords)
            local dx,dy,dz,rooms
            for k,v in ipairs(exits) do
                if stubmap[v] then
                    dx,dy,dz = unpack(coordmap[stubmap[v]])
                    rooms = getRoomsByPosition(map.currentArea,x+dx,y+dy,z+dz)
                    if table.size(rooms) == 1 then
                        connect_rooms(newID,rooms[0],v)
                    end
                end
            end
        end
        set_room(newID)
    end
end

local function find_area_limits(areaID)
    -- used to find min and max coordinate limits for an area
    if not areaID then
        error("Find Limits: Missing area ID",2)
    end
    local rooms = getAreaRooms(areaID)
    local minx, miny, minz = getRoomCoordinates(rooms[0])
    local maxx, maxy, maxz = minx, miny, minz
    local x,y,z
    for k,v in pairs(rooms) do
        x,y,z = getRoomCoordinates(v)
        minx = math.min(x,minx)
        maxx = math.max(x,maxx)
        miny = math.min(y,miny)
        maxy = math.max(y,maxy)
        minz = math.min(z,minz)
        maxz = math.max(z,maxz)
    end
    return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
    -- search for matching room in desired direction
    -- in lazy mode check_room search only by name
    local x,y,z = getRoomCoordinates(map.currentRoom)
    if map.mapping and x then
        if max_distance &lt; 1 then
            max_distance = nil
        else
            max_distance = max_distance - 1
        end
        if not stubmap[dir] or not coordmap[stubmap[dir]] then return end
        local dx,dy,dz = unpack(coordmap[stubmap[dir]])
        local minx, maxx, miny, maxy, minz, maxz = find_area_limits(map.currentArea)
        local rooms, match, stubs
        if max_distance then
            minx, maxx = x - max_distance, x + max_distance
            miny, maxy = y - max_distance, y + max_distance
            minz, maxz = z - max_distance, z + max_distance
        end
        -- find link from room hash first
        if map.prompt.hash then
            local room = getRoomIDbyHash(map.prompt.hash)
            if room &gt; 0 then
                match = room
            end
        else
            repeat
                x, y, z = x + dx, y + dy, z + dz
                rooms = getRoomsByPosition(map.currentArea,x,y,z)
            until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
            for k,v in pairs(rooms) do
                if check_room(v,name,exits,false) then
                    match = v
                    break
                elseif map.mode == "lazy" and check_room(v,name,exits,true) then
                    match = v
                    break
                end
            end
        end
        if match then
            connect_rooms(map.currentRoom, match, dir)
            set_room(match)
        else
            x,y,z = getRoomCoordinates(map.currentRoom)
            create_room(name, exits, dir,{x+dx,y+dy,z+dz})
        end
    end
end

local function move_map()
    -- tries to move the map to the next room
    local move = table.remove(move_queue,1)
    if move or random_move then
        local exits = (map.currentRoom and getRoomExits(map.currentRoom)) or {}
        -- check handling of custom exits here
        if map.currentRoom then
            for i = 13, #stubmap do
                exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
            end
        end
        local special = (map.currentRoom and getSpecialExitsSwap(map.currentRoom)) or {}
        if move and not exits[move] and not special[move] then
            for k,v in pairs(special) do
                if string.starts(k,move) then
                    move = k
                    break
                end
            end
        end
        if find_portal then
            map.find_me(map.currentName,map.currentExits,move)
            find_portal = false
        elseif force_portal then
            find_portal = false
            map.echo("Creating portal destination")
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
            force_portal = false
        elseif move == "recall" and map.save.recall[map.character] then
            set_room(map.save.recall[map.character])
        elseif move == map.configs.lang_dirs['look'] and map.currentRoom and not check_room(map.currentRoom, map.currentName, map.currentExits) then
            -- this check isn't working as intended, find out why
            map.find_me(map.currentName,map.currentExits)
        else
            local onlyName
            if map.mode == "lazy" then
              onlyName = true
            else
              onlyName = false
            end
            if exits[move] and (vision_fail or check_room(exits[move], map.currentName, map.currentExits, onlyName)) then
                set_room(exits[move])
            elseif special[move] and (vision_fail or check_room(special[move], map.currentName, map.currentExits, onlyName)) then
                set_room(special[move])
            elseif not vision_fail then
                if map.mapping and move then
                    find_link(map.currentName, map.currentExits, move, map.configs.max_search_distance)
                else
                    map.find_me(map.currentName,map.currentExits, move)
                end
            end
        end
        vision_fail = false
    end
end

local function capture_move_cmd(dir,priority)
    -- captures valid movement commands
    local configs = map.configs
    if configs.clear_lines_on_send then
        lines = {}
    end
    dir = string.lower(dir)
    if dir == "/" then dir = "recall" end
    if dir == configs.lang_dirs['l'] then dir = configs.lang_dirs['look'] end
    if configs.use_translation then
        dir = configs.translate[dir] or dir
    end
    local door = string.match(dir,"open (%a+)")
    if map.mapping and door and (exitmap[door] or short[door]) then
        local doors = getDoors(map.currentRoom)
        if not doors[door] and not doors[short[door]] then
            map.set_door(door,"","")
        end
    end
    for i,v in ipairs(map.save.move_methods) do
    	local str = string.match(dir, v .. " (%a+)")
    	if str then 
    		dir = str
    		break
    	end
    end
    local portal = string.match(dir,"enter (%a+)")
    if map.mapping and portal then
        local portals = getSpecialExitsSwap(map.currentRoom)
        if not portals[dir] then
            map.set_portal(dir, true)
        end
    end
    if table.contains(exitmap,dir) or string.starts(dir,"enter ") or dir == "recall" then
      if dir ~= configs.lang_dirs['look'] then
        if priority then
            table.insert(move_queue,1,exitmap[dir] or dir)
        else
            table.insert(move_queue,exitmap[dir] or dir)
        end
      else
        if configs.search_on_look == true then
          table.insert(move_queue, dir)
        end
    end				
    elseif map.currentRoom then
        local special = getSpecialExitsSwap(map.currentRoom) or {}
        if special[dir] then
            if priority then
                table.insert(move_queue,1,dir)
            else
                table.insert(move_queue,dir)
            end
        end
    end
end

local function deduplicate_exits(exits)
  local deduplicated_exits = {}
  for _, v in ipairs(exits) do
    deduplicated_exits[v] = true
  end

  return table.keys(deduplicated_exits)
end
local function capture_room_info(name, exits)
    -- captures room info, and tries to move map to match
    if (not vision_fail) and name and exits then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        name = string.trim(name)
        map.set("currentName", name)
        if exits:ends(".") then exits = exits:sub(1,#exits-1) end
        if not map.configs.use_translation then
            exits = string.gsub(string.lower(exits)," and "," ")
        end
        map.set("currentExits", {})
        for w in string.gmatch(exits,"%a+") do
            if map.configs.use_translation then
                local dir = map.configs.translate and map.configs.translate[w]
                if dir then table.insert(map.currentExits,dir) end
            else
                table.insert(map.currentExits,w)
            end
        end
        undupeExits = deduplicate_exits(map.currentExits)
        map.set("currentExits", undupeExits)
        map.echo(string.format("Exits Captured: %s (%s)",exits, table.concat(map.currentExits, " ")),true)
        move_map()
    elseif vision_fail then
        move_map()
    end
end

local function find_area(name)
    -- searches for the named area, and creates it if necessary
    local areas = getAreaTable()
    local areaID
    for k,v in pairs(areas) do
        if string.lower(name) == string.lower(k) then
            areaID = v
            break
        end
    end
    if not areaID then areaID = addAreaName(name) end
    if not areaID then
        show_err("Invalid Area. No such area found, and area could not be added.",true)
    end
    map.set("currentArea", areaID)
end

function map.load_map(address)
    local path = profilePath .. "/map downloads/map.dat"
    if not address then
        loadMap(path)
        map.echo("Map reloaded from local copy.")
    else
        if not string.match(address,"/[%a_]+%.dat$") then
            address = address .. "/map.dat"
        end
        downloading = true
        downloadFile(path, address)
        map.echo(string.format("Downloading map file from: %s.",address))
    end
end

function map.set_exit(dir,roomID)
    -- used to set unusual exits from the room you are standing in
    if map.mapping then
        roomID = tonumber(roomID)
        if not roomID then
            show_err("Set Exit: Invalid Room ID")
        end
        if not table.contains(exitmap,dir) and not string.starts(dir, "-p ") then
            show_err("Set Exit: Invalid Direction")
        end

        if not string.starts(dir, "-p ") then
            local exit
            if stubmap[exitmap[dir] or dir] &lt;= 12 then
                exit = short[exitmap[dir] or dir]
                setExit(map.currentRoom,roomID,exit)
            else
                -- check handling of custom exits here
                exit = exitmap[dir] or dir
                exit = "exit " .. exit
                setRoomUserData(map.currentRoom,exit,roomID)
            end
            map.echo("Exit " .. dir .. " now goes to roomID " .. roomID)
        else
            dir = string.gsub(dir,"^-p ","")
            addSpecialExit(map.currentRoom,roomID,dir)
            map.echo("Special exit '" .. dir .. "' now goes to roomID " .. roomID)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.find_path(roomName,areaName,return_tables)
    areaName = (areaName ~= "" and areaName) or nil
    local rooms = find_room(roomName,areaName)
    local found,dirs = false,{}
    local path = {}
    for k,v in pairs(rooms) do
        found = getPath(map.currentRoom,k)
        if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
            dirs = speedWalkDir
            path = speedWalkPath
        end
    end
    if return_tables then
        if table.is_empty(path) then
            path, dirs = nil, nil
        end
        return path, dirs
    else
        if #dirs &gt; 0 then
            map.echo("Path to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ": " .. table.concat(dirs,", "))
        else
            map.echo("No path found to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ".",false,true)
        end
    end
end

function map.export_area(name)
    -- used to export a single area to a file
    local areas = getAreaTable()
    name = string.lower(name)
    for k,v in pairs(areas) do
        if name == string.lower(k) then name = k end
    end
    if not areas[name] then
        show_err("No such area.")
    end
    local rooms = getAreaRooms(areas[name])
    local tmp = {}
    for k,v in pairs(rooms) do
        tmp[v] = v
    end
    rooms = tmp
    local tbl = {}
    tbl.name = name
    tbl.rooms = {}
    tbl.exits = {}
    tbl.special = {}
    local rname, exits, stubs, doors, special, portals, door_up, door_down, coords, environment, roomChar
    for k,v in pairs(rooms) do
        rname = getRoomName(v)
        exits = getRoomExits(v)
        stubs = getExitStubs(v)
        doors = getDoors(v)
        special = getSpecialExitsSwap(v)
        portals = getRoomUserData(v,"portals") or ""
	environment = getRoomEnv(v)
	roomChar = getRoomChar(v)
        coords = {getRoomCoordinates(v)}
        tbl.rooms[v] = {name = rname, coords = coords, exits = exits, stubs = stubs, doors = doors, door_up = door_up,
            door_down = door_down, door_in = door_in, door_out = door_out, special = special, portals = portals, environment = environment, roomChar = roomChar}
        tmp = {}
        for k1,v1 in pairs(exits) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.exits[v] = tmp
        end
        tmp = {}
        for k1,v1 in pairs(special) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.special[v] = tmp
        end
    end
    local path = profilePath.."/"..string.gsub(string.lower(name),"%s","_")..".dat"
    table.save(path,tbl)
    map.echo("Area " .. name .. " exported to " .. path)
end

function map.import_area(name)
    name = profilePath .. "/" .. string.gsub(string.lower(name),"%s","_") .. ".dat"
    local tbl = {}
    table.load(name,tbl)
    if table.is_empty(tbl) then
        show_err("No file found")
    end
    local areas = getAreaTable()
    local areaID = areas[tbl.name] or addAreaName(tbl.name)
    local rooms = {}
    local ID
    for k,v in pairs(tbl.rooms) do
        ID = createRoomID()
        rooms[k] = ID
        addRoom(ID)
        setRoomName(ID,v.name)
        setRoomArea(ID,areaID)
        setRoomCoordinates(ID,unpack(v.coords))
        if type(v.stubs) == "table" then
            for i,j in pairs(v.stubs) do
                setExitStub(ID,j,true)
            end
        end
        for i,j in pairs(v.doors) do
            setDoor(ID,i,j)
        end
        setRoomUserData(ID,"portals",v.portals)
	setRoomEnv(ID,v.environment)
	setRoomChar(ID,v.roomChar)
    end
    for k,v in pairs(tbl.rooms) do
        for i,j in pairs(v.exits) do
            if rooms[j] then
                connect_rooms(rooms[k],rooms[j],i)
            end
        end
        for i,j in pairs(v.special) do
            if rooms[j] then
                addSpecialExit(rooms[k],rooms[j],i)
            end
        end
    end
    for k,v in pairs(tbl.exits) do
        for i,j in pairs(v) do
            if getRoomName(j[1]) == j[2] then
                connect_rooms(rooms[k],j[1],i)
            end
        end
    end
    for k,v in pairs(tbl.special) do
        for i,j in pairs(v) do
            addSpecialExit(k,j[1],i)
        end
    end
    map.fix_portals()
    map.echo("Area " .. tbl.name .. " imported from " .. name)
end

function map.set_recall()
    -- assigned the current room to be recall for the current character
    map.save.recall[map.character] = map.currentRoom
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Recall room set to: " .. getRoomName(map.currentRoom) .. ".")
end

function map.set_portal(name, is_auto)
    -- creates a new portal in the room
    if map.mapping then
        if not string.starts(name,"-f ") then
            find_portal = name
        else
            name = string.gsub(name,"^-f ","")
            force_portal = name
        end
        move_queue = {name}
        if not is_auto then
            send(name)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_mode(mode)
    -- switches mapping modes
    if not table.contains({"lazy","simple","normal","complex"},mode) then
        show_err("Invalid Map Mode, must be 'lazy', 'simple', 'normal' or 'complex'.")
    end
    map.set("mode", mode)
    map.echo("Current mode set to: " .. mode)
end

function map.start_mapping(area_name)
    -- starts mapping, and sets the current area to the given one, or uses the current one
    if not map.currentName then
        show_err("Room detection not yet working, see &lt;yellow&gt;map basics&lt;reset&gt; for guidance.")
    end
    local rooms
    move_queue = {}
    area_name = area_name ~= "" and area_name or nil
    if map.currentArea and not area_name then
        local areas = getAreaTableSwap()
        area_name = areas[map.currentArea]
    end
    if not area_name then
        show_err("You haven't started mapping yet, how should the first area be called? Set it with: &lt;yellow&gt;start mapping &lt;area name&gt;&lt;reset&gt;")
    end
    map.echo("Now mapping in area: " .. area_name)
    map.set("mapping", true)
    find_area(area_name)
    rooms = find_room(map.currentName, map.currentArea)
    if table.is_empty(rooms) then
        if map.currentRoom and getRoomName(map.currentRoom) == map.currentName then
            map.set_area(area_name)
        else
            create_room(map.currentName, map.currentExits, nil, {0,0,0})
        end
    elseif map.currentRoom and map.currentArea ~= getRoomArea(map.currentRoom) then
        map.set_area(area_name)
    end
end

function map.stop_mapping()
    map.set("mapping", false)
    map.echo("Mapping off.")
end

function map.clear_moves()
    local commands_in_queue = #move_queue
    move_queue = {}
    map.echo("Move queue cleared, "..commands_in_queue.." commands removed.")
end

function map.show_moves()
    map.echo("Moves: "..(move_queue and table.concat(move_queue, ', ') or '(queue empty)'))
end

function map.set_area(name)
    -- assigns the current room to the area given, creates the area if necessary
    if map.mapping then
        find_area(name)
        if map.currentRoom and getRoomArea(map.currentRoom) ~= map.currentArea then
            setRoomArea(map.currentRoom,map.currentArea)
            set_room(map.currentRoom)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_door(dir,status,one_way)
    -- adds a door on a given exit
    if map.mapping then
        if not map.currentRoom then
            show_err("Make Door: No room found.")
        end
        dir = exitmap[dir] or dir
        if not stubmap[dir] then
            show_err("Make Door: Invalid direction.")
        end
        status = (status ~= "" and status) or "closed"
        one_way = (one_way ~= "" and one_way) or "no"
        if not table.contains({"yes","no"},one_way) then
            show_err("Make Door: Invalid one-way status, must be yes or no.")
        end

        local exits = getRoomExits(map.currentRoom)
        local exit
        -- check handling of custom exits here
        for i = 13,#stubmap do
            exit = "exit " .. stubmap[i]
            exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,exit))
        end
        local target_room = exits[dir]
        if target_room then
            exits = getRoomExits(target_room)
            -- check handling of custom exits here
            for i = 13,#stubmap do
                exit = "exit " .. stubmap[i]
                exits[stubmap[i]] = tonumber(getRoomUserData(target_room,exit))
            end
        end
        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == map.currentRoom) then
            add_door(target_room,reverse_dirs[dir],status)
        end
        add_door(map.currentRoom,dir,status)
        map.echo(string.format("Adding %s door to the %s", status, dir))
    else
        map.echo("Not mapping",false,true)
    end
end

function map.shift_room(dir)
    -- shifts a room around on the map
    if map.mapping then
        dir = exitmap[dir] or (table.contains(exitmap,dir) and dir)
        if not dir then
            show_err("Shift Room: Exit not found")
        end
        local x,y,z = getRoomCoordinates(map.currentRoom)
        dir = stubmap[dir]
        local coords = coordmap[dir]
        x = x + coords[1]
        y = y + coords[2]
        z = z + coords[3]
        setRoomCoordinates(map.currentRoom,x,y,z)
        centerview(map.currentRoom)
        map.echo("Shifting room",true)
    else
        map.echo("Not mapping",false,true)
    end
end

local function check_link(firstID, secondID, dir)
    -- check to see if two rooms are connected in a given direction
    if not firstID then error("Check Link Error: No first ID",2) end
    if not secondID then error("Check Link Error: No second ID",2) end
    local name = getRoomName(firstID)
    local exits1 = table.union(getRoomExits(firstID),getRoomStubs(firstID))
    local exits2 = table.union(getRoomExits(secondID),getRoomStubs(secondID))
    local exit
    -- check handling of custom exits here
    for i = 13,#stubmap do
        exit = "exit " .. stubmap[i]
        exits1[stubmap[i]] = tonumber(getRoomUserData(firstID,exit))
        exits2[stubmap[i]] = tonumber(getRoomUserData(secondID,exit))
    end
    local checkID = exits2[reverse_dirs[dir]]
    local exits = {}
    for k,v in pairs(exits1) do
        table.insert(exits,k)
    end
    return checkID and check_room(checkID,name,exits)
end

function map.find_me(name, exits, dir, manual)
    -- tries to locate the player using the current room name and exits, and if provided, direction of movement
    -- if direction of movement is given, narrows down possibilities using previous room info
    if move ~= "recall" then move_queue = {} end
    -- find from room hash id - map.find_me(nil, nil, nil, false)
    if map.prompt.hash then
        local room = getRoomIDbyHash(map.prompt.hash)
        if room &gt; 0 then
            set_room(room)
            map.echo("Room found, ID: " .. room, true)
            return
        else
            map.echo("Room not found in map database!", not manual, true)
            return
        end
    end
    local check = dir and map.currentRoom and table.contains(exitmap,dir)
    name = name or map.currentName
    exits = exits or map.currentExits
    if not name and not exits then
        show_err("Room not found, complete room name and exit data not available.")
    end
    local rooms = find_room(name)
    local match_IDs = {}
    for k,v in pairs(rooms) do
        if check_room(k, name, exits) then
            table.insert(match_IDs,k)
        end
    end
    rooms = match_IDs
    match_IDs = {}
    if table.size(rooms) &gt; 1 and check then
        for k,v in pairs(rooms) do
            if check_link(map.currentRoom,v,dir) then
                table.insert(match_IDs,v)
            end
        end
    elseif random_move then
        for k,v in pairs(getRoomExits(map.currentRoom)) do
            if check_room(v,map.currentName,map.currentExits) then
                table.insert(match_IDs,v)
            end
        end
    end
    if table.size(match_IDs) == 0 then
        match_IDs = rooms
    end
    if table.index_of(match_IDs,map.currentRoom) then
        match_IDs = {map.currentRoom}
    end
    if not table.is_empty(match_IDs) and not find_portal then
        set_room(match_IDs[1])
        map.echo("Room found, ID: " .. match_IDs[1],true)
    elseif find_portal then
        if not table.is_empty(match_IDs) then
            map.echo("Found portal destination, linking rooms",false,false,true)
            addSpecialExit(map.currentRoom,match_IDs[1],find_portal)
            local portals = getRoomUserData(match_IDs[1],"portals") or ""
            portals = portals .. "," .. tostring(map.currentRoom)..":"..find_portal
            setRoomUserData(match_IDs[1],"portals",portals)
            set_room(match_IDs[1])
            map.echo("Room found, ID: " .. match_IDs[1],true)
        else
            map.echo("Creating portal destination",false,false,true)
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
        end
        find_portal = false
    elseif table.is_empty(match_IDs) then
        map.echo("Room not found in map database", not manual, true)
    end
end

function map.fix_portals()
    if map.mapping then
        -- used to clear and update data for portal back-referencing
        local rooms = getRooms()
        local portals
        for k,v in pairs(rooms) do
            setRoomUserData(k,"portals","")
        end
        for k,v in pairs(rooms) do
            for cmd,room in pairs(getSpecialExitsSwap(k)) do
                portals = getRoomUserData(room,"portals") or ""
                if portals ~= "" then portals = portals .. "," end
                portals = portals .. tostring(k) .. ":" .. cmd
                setRoomUserData(room,"portals",portals)
            end
        end
        map.echo("Portals Fixed")
    else
        map.echo("Not mapping",false,true)
    end
end

function map.merge_rooms()
    -- used to combine essentially identical rooms with the same coordinates
    -- typically, these are generated due to mapping errors
    if map.mapping then
        map.echo("Merging rooms")
        local x,y,z = getRoomCoordinates(map.currentRoom)
        local rooms = getRoomsByPosition(map.currentArea,x,y,z)
        local exits, portals, room, cmd, curportals
        local room_count = 1
        for k,v in pairs(rooms) do
            if v ~= map.currentRoom then
                if getRoomName(v) == getRoomName(map.currentRoom) then
                    room_count = room_count + 1
                    for k1,v1 in pairs(getRoomExits(v)) do
                        setExit(map.currentRoom,v1,stubmap[k1])
                        exits = getRoomExits(v1)
                        if exits[reverse_dirs[k1]] == v then
                            setExit(v1,map.currentRoom,stubmap[reverse_dirs[k1]])
                        end
                    end
                    for k1,v1 in pairs(getDoors(v)) do
                        setDoor(map.currentRoom,k1,v1)
                    end
                    for k1,v1 in pairs(getSpecialExitsSwap(v)) do
                        addSpecialExit(map.currentRoom,v1,k1)
                    end
                    portals = getRoomUserData(v,"portals") or ""
                    if portals ~= "" then
                        portals = string.split(portals,",")
                        for k1,v1 in ipairs(portals) do
                            room,cmd = unpack(string.split(v1,":"))
                            addSpecialExit(tonumber(room),map.currentRoom,cmd)
                            curportals = getRoomUserData(map.currentRoom,"portals") or ""
                            if not string.find(curportals,room) then
                                curportals = curportals .. "," .. room .. ":" .. cmd
                                setRoomUserData(map.currentRoom,"portals",curportals)
                            end
                        end
                    end
                    -- check handling of custom exits here for doors and exits, and reverse exits
                    for i = 13,#stubmap do
                        local door = "door " .. stubmap[i]
                        local tmp = tonumber(getRoomUserData(v,door))
                        if tmp then
                            setRoomUserData(map.currentRoom,door,tmp)
                        end
                        local exit = "exit " .. stubmap[i]
                        tmp = tonumber(getRoomUserData(v,exit))
                        if tmp then
                            setRoomUserData(map.currentRoom,exit,tmp)
                            if tonumber(getRoomUserData(tmp, "exit " .. reverse_dirs[stubmap[i]])) == v then
                                setRoomUserData(tmp, exit, map.currentRoom)
                            end
                        end
                    end
                    deleteRoom(v)
                end
            end
        end
        if room_count &gt; 1 then
            map.echo(room_count .. " rooms merged", true)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.findAreaID(areaname, exact)
    local areaname = areaname:lower()
    local list = getAreaTable()

    -- iterate over the list of areas, matching them with substring match.
    -- if we get match a single area, then return its ID, otherwise return
    -- 'false' and a message that there are than one are matches
    local returnid, fullareaname, multipleareas = nil, nil, {}
    for area, id in pairs(list) do
        if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
            returnid = id
            fullareaname = area
            multipleareas[#multipleareas+1] = area
        end
    end

    if #multipleareas == 1 then
        return returnid, fullareaname
    else
        return nil, nil, multipleareas
    end
end

function map.echoRoomList(areaname, exact)
    local areaid, msg, multiples
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"
    if tonumber(areaname) then
        areaid = tonumber(areaname)
        msg = getAreaTableSwap()[areaid]
    else
        areaid, msg, multiples = map.findAreaID(areaname, exact)
    end
    if areaid then
        local roomlist, endresult = getAreaRooms(areaid) or {}, {}

        -- obtain a room list for each of the room IDs we got
        local getRoomName = getRoomName
        for _, id in pairs(roomlist) do
            endresult[id] = getRoomName(id)
        end
        roomlist[#roomlist+1], roomlist[0] = roomlist[0], nil
        -- sort room IDs so we can display them in order
        table.sort(roomlist)

        local echoLink, format, fg, echo = echoLink, string.format, fg, cecho
        -- now display something half-decent looking
        cecho(format("&lt;%s&gt;List of all rooms in &lt;%s&gt;%s&lt;%s&gt; (areaID &lt;%s&gt;%s&lt;%s&gt; - &lt;%s&gt;%d&lt;%s&gt; rooms):\n",
            listcolor, othercolor, msg, listcolor, othercolor, areaid, listcolor, othercolor, #roomlist, listcolor))
        -- use pairs, as we can have gaps between room IDs
        for _, roomid in pairs(roomlist) do
            local roomname = endresult[roomid]
            cechoLink(format("&lt;%s&gt;%7s",othercolor,roomid), 'map.speedwalk('..roomid..')',
                format("Go to %s (%s)", roomid, tostring(roomname)), true)
            cecho(format("&lt;%s&gt;: &lt;%s&gt;%s&lt;%s&gt;.\n", listcolor, othercolor, roomname, listcolor))
        end
    elseif not areaid and #multiples &gt; 0 then
        local allareas, format = getAreaTable(), string.format
        local function countrooms(areaname)
            local areaid = allareas[areaname]
            local allrooms = getAreaRooms(areaid) or {}
            local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
            return areac
        end
        map.echo("For which area would you want to list rooms for?")
        for _, areaname in ipairs(multiples) do
            echo("  ")
            setUnderline(true)
            cechoLink(format("&lt;%s&gt;%-40s (%d rooms)", othercolor, areaname, countrooms(areaname)),
                'map.echoRoomList("'..areaname..'", true)', "Click to view the room list for "..areaname, true)
            setUnderline(false)
            echo("\n")
        end
    else
        map.echo(string.format("Don't know of any area named '%s'.", areaname),false,true)
    end
    resetFormat()
end

function map.echoAreaList()
    local totalroomcount = 0
    local rlist = getAreaTableSwap()
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"

    -- count the amount of rooms in an area, taking care to count the room in the 0th
    -- index as well if there is one
    -- saves the total room count on the side as well
    local function countrooms(areaid)
        local allrooms = getAreaRooms(areaid) or {}
        local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
        totalroomcount = totalroomcount + areac
        return areac
    end

    local getAreaRooms, cecho, fg, echoLink = getAreaRooms, cecho, fg, echoLink
    cecho(string.format("&lt;%s&gt;List of all areas we know of (click to view room list):\n",listcolor))
    for id = 1,table.maxn(rlist) do
        if rlist[id] then
            cecho(string.format("&lt;%s&gt;%7d ", othercolor, id))
            fg(listcolor)
            echoLink(string.format("%-40s (%d rooms)",rlist[id],countrooms(id)), 'map.echoRoomList("'..id..'", true)',
                "View the room list for "..rlist[id], true)
            echo("\n")
        end
    end
    cecho(string.format("&lt;%s&gt;Total amount of rooms in this map: %s\n", listcolor, totalroomcount))
end

function map.search_timer_check()
    if find_prompt then
        map.echo("Prompt not auto-detected, use 'map prompt' to set a prompt pattern.",false,true)
        find_prompt = false
    end
end

function map.find_prompt()
    find_prompt = true
    map.echo("Searching for prompt.")
    send("\n", false)
    tempTimer(5, "map.search_timer_check()")
end

function map.make_prompt_pattern(str)
    if not str:starts("^") then str = "^"..str end
    map.save.prompt_pattern[map.character] = str
    find_prompt = false
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Prompt pattern set: " .. str)
end

function map.make_ignore_pattern(str)
    map.save.ignore_patterns = map.save.ignore_patterns or {}
    if not table.contains(map.save.ignore_patterns,str) then
        table.insert(map.save.ignore_patterns,str)
        map.echo("Ignore pattern added: " .. str)
    else
        table.remove(map.save.ignore_patterns, table.index_of(map.save.ignore_patterns, str))
        map.echo("Ignore pattern removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

function map.make_move_method(str)
    map.save.move_methods = map.save.move_methods or {}
    if not table.contains(map.save.move_methods,str) then
        table.insert(map.save.move_methods,str)
        map.echo("Move method added: " .. str)
    else
        table.remove(map.save.move_methods, table.index_of(map.save.move_methods, str))
        map.echo("Move method removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

local function grab_line()
    table.insert(lines,line)
    if map.save.prompt_pattern[map.character] and string.match(line, map.save.prompt_pattern[map.character]) then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt captured",true)
    end
    if find_prompt then
        for k,v in ipairs(map.configs.prompt_test_patterns) do
            if string.match(line,v) then
                map.save.prompt_pattern[map.character] = v
                table.save(profilePath .. "/map downloads/map_save.dat",map.save)
                find_prompt = false
                map.echo("Prompt found")
                break
            end
        end
    end
end

local function name_search()
    local room_name
    if map.configs.custom_name_search then
        room_name = mudlet.custom_name_search(lines)
    else
        local line_count = #lines + 1
        local cur_line, last_line
        local prompt_pattern = map.save.prompt_pattern[map.character]
        if not prompt_pattern then return end
        while not room_name do
            line_count = line_count - 1
            if not lines[line_count] then break end
            cur_line = lines[line_count]
            for k,v in ipairs(map.save.ignore_patterns) do
                cur_line = string.trim(string.gsub(cur_line,v,""))
            end
            if string.find(cur_line,prompt_pattern) then
                cur_line = string.trim(string.gsub(cur_line,prompt_pattern,""))
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif line_count == 1 then
                cur_line = string.trim(cur_line)
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif not string.match(cur_line,"^%s*$") then
                last_line = cur_line
            end
        end
        lines = {}
        room_name = room_name:sub(1,100)
    end
    return room_name
end

local function handle_exits(exits)
    local room = map.prompt.room or name_search()
    room = map.sanitizeRoomName(room)
    exits = map.prompt.exits or exits
    exits = string.lower(exits)
    exits = string.gsub(exits,"%a+", exitmap)
    if room then
        map.echo("Room Name Captured: " .. room, true)
        room = string.trim(room)
        capture_room_info(room, exits)
        map.prompt.room = nil
        map.prompt.exits = nil
    end
end

local continue_walk, timerID
continue_walk = function(new_room)
    if not walking then return end
    -- calculate wait time until next command, with randomness
    local wait = map.configs.speedwalk_delay or 0
    if wait &gt; 0 and map.configs.speedwalk_random then
        wait = wait * (1 + math.random(0,100)/100)
    end
    -- if no wait after new room, move immediately
    if new_room and map.configs.speedwalk_wait and wait == 0 then
        new_room = false
    end
    -- send command if we don't need to wait
    if not new_room then
        --handle script exits
        if string.starts(map.walkDirs[1], "script:") then
          map.walkDirs[1] = string.gsub(map.walkDirs[1], "script:", "")
          loadstring(table.remove(map.walkDirs,1))()
        else
          send(table.remove(map.walkDirs,1))
        end
        -- check to see if we are done
        if #map.walkDirs == 0 then
            walking = false
            speedWalkPath, speedWalkWeight = {}, {}
            raiseEvent("sysSpeedwalkFinished")
        end
    end
    -- make tempTimer to send next command if necessary
    if walking and (not map.configs.speedwalk_wait or (map.configs.speedwalk_wait and wait &gt; 0)) then
        if timerID then killTimer(timerID) end
        timerID = tempTimer(wait, function() continue_walk() end)
    end
end

function map.speedwalk(roomID, walkPath, walkDirs)
    roomID = roomID or speedWalkPath[#speedWalkPath]
    getPath(map.currentRoom, roomID)
    walkPath = speedWalkPath
    walkDirs = speedWalkDir
    if #speedWalkPath == 0 then
        map.echo("No path to chosen room found.",false,true)
        return
    end
    table.insert(walkPath, 1, map.currentRoom)
    -- go through dirs to find doors that need opened, etc
    -- add in necessary extra commands to walkDirs table
    local k = 1
    repeat
        local id, dir = walkPath[k], walkDirs[k]
        if exitmap[dir] or short[dir] then
            local door = check_doors(id, exitmap[dir] or dir)
            local status = door and door[dir]
            if status and status &gt; 1 then
                -- if locked, unlock door
                if status == 3 then
                    table.insert(walkPath,k,id)
                    table.insert(walkDirs,k,"unlock " .. (exitmap[dir] or dir))
                    k = k + 1
                end
                -- if closed, open door
                table.insert(walkPath,k,id)
                table.insert(walkDirs,k,"open " .. (exitmap[dir] or dir))
                k = k + 1
            end
        end
        k = k + 1
    until k &gt; #walkDirs
    if map.configs.use_translation then
        for k, v in ipairs(walkDirs) do
            walkDirs[k] = map.configs.lang_dirs[v] or v
        end
    end
    -- perform walk
    walking = true
    if map.configs.speedwalk_wait or map.configs.speedwalk_delay &gt; 0 then
        map.walkDirs = walkDirs
        continue_walk()
    else
        for _,dir in ipairs(walkDirs) do
           if string.starts(dir, "script:") then
              dir = string.gsub(dir, "script:", "")
              loadstring(dir)()
            else
              send(dir)
           end
        end
        walking = false
        raiseEvent("sysSpeedwalkFinished")
    end
end

function doSpeedWalk()
    if #speedWalkPath ~= 0 then
        raiseEvent("sysSpeedwalkStarted")
        map.speedwalk(nil, speedWalkPath, speedWalkDir)
    else
        map.echo("No path to chosen room found.",false,true)
    end
end

function map.pauseSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        raiseEvent("sysSpeedwalkPaused")
        map.echo("Speedwalking paused.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.resumeSpeedwalk(delay)
    if #speedWalkDir ~= 0 then
        map.find_me(nil, nil, nil, true)
        raiseEvent("sysSpeedwalkResumed")
        map.echo("Speedwalking resumed.")
        tempTimer(delay or 0, function() map.speedwalk(nil, speedWalkPath, speedWalkDir) end)
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.stopSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        map.walkDirs, speedWalkDir, speedWalkPath, speedWalkWeight = {}, {}, {}, {}
        raiseEvent("sysSpeedwalkStopped")
        map.echo("Speedwalking stopped.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.toggleSpeedwalk(what)
    assert(what == nil or what == "on" or what == "off", "map.toggleSpeedwalk wants 'on', 'off' or nothing as an argument")

    if what == "on" or (what == nil and walking) then
        map.pauseSpeedwalk()
    elseif what == "off" or (what == nil and not walking) then
        map.resumeSpeedwalk()
    end
end

local function check_version()
    downloading = false
    local path = profilePath .. "/map downloads/versions.lua"
    local versions = {}
    table.load(path, versions)
    local pos = table.index_of(versions, map.version) or 0
    if pos ~= #versions then
        enableAlias("Map Update Alias")
        if not map.silentUpdate then
          map.echo(string.format("The Generic Mapping Script is currently &lt;red&gt;%d&lt;reset&gt; versions behind.",#versions - pos))
          map.echo("To update now, please type: &lt;yellow&gt;map update&lt;reset&gt;")
        else
          map.updateVersion()
        end
    end
    map.update_timer = tempTimer(3600, [[map.checkVersion()]])
end

function map.checkVersion()
    if #getRooms() &gt; 0 then
      map.silentUpdate = false
    end    
    if map.update_timer then
        killTimer(map.update_timer)
        map.update_timer = nil
    end
    if not map.update_waiting and map.configs.download_path ~= "" then
        local path, file = profilePath .. "/map downloads", "/versions.lua"
        downloading = true
        downloadFile(path .. file, map.configs.download_path .. file)
        map.update_waiting = true
    end
end

local function update_version()
    downloading = false
    local path = profilePath .. "/map downloads/generic_mapper.xml"
    disableAlias("Map Update Alias")
    map.updatingMapper = true
    uninstallPackage("generic_mapper")
    installPackage(path)
    map.updatingMapper = nil
    if not map.silentUpdate then
      map.echo("Generic Mapping Script updated successfully.")
    end
end

function map.updateVersion()
    local path, file = profilePath .. "/map downloads", "/generic_mapper.xml"
    downloading = true
    downloadFile(path .. file, map.configs.download_path .. file)
end

function map.showMap(shown)
    local configs = map.configs.map_window
    shown = shown or not configs.shown
    map.configs.map_window.shown = shown
    map.silentUpdate = false
    local x, y, w, h, origin = configs.x, configs.y, configs.w, configs.h, configs.origin
    if string.find(origin,"bottom") then
        if y == 0 or y == "0%" then
            y = h
        end
        if type(y) == "number" then
            y = -y
        else
            y = "-"..y
        end
    end
    if string.find(origin,"right") then
        if x == 0 or x == "0%" then
            x = w
        end
        if type(x) == "number" then
            x = -x
        else
            x = "-"..x
        end
    end
    local mapper = Geyser.Mapper:new({name = "my_mapper", x = x, y = y, w = w, h = h})
    mapper:resize(w,h)
    mapper:move(x,y)
    if shown then
        mapper:show()
    else
        mapper:hide()
    end
end

-- some games embed an ASCII map on the same line, which messes up the room room name
-- extract the longest continuous piece of text from the line to be the room name
function map.sanitizeRoomName(roomtitle)
  -- sometimes we get 'nil' for a room title - ignore that silently
  if type(roomtitle) ~= "string" then
    return roomtitle
  end

  if not roomtitle:match("   ") then
    -- if the whole line does not contain a run of three consecutive spaces then
    -- consider the whole line as the room name; this was previously two spaces
    -- but some MUDs do have titles that are multiple (short) sentances AND
    -- put TWO spaces after a full-stop for the first (e.g. After the Plague MUD
    -- on telnet://atp.pedia.szote.u-szeged.hu:3000)
    return roomtitle
  end

  -- otherwise split the text up in double-spaced chunks and return the longest
  -- run of bytes found in those chunks
  local parts = roomtitle:split("  ")
  table.sort(parts, function(a,b) return #a &lt; #b end)
  local longestpart = parts[#parts]

  local trimmed = utf8.match(longestpart, "[%w ]+"):trim()
  return trimmed
end

function map.eventHandler(event, ...)
    if event == "onNewRoom" then
        handle_exits(arg[1])
        if walking and map.configs.speedwalk_wait then
            continue_walk(true)
        end
    elseif event == "onPrompt" then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt Captured",true)
    elseif event == "onMoveFail" then
        map.echo("onMoveFail",true)
        table.remove(move_queue,1)
    elseif event == "onVisionFail" then
        map.echo("onVisionFail",true)
        vision_fail = true
        capture_room_info()
    elseif event == "onRandomMove" then
        map.echo("onRandomMove",true)
        random_move = true
        move_queue = {}
    elseif event == "onForcedMove" then
        map.echo("onForcedMove",true)
        capture_move_cmd(arg[1],arg[2]=="true")
    elseif event == "onNewLine" then
        grab_line()
    elseif event == "sysDataSendRequest" then
        capture_move_cmd(arg[1])
        -- check to prevent multiple version checks in a row without user intervention
        if map.update_waiting and map.update_timer then
            map.update_waiting = nil
        -- check to ensure version check cycle is started
        elseif not map.update_waiting and not map.update_timer then
            map.checkVersion()
        end
    elseif event == "sysDownloadDone" and downloading then
        local file = arg[1]
        if string.ends(file,"/map.dat") then
            loadMap(file)
            downloading = false
            map.echo("Map File Loaded.")
        elseif string.ends(file,"/versions.lua") then
            check_version()
        elseif string.ends(file,"/generic_mapper.xml") then
            update_version()
        end
    elseif event == "sysDownloadError" and downloading then
        local file = arg[1]
        if string.ends(file,"/versions.lua") and mudlet.translations.interfacelanguage == "zh_CN" then
            -- update to the current download path for chinese user
            if map.configs.download_path == "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
                map.configs.download_path = "https://gitee.com/mudlet/Mudlet/raw/development/src/mudlet-lua/lua/generic-mapper"
                map.checkVersion()
            end
        end
    elseif event == "sysLoadEvent" or event == "sysInstall" then
        config()
        raiseEvent("mapperScriptLoaded", "generic_mapper")
    elseif event == "mapOpenEvent" then
        if not help_shown and not map.save.prompt_pattern[map.character or ""] then
            map.find_prompt()
            send(map.configs.lang_dirs['look'], true)
            tempTimer(3, function() map.show_help("quick_start"); help_shown = true end)
        end
    elseif event == "mapStop" then
        map.set("mapping", false)
        walking = false
        map.echo("Mapping and speedwalking stopped.")
    elseif event == "sysManualLocationSetEvent" then
      set_room(arg[1])
    elseif event == "sysUninstallPackage" and not map.updatingMapper and arg[1] == "generic_mapper" then
        for _,id in ipairs(map.registeredEvents) do
            killAnonymousEventHandler(id)
        end
    end
end

map.registeredEvents = {
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler"),
registerAnonymousEventHandler("sysDownloadError", "map.eventHandler"),
registerAnonymousEventHandler("sysLoadEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysInstall", "map.eventHandler"),
registerAnonymousEventHandler("sysDataSendRequest", "map.eventHandler"),
registerAnonymousEventHandler("onMoveFail", "map.eventHandler"),
registerAnonymousEventHandler("onVisionFail", "map.eventHandler"),
registerAnonymousEventHandler("onRandomMove", "map.eventHandler"),
registerAnonymousEventHandler("onForcedMove", "map.eventHandler"),
registerAnonymousEventHandler("onNewRoom", "map.eventHandler"),
registerAnonymousEventHandler("onNewLine", "map.eventHandler"),
registerAnonymousEventHandler("mapOpenEvent", "map.eventHandler"),
registerAnonymousEventHandler("mapStop", "map.eventHandler"),
registerAnonymousEventHandler("onPrompt", "map.eventHandler"),
registerAnonymousEventHandler("sysManualLocationSetEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysUninstallPackage", "map.eventHandler")
}


function map.echon(what)
  moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
  decho("&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;")
  cecho(tostring(what))
end

function map.roomexists(num)
  if not num then return false end
  if roomExists then return roomExists(num) end

  local s,m = pcall(getRoomArea, tonumber(num))
  return (s and true or false)
end

-- translates n to north and so forth
-- should incorporate generic_mappers exit_map, stub_map
local tempDir = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    i = "in",
    o = "out",
    ["in"] = "in"
}
local anytolongmap = {}
for s, l in pairs(tempDir) do anytolongmap[l] = l; anytolongmap[s] = l end

function map.anytolong(exit)

  return anytolongmap[exit]
end

function map.anytoshort(exit)
  local t = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    ["in"] = "in",
    out = "out"
  }
  local rt = {}
  for s,l in pairs(t) do
    rt[l] = s; rt[s] = s
  end

  return rt[exit]
end


function map.ranytolong(exit)
  local t = {
    n = "south",
    north = "south",
    e = "west",
    east = "west",
    s = "north",
    south = "north",
    w = "east",
    west = "east",
    ne = "southwest",
    northeast = "southwest",
    se = "northwest",
    southeast = "northwest",
    sw = "northeast",
    southwest = "northeast",
    nw = "southeast",
    northwest = "southeast",
    u = "down",
    up = "down",
    d = "up",
    down = "up",
    i = "out",
    ["in"] = "out",
    o = "in",
    out = "in"
  }

  return t[exit]
end

-- returns nil or the room number relative to this one
function map.relativeroom(from, dir)
  if not map.roomexists(from) then return end

  local exits = getRoomExits(tonumber(from))
  return exits[map.anytolong(dir)]
end

function map.roomFind(query, lines)
  if query:ends('.') then
    query = query:sub(1, -2)
  end
  local defaultLine = 30 -- this could this to a setting instead of a static number
  local result = map.searchRoom(query)
  if lines == 'all' then
    lines = table.size(result)
  end
  lines = (lines ~= '') and tonumber(lines) or defaultLine

  --create a new table (roomsTable) with keys and add areas to the table
  local roomsTable = {}
  for k, v in pairs(result) do
    local a = getRoomArea(k) or "unknown"
    roomsTable[#roomsTable + 1] = {num = k, area = a, name = v}
  end
  --sort roomsTable by area name
  table.sort(
    roomsTable,
    function(a, b)
      return a.area &lt; b.area
    end
  )
  --start displaying info
  if type(result) == "string" or not next(result) then
    cecho("&lt;grey&gt;You have no recollection of any room with that name.")
    return
  end
  cecho("&lt;DarkSlateGrey&gt;You know the following relevant rooms:\n")

  local i = 1
  if not tonumber(select(2, next(result))) then
    cecho(string.format("&lt;white&gt; %-10s%-40s%s\n", "ROOM ID", "ROOM NAME", "ROOM AREA"))
    for _, v in ipairs(roomsTable) do
      if i &gt; lines then
        break
      end
      roomid = tonumber(v.num)
      roomname = v.name
      roomarea = v.area
      cechoLink(
        string.format("&lt;cyan&gt; %-10s", roomid),
        'gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(string.format("&lt;LightSlateGray&gt;%-40s", string.sub(tostring(roomname), 1, 39)))
      cechoLink(
        string.format(
          "&lt;DarkSlateGrey&gt;%s&lt;DarkSlateGrey&gt;\n", getRoomAreaName(getRoomArea(roomid))
        ),
        [[map.echoPath(map.currentRoom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
      i = i + 1
    end
  else
    -- new style
    --- not sure what this new area code is but it doesn't seem to fire
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;cyan&gt;" .. roomid,
        'gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.", getRoomAreaName(getRoomArea(roomid))
        )
      )
      fg("DarkSlateGrey")
      echoLink(
        " &gt; Show path\n",
        [[map.echoPath(map.currentRoom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
    end
  end
  if table.size(result) &lt;= lines then
    cecho(string.format("&lt;DarkSlateGrey&gt;%d rooms found.\n", table.size(result)))
  else
    lastRoomQuery = query
    cechoLink(
      string.format(
        "&lt;DarkSlateGrey&gt;%d of %d rooms shown. Click to see all rooms.\n", lines, table.size(result)
      ),
      'map.roomFind(lastRoomQuery, "all")',
      string.format("Show all %d rooms.", table.size(result)),
      true
    )
  end
end

function map.searchRoom(what)
  local result = searchRoom(what)
  local realResult = {}
  for key, value in pairs(type(result) == "table" and result or {}) do
      -- both ways, because searchRoom can return either id-room name or the reverse
      if type(key) == "string" then
        realResult[key:ends(" (road)") and key:sub(1, -8) or key] = value
      else
        realResult[key] = value:ends(" (road)") and value:sub(1, -8) or value
      end
  end
  result = realResult
  return result
end


-- Lock Area

map.locked = map.locked or {}
map.lastLockSearch = map.lastLockSearch or nil

function map.doLockArea(search)
	local areaList
	if search ~= nil then
		local r = rex.new(string.lower(search))
		map.lastLockSearch = search
		for name, id in pairs(getAreaTable()) do
			if r:match(string.lower(name)) then
				areaList = areaList or {}
				areaList[name] = id
			end
		end
		if areaList == nil then
			map.echo("'" .. search .. "' did not match any known areas!")
			return
		end
	else
		map.lastLockSearch = nil
		areaList = getAreaTable()
	end

	for name, id in pairs(areaList) do
    map.echon(string.format("%-40s %s", name, " "))
--		map.echon(name .. string.rep(" ", 40 - string.len(name)))
		if not map.locked[id] then
			setFgColor(0, 200, 0)
			setUnderline(true)
			echoLink("Lock!", [[map.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', true )]], "Click to lock area '" .. name .. "'", true)
		else
			setFgColor(200, 0, 0)
			setUnderline(true)
			echoLink("Unlock!", [[map.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', false )]], "Click to unlock area '" .. name .. "'", true)
		end
	end

	if not search then
		echo"\n\n" map.echo("Use &lt;green&gt;arealock &lt;area&gt;&lt;white&gt; to filter areas.")
	end
end

function map.lockArea(name, lock, dontreshow)
	local areas = getAreaTable()
	local rooms = getAreaRooms(areas[name]) or {}
    local lockRoom = lockRoom
    local count = 0
	for _, room in pairs(rooms) do
		lockRoom(room, lock)
        count = count + 1
	end

	map.locked[areas[name]] = lock and true or nil
	map.echo(string.format("Area '%s' %slocked! All %s room%s within it.", name, (lock and '' or 'un'), count, (count == 1 and '' or 's')))

	if not dontreshow then map.doLockArea(map.lastLockSearch) end
end


function map.roomLook(input)
  -- we can do a report with a number

  local function handle_number(num)
    -- compile all available data
    if not map.roomexists(num) then
      map.echo(num .. " doesn't seem to exist.")
      return
    end
    local s, areanum = pcall(getRoomArea, num)
    if not s then
      map.echo(areanum);
      return ;
    end
    local exits = getRoomExits(num)
    local name = getRoomName(num)
    local islocked = roomLocked(num)
    local weight = (getRoomWeight(num) and getRoomWeight(num) or "?")
    -- getRoomWeight is buggy in one of the versions, is actually linked to setRoomWeight and thus returns nil
    local exitweights = (getExitWeights and getExitWeights(num) or {})
    local coords = {getRoomCoordinates(num)}
    local specexits = getSpecialExits(num)
    local env = getRoomEnv(num)
    -- generic_mapper doesn't have support for environments like IRE_mapper
    local envname = (map.envidsr and map.envidsr[env]) or "?"
    -- generate a report
    map.echo(
      string.format(
        "Room: %s #: %d area: %s (%d)", name, num, getRoomAreaName(areanum), areanum
      )
    )
    map.echo(
      string.format(
        "Coordinates: x:%d, y:%d, z:%d, locked: %s, weight: %s",
        coords[1],
        coords[2],
        coords[3],
        (islocked and "yes" or "no"),
        tostring(weight)
      )
    )
    map.echo(
      string.format(
        "Environment: %s (%d)%s",
        tostring(envname),
        env,
        (getRoomUserData(num, "indoors") ~= '' and ", indoors" or '')
      )
    )
    map.echo(string.format("Exits (%d):", table.size(exits)))
    for exit, leadsto in pairs(exits) do
      echo(
        string.format(
          "  %s -&gt; %s (%d)%s%s\n",
          exit,
          getRoomName(leadsto),
          leadsto,
          (
            (getRoomArea(leadsto) or "?") == areanum and
            "" or
            " (in " ..
            (getRoomAreaName(getRoomArea(leadsto)) or "?") ..
            ")"
          ),
          (
            (not exitweights[map.anytoshort(exit)] or exitweights[map.anytoshort(exit)] == 0) and
            "" or
            " (weight: " ..
            exitweights[map.anytoshort(exit)] ..
            ")"
          )
        )
      )
    end
    -- display special exits if we got any
    if next(specexits) then
      map.echo(string.format("Special exits (%d):", table.size(specexits)))
      for leadsto, command in pairs(specexits) do
        if type(command) == "string" then
          echo(string.format("  %s -&gt; %s (%d)\n", command, getRoomName(leadsto), leadsto))
        else
          -- new format - exit name, command
          for cmd, locked in pairs(command) do
            if locked == '1' then
              cecho(
                string.format(
                  "&lt;DarkSlateGrey&gt;  %s -&gt; %s (%d) (locked)\n", cmd, getRoomName(leadsto), leadsto
                )
              )
            else
              echo(string.format("  %s -&gt; %s (%d)\n", cmd, getRoomName(leadsto), leadsto))
            end
          end
        end
      end
    end
    local message = "This room has the feature '%s'."
    for _, mapFeature in pairs(map.getRoomMapFeatures(num)) do
      map.echo(string.format(message, mapFeature))
    end
    -- actions we can do. This will be a short menu of sorts for actions
    map.echo("Stuff you can do:")
    echo("  ")
    echo("Clear all labels ")
    setUnderline(true)
    echoLink("(in area)", 'map.clearLabels(' .. areanum .. ')', '', true)
    setUnderline(false)
    echo(" ")
    setUnderline(true)
    echoLink(
      "(whole map)",
      [[
    if not map.clearinglabels then
      map.echo("Are you sure you want to clear all of your labels on this map? If yes, click the link again.")
      map.clearinglabels = true
    else
      map.clearLabels("map")
      map.clearinglabels = nil
    end
    ]],
      '',
      true
    )
    setUnderline(false)
    echo("\n")
  end

  -- see if we can do anything with the name

  local function handle_name(name)
    local result = map.searchRoom(name)
    if type(result) == "string" then
      cecho("&lt;grey&gt;You have no recollection of any room with that name.")
      return
    end
    -- if we got one result, then act on it
    if table.size(result) == 1 then
      if type(next(result)) == "number" then
        handle_number(next(result))
      else
        handle_number(select(2, next(result)))
      end
      return
    end
    -- if not, then ask the user to clarify which one would they want
    map.echo("Which room specifically would you like to look up?")
    if not select(2, next(result)) or not tonumber(select(2, next(result))) then
      for roomid, roomname in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;cyan&gt;" .. roomid,
          'map.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            getRoomAreaName(getRoomArea(roomid))
          )
        )
      end
    else
      for roomname, roomid in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;cyan&gt;" .. roomid,
          'map.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            getRoomAreaName(getRoomArea(roomid))
          )
        )
      end
    end
  end

  if not input then
    if not map.roomexists(map.currentRoom) then
      map.echo(map.currentRoom .. " doesn't seem to be mapped yet.")
      echo("\n")
      map.echo(string.format("version %s.", tostring(map.version)))
      return
    else
      input = map.currentRoom
    end
  end
  if tonumber(input) then
    handle_number(tonumber(input))
  else
    handle_name(input)
  end
  map.echo(string.format("version %s.", tostring(map.version)))
end


local function loadMapFeatures()
  local mapFeaturesString = getMapUserData("mapFeatures")
  local mapFeatures
  if mapFeaturesString and mapFeaturesString ~= "" then
    mapFeatures = yajl.to_value(mapFeaturesString)
  else
    mapFeatures = {}
  end
  return mapFeatures
end

local function saveMapFeatures(mapFeaturesToSave)
  local mapFeaturesString = yajl.to_string(mapFeaturesToSave)
  setMapUserData("mapFeatures", mapFeaturesString)
end

function map.createMapFeature(featureName, roomCharacter)
  if not featureName or featureName == "" then
    map.echo("Can't create an empty map feature.")
    return
  end
  if featureName:find("%d") then
    map.echo("Map feature names must not contain numbers.")
    return
  end
  roomCharacter = roomCharacter or ""
  if type(roomCharacter) ~= "string" then
    map.echo(
      "The new room character must be either a string or nil. " ..
      type(roomCharacter) ..
      " is not allowed."
    )
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    mapFeatures[lowerFeatureName] = roomCharacter
    saveMapFeatures(mapFeatures)
    map.echo(
      "Created map feature '" ..
      featureName ..
      "' with the room character '" ..
      roomCharacter ..
      "'."
    )
  else
    map.echo("A map feature with the name '" .. featureName .. "' already exists.")
    return
  end
  return true
end

function map.listMapFeatures()
  local mapFeatures = loadMapFeatures()
  map.echo("This map has the following features:")
  echo(string.format("    %-25s | %s\n", "feature name", "room character"))
  echo(string.format("    ---------------------------------------------\n"))
--  echo(string.format("    %s\n", string.rep("-", 45)))
  for featureName, roomCharacter in pairs(mapFeatures) do
    echo(string.format("    %-25s | %s\n", featureName, roomCharacter))
  end
  return true
end

function map.roomCreateMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    map.echo("Which feature would you like to create?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    map.echo(
      "A feature with name '" ..
      featureName ..
      "' does not exist. You need to use 'feature create' first."
    )
    return
  end
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentRoom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for creating a map feature on a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature already exists
  if table.contains(map.getRoomMapFeatures(roomId), lowerFeatureName) then
    map.echo("Room '" .. roomId .. "' has already map feature '" .. featureName .. "'.")
    return
  end
  -- create map feature in room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "true")
  map.echo(string.format("Map feature '%s' created in room number '%d'.", featureName, roomId))
  local featureRoomChar = mapFeatures[lowerFeatureName]
  if featureRoomChar ~= "" then
    setRoomChar(roomId, featureRoomChar)
    map.echo("The room now carries the room char '" .. featureRoomChar .. "'.")
  end
  return true
end

function map.roomDeleteMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    map.echo("Which feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentroom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for deleting a map feature from a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature exists
  local roomMapFeatures = map.getRoomMapFeatures(roomId)
  if not table.contains(roomMapFeatures, lowerFeatureName) then
    map.echo("Room '" .. roomId .. "' doesn't have map feature '" .. featureName .. "'.")
    return
  end
  -- delete map feature from room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "")
  map.echo(string.format("Map feature '%s' deleted from room number '%d'.", featureName, roomId))
  -- now update room char if needed.
  -- first update current map features of this room
  roomMapFeatures = map.getRoomMapFeatures(roomId)
  local mapFeatures = loadMapFeatures()
  -- find out if we need to set a new room character
  if getRoomChar(roomId) == mapFeatures[lowerFeatureName] and getRoomChar(roomId) ~= "" then
    local index, otherRoomMapFeature
    -- find another usable room character
    repeat
      index, otherRoomMapFeature = next(roomMapFeatures, index)
    until not otherRoomMapFeature or mapFeatures[otherRoomMapFeature] ~= ""
    if otherRoomMapFeature then
      -- we found a usable room character, now set it
      local newRoomChar = mapFeatures[otherRoomMapFeature]
      setRoomChar(roomId, newRoomChar)
      map.echo("Using '" .. newRoomChar .. "' as new room character.")
    else
      -- we didn't find a usable room character, delete it.
      setRoomChar(roomId, "")
      map.echo("Deleted the current room character.")
    end
  end
  return true
end

function map.getRoomMapFeatures(roomId)
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentRoom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for getting all map features of a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  local result = {}
  local mapFeatures = loadMapFeatures()
  for mapFeature in pairs(mapFeatures) do
    if getRoomUserData(roomId, "feature-" .. mapFeature) == "true" then
      result[#result + 1] = mapFeature
    end
  end
  return result
end

function map.deleteMapFeature(featureName)
  if not featureName or featureName == "" then
    map.echo("Which map feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    map.echo("Map feature '" .. featureName .. "' does not exist.")
    return
  end
  local roomsWithFeature = searchRoomUserData("feature-" .. lowerFeatureName, "true")
  for _, roomId in pairs(roomsWithFeature) do
    local deletionResult = map.roomDeleteMapFeature(lowerFeatureName, roomId)
    if not deletionResult then
      map.echo(
        "Something went wrong deleting the map feature '" ..
        featureName ..
        "' from all rooms. Deletion incomplete."
      )
      return
    end
  end
  mapFeatures[lowerFeatureName] = nil
  saveMapFeatures(mapFeatures)
  map.echo("Deleted map feature '" .. featureName .. "' from map.")
  return true
end

function map.getMapFeatures()
  return loadMapFeatures()
end


function map.echoPath(from, to)
  assert(tonumber(from) and tonumber(to), "map.echoPath: both from and to have to be room IDs")
  if getPath(from, to) then
    map.echo(
      "&lt;white&gt;Directions from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;:"
    )
    map.echo(table.concat(speedWalkDir, ", "))
    return map.speedWalkDir
  else
    map.echo(
      "&lt;white&gt;I can't find a way from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;"
    )
  end
end


function map.listSpecialExits(filter)
  local c = 0
  map.echo("Listing special exits...")
  for area, areaname in pairs(getAreaTableSwap()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            if getRoomArea(exit) ~= area then
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d, in %s)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s -&lt;MediumSlateBlue&gt;&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d, in %s)\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  areaname,
                  cmd,
                  getRoomName(exit),
                  exit,
                  getRoomAreaName(getRoomArea(exit)) or '?'
                )
              )
            else
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s &lt;MediumSlateBlue&gt;-&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; in %s\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  cmd,
                  getRoomName(exit),
                  exit,
                  areaname
                )
              )
            end
            c = c + 1
          end
        end
      end
    end
  end
  map.echo(
    string.format(
      "%d exits listed%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end

function map.delSpecialExits(filter)
  local c = 0
  for area, areaname in pairs(getAreaTableSwap()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            local rid, action
            local originalExits = {}
            local e = getSpecialExits(rooms[i])
            for t, n in pairs(e) do
              rid = tonumber(t)
              for a, l in pairs(n) do
                action = tostring(a)
              end
              if not action:find(filter, 1, true) then
                originalExits[rid] = action
              end
            end
            clearSpecialExits(rooms[i])
            for rid, act in pairs(originalExits) do
              addSpecialExit(rooms[i], tonumber(rid), tostring(act))
            end
            c = c + 1
          end
        end
      end
    end
  end
  map.echo(
    string.format(
      "%d exits deleted%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end


do
local oldsetExit = setExit

local exitmap = {
  n = 1,
  north = 1,
  ne = 2,
  northeast = 2,
  nw = 3,
  northwest = 3,
  e = 4,
  east = 4,
  w = 5,
  west = 5,
  s = 6,
  south = 6,
  se = 7,
  southeast = 7,
  sw = 8,
  southwest = 8,
  u = 9,
  up = 9,
  d = 10,
  down = 10,
  ["in"] = 11,
  out = 12
}

function map.setExit(from, to, direction)
  if type(direction) == "string" and not exitmap[direction] then return false end

  return oldsetExit(from, to, type(direction) == "string" and exitmap[direction] or direction)
end
end


function map.deleteArea(name, exact)
  local id, fname, ma = map.findAreaID(name, exact)
  if id then
    map.doareadelete(id)
  elseif next(ma) then
    map.echo("Which one of these specifically would you like to delete?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(name, [[map.deleteArea("]] .. name .. [[", true)]], "Delete " .. name, true)
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    map.echo("Don't know of that area.")
  end
end

-- the function actually doing area deletion

function map.doareadelete(areaid)
  map.deletingarea = {}
  local t = map.deletingarea
  local rooms = getAreaRooms(areaid)
  t.roomcount = table.size(rooms)
  t.roombatches = {}
  t.currentbatch = 1
  t.areaid = areaid
  t.areaname = getAreaTableSwap()[areaid]
  -- delete the area right away if there's nothing in it
  if t.roomcount == 0 then
    deleteArea(t.areaid)
    map.echo("All done! The area was already gone/empty.")
  end
  local rooms_per_batch = 100
  -- split up rooms into tables of tables, to be deleted in batches so
  -- that our print statements in between get a chance to be processed
  for batch = 1, t.roomcount, 100 do
    t.roombatches[#t.roombatches + 1] = {}
    local onebatch = t.roombatches[#t.roombatches]
    for inbatch = 1, 100 do
      onebatch[#onebatch + 1] = rooms[batch + inbatch]
    end
  end

  function map.deletenextbatch()
    local t = map.deletingarea
    if not t then
      return
    end
    local currentbatch = t.roombatches[t.currentbatchi]
    if currentbatch == nil then
      deleteArea(t.areaid)
      map.echo("All done! Deleted the '" .. t.areaname .. "' area.")
      map.deletingarea = nil
      centerview(map.currentRoom)
      return
    end
    local deleteRoom = deleteRoom
    for i = 1, #currentbatch do
      deleteRoom(currentbatch[i])
    end
    map.echo(
      string.format(
        "Deleted %d batch%s so far, %d left to go - %.2f%% done out of %d needed",
        t.currentbatchi,
        (t.currentbatchi == 1 and '' or 'es'),
        #t.roombatches - t.currentbatchi,
        (100 / #t.roombatches) * t.currentbatchi,
        #t.roombatches
      )
    )
    t.currentbatchi = t.currentbatchi + 1
    tempTimer(0.010, map.deletenextbatch)
  end

  t.currentbatchi = 1
  map.echo("Prepped room batches, starting deletion...")
  tempTimer(0.010, map.deletenextbatch)
end

function map.renameArea(name, exact)
  if not (map.currentroom or getRoomArea(map.currentRoom)) then
    map.echo("Don't know what area are we in at the moment, to rename it.")
  else
    map.echo(
      string.format(
        "Renamed %s to %s (%d).",
        getRoomAreaName(getRoomArea(map.currentRoom)),
        name,
        getRoomArea(map.currentRoom)
      )
    )
    setAreaName(getRoomArea(map.currentRoom), name)			
    centerview(map.currentRoom)
  end
end

function map.roomArea(otherroom, name, exact)
  local id, fname, ma
  if tonumber(name) then
    id = tonumber(name);
    fname = getAreaTableSwap()[id]
  else
    id, fname, ma = map.findAreaID(name, exact)
  end
  if fname == nil then
    map.echo("Area unknown, can't move room.")
    return
  end
  if otherroom ~= "" and not map.roomexists(otherroom) then
    map.echo("Room id " .. otherroom .. " doesn't seem to exist.")
    return
  elseif otherroom == "" and not map.roomexists(map.currentRoom) then
    map.echo("Don't know where we are at the moment.")
    return
  end
  otherroom = otherroom ~= "" and otherroom or map.currentRoom
  if id then
    setRoomArea(otherroom, id)
    map.echo(
      string.format(
        "Moved %s to %s (%d).",
        (getRoomName(otherroom) ~= "" and getRoomName(otherroom) or "''"),
        fname,
        id
      )
    )
    centerview(otherroom)
  elseif next(ma) then
    map.echo("Into which area exactly would you like to move the room?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(
        name, [[map.roomArea('', "]] .. name .. [[", true)]], "Move the room to " .. name, true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    map.echo("Don't know of that area.")
  end
end


function map.clearLabels(areaid)
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= "table" then
      return
    end
    for labelid, _ in pairs(t) do
      deleteMapLabel(areaid, labelid)
    end
  end

  if areaid == "map" then
    for areaid in pairs(getAreaTableSwap()) do
      clearlabels(areaid)
    end
    map.echo("Cleared labels in all of the map.")
    return
  end
  clearlabels(areaid)
  map.echo(string.format("Cleared all labels in '%s'.", map.getAreaTableSwap()[areaid]))
end

function map.roomLabel(input)
  if not createMapLabel then
    map.echo(
      "Your Mudlet doesn't support createMapLabel() yet - please update to 2.0-test3 or better."
    )
    return
  end
  local tk = input:split(" ")
  local room, fg, bg, message = map.currentRoom, "yellow", "red", "Some room label"
  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1))
    -- remove the number, so we're left with the colors or msg
  end
  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end
  -- next: is this a background color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end
  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, " ")
  end
  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    map.echo("We don't know where we are to make a label here.")
    return
  end
  local x, y, z = getRoomCoordinates(room)
  local f1, f2, f3 = unpack(color_table[fg])
  local b1, b2, b3 = unpack(color_table[bg])
  -- finally: do it :)
  local lid = createMapLabel(getRoomArea(room), message, x, y, z, f1, f2, f3, b1, b2, b3)
  map.echo(
    string.format(
      "Created new label #%d '%s' in %s.", lid, message, getRoomAreaName(getRoomArea(room))
    )
  )
end

function map.areaLabels(where, exact)
  if not getMapLabels then
    map.echo(
      "Your Mudlet doesn't support getMapLabels() yet - please update to 2.0-test3 or better."
    )
    return
  end
  if (not where or not type(where) == "string") and not map.currentRoom then
    map.echo("For which area would you like to view labels?")
    return
  end
  if not where then
    exact = true
    where = getRoomAreaName(getRoomArea(map.currentRoom))
  end
  local areaid, msg, multiples = map.findAreaID(where, exact)
  if areaid then
    local t = getMapLabels(areaid)
    if type(t) ~= "table" or not next(t) then
      map.echo(string.format("'%s' doesn't seem to have any labels.", getRoomAreaName(areaid)))
      return
    end
    map.echo(string.format("Area labels for '%s'", getRoomAreaName(areaid)))
    for labelid, labeltext in pairs(t) do
      fg("DimGrey")
      echo(string.format("  %d) %s (", labelid, labeltext))
      fg("orange_red")
      setUnderline(true)
      echoLink(
        'delete',
        string.format(
          'deleteMapLabel(%d, %d); map.echo("Deleted label #' .. labelid .. '")', areaid, labelid
        ),
        "Delete label #" .. labelid .. " from " .. getRoomAreaName(areaid)
      )
      setUnderline(false)
      echo(")\n")
    end
    resetFormat()
  elseif not areaid and #multiples &gt; 0 then
    map.echo("Which area would you like to view exactly?")
    fg("DimGrey")
    for _, areaname in ipairs(multiples) do
      echo("  ");
      setUnderline(true)
      echoLink(
        areaname,
        'map.areaLabels("' .. areaname .. '", true)',
        "Click to view labels in " .. areaname,
        true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
    return
  else
    map.echo(string.format("Don't know of any area named '%s'.", where))
    return
  end
end

</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>autosave</name>
			<packageName>autosave</packageName>
			<script></script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>gui-drop</name>
				<packageName>gui-drop</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>workaround for add</name>
					<packageName></packageName>
					<script>-- Once Geyser.add2 is in this is not needed anymore
local addwrapper = Adjustable.Container.add
function Adjustable.Container:add(window, cons)
  addwrapper(self, window, cons)
  if self.hidden then
    tempTimer(0, function() self:hide() end)
  end
  if self.auto_hidden then
    tempTimer(0, function() self:hide(true) end)
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>createDropManager</name>
					<packageName></packageName>
					<script>GUIDropManager = GUIDropManager or {}
GUIDropImages = GUIDropImages or {}
function GUIDropManager.createDropManager()
    GUIDropManager.script = "--GUIDropManager\n"
    
    local labelscript = [[%s = %s or Geyser.Label:new({name = "%s", x="%s", y="%s", width="%s", height="%s"%s}, %s)
    %s:setStyleSheet("border-image: url(%s);")
    %s.imgName = "%s"
    %s:setDropImg()
    
    ]]
    local containerscript = [[%s = %s or Adjustable.Container:new({name = "%s", x = "%s", y = "%s", width = "%s", height = "%s", lockStyle = "full", padding = 0, noLimit = true%s%s}%s)
    
    ]]
    local function createFname(imgName)
        return [["..getMudletHomeDir().."/GUIDropImages/]].. imgName
    end
    for k,v in pairs(GUIDropImages) do
        
        if v.type == "adjustablecontainer" then
            local container = ""
            local containervar = ""
            local locked = ""
            if v.windowname ~= "main" then
                container = v.containervar or getKeyFrom(v.container, ".container")
                if not container then
                    container = "Geyser.windowList."..v.windowname.."Container.windowList."..v.windowname
                end
                containervar = [[, containervar = "]]..container..[["]]
                v.containervar = container
                container = ", "..container
            end
            if v.locked then
                locked = ", locked = true"
            end
            GUIDropManager.script = GUIDropManager.script..string.format(containerscript, v.name, v.name, v.name, v.x, v.y, v.width, v.height, locked, containervar, container)
        end
        
    end
    
    
    for k,v in pairs(GUIDropImages) do    
        if v.type == "label" then
            v.fname = v.fname or createFname(v.imgName)
            local clickthrough = ""
            if v.clickthrough then
                clickthrough = ", clickthrough = true"
            end
            GUIDropManager.script = GUIDropManager.script..string.format(labelscript, v.name, v.name, v.name, v.x, v.y, v.width, v.height, clickthrough, v.container.container.name, v.name, v.fname, v.name, v.imgName, v.container.container.name)
        end    
    end
    
    if not setScript("GUIDropManager", GUIDropManager.script, 2) then
        display(setScript("GUIDropManager", GUIDropManager.script, 2))
    end
    
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Global Variable Functions</name>
					<packageName></packageName>
					<script>function GUIDropManager.getKeyFrom(value, exclude, depth, table, iteration)
    exclude = exclude or false
    depth = depth or 3
    table = table or _G
    local tempTable = {}
    iteration = iteration or 1
    if iteration &gt; depth then
        return nil, "key not found"
    end
    for k,v in pairs(table) do
        if type(v) == "table" and k ~= "_G" then
            for k1,v1 in pairs(v) do
                tempTable[k.."."..k1] = v1
            end
        end
        if v == value and not string.find(k, exclude) then
            return k
        end
    end
    return GUIDropManager.getKeyFrom(value, exclude, depth, tempTable, iteration + 1)    
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>createDropScript</name>
					<packageName></packageName>
					<script>function GUIDropManager.createDropScript()
    if exists("GUIDropManager", "script") == 0 then
        permGroup("GUIDropManager", "script")
    end
    if exists("GUIDropManager", "script") &lt; 2 then
        permScript("GUIDropManager", "GUIDropManager","--GUIDropManager Script")
        enableScript("GUIDropManager")
        echo("DropScript created!")
    end
    GUIDropManager.createDropManager()
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ImageDrop</name>
					<packageName></packageName>
					<script>function GUIDropManager.ImageDrop(event, fname, suffix, posx, posy, consoleName)
    Adjustable.Container:saveAll()
    local acceptable_suffix = {"png", "jpg", "bmp", "jpeg"}
    
    if not table.contains(acceptable_suffix, suffix) then
        return
    end
    local main_width, main_height = getMainWindowSize()
    local image_width, image_height = getImageSize(fname)
    
    if not image_width then 
        return 
    end
    local image_ratio = image_height / image_width
    if image_width &gt; main_width-50 or image_height &gt; main_height-50 then
        image_height = main_height-50
        image_width = (main_height-50) / image_ratio
    end
    
    posx = math.max(0, posx - (image_width/10))
    posy = math.max(0, posy - (image_height/10))
    local imgName = fname:match("([^%/]+)%..+$")
    
    if not (io.exists(getMudletHomeDir() .. "/GUIDropImages/")) then
        lfs.mkdir(getMudletHomeDir() .. "/GUIDropImages/")
    end
    
    --copy file to my profile location
    local imgLocation = getMudletHomeDir() .. "/GUIDropImages/".. imgName.. ".".. suffix
    local infile = io.open(fname, "rb")
    if not (io.exists(imgLocation)) then 
        local instr = infile:read("*ab")
        infile:close()
        local outfile = io.open(imgLocation, "wb")
        outfile:write(instr)
        outfile:close()
    end
    
    local acontainer
    if consoleName == "main" then
        acontainer = Geyser
    else
        acontainer = Geyser.windowList[consoleName.."Container"].windowList[consoleName]
    end
    --convert filename to be a feasible variablename
    local containername = string.gsub(imgName,"[^_%w]","")
    --if filename is only composed of number convert it
    if not containername:match("%D+") then
        containername = "defaultName"
    end
    
    --Check if image exists already and create new containername by adding +1 to the name
    if GUIDropImages[containername] or _G[containername] then 
        while GUIDropImages[containername] or _G[containername] do
            counter = containername:match("%d+$")
            if counter ~= nil then     
                containername = containername:sub(1,-(string.len(counter)+1))
            end
            counter = counter or 0
            counter = counter + 1
            containername = containername..counter
        end
    end
    
    containername = containername
    local labelname = containername.."Label"
    
    GUIDropImages[containername] = Adjustable.Container:new({name="GUIDropImages."..containername, lockStyle = "full", padding = 0, noLimit = true, autoLoad = false, autoSave = false} , acontainer)
    GUIDropImages[containername]:move(posx, posy)
    GUIDropImages[containername]:resize(image_width, image_height)
    GUIDropImages[containername]:setPercent(true, true)
    GUIDropImages[labelname] = Geyser.Label:new({name = "GUIDropImages."..labelname, x=0, y=0, width="100%", height="100%", clickthrough = true}, GUIDropImages[containername])
    
    GUIDropImages[labelname].fname = [["..getMudletHomeDir().."/GUIDropImages/]].. imgName .. ".".. suffix
    GUIDropImages[labelname].imgName = imgName .. ".".. suffix
    GUIDropManager.createDropScript()
end
registerAnonymousEventHandler("sysDropEvent", "GUIDropManager.ImageDrop")</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>AdjustableContainer Additions</name>
					<packageName></packageName>
					<script>local function deleteImage(s) 
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")] = nil  
    GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")] = nil
    table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, s.name))
    Adjustable.Container.all[s.name] = nil
    if io.exists(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua") then
        os.remove(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua")
    end    
    s:hide()
end

local function convertToLabel(s)
    local labelscript = [[%s = %s or Geyser.Label:new({name = "%s", x="%s", y="%s", width="%s", height="%s"}%s)
    %s:setStyleSheet("border-image: url(%s);")
    ]]
    local container = GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")]
    local labelname = string.gsub(s.name.."Label", "GUIDropImages%.","")
    GUIDropImages[labelname]:changeContainer(container.container)
    GUIDropImages[labelname]:move(container.x, container.y)
    GUIDropImages[labelname]:resize(container.width, container.height)
    
    if exists("GUIDropManager", "script") == 0 then
        permGroup("GUIDropManager", "script")
    end
    
    if exists("GUIDropLabels", "script") == 0 then
        permScript("GUIDropLabels", "GUIDropManager","--GUIDropLabels Script")
        enableScript("GUIDropLabels")
        echo("LabelScript created!")
    end
    
    if container.containervar then
        container.containervar = ","..container.containervar
    else
        container.containervar = ""
    end
    
    local label = GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")]
    labelname = labelname:sub(1,-6)
    labelscript = string.format(labelscript, labelname, labelname, labelname, label.x, label.y, label.width, label.height, container.containervar, labelname, [["..getMudletHomeDir().."/GUIDropImages/]].. label.imgName)
    
    appendScript("GUIDropLabels", labelscript)
    
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")]:hide()
    GUIDropImages[string.gsub(s.name,"GUIDropImages%.","")] = nil
    GUIDropImages[string.gsub(s.name.."Label", "GUIDropImages%.","")] = nil
    table.remove(Adjustable.Container.all_windows, table.index_of(Adjustable.Container.all_windows, s.name))
    Adjustable.Container.all[s.name] = nil
    if io.exists(getMudletHomeDir().."/AdjustableContainer/"..s.name..".lua") then
        os.remove(getMudletHomeDir().."/AdjdustableContainer/"..s.name..".lua")
    end  
end


function Adjustable.Container:setDropImg()
    if self.dropImg then
        return
    end
    
    self.dropImg = true
    self.adjLabelstyle =[[
    QLabel::hover{ background-color: rgba(0,0,0,0%); border: 1px solid grey;}
    QLabel::!hover{ background-color: rgba(0,0,0,0%);}]]
    if not self.locked then
        self.adjLabel:setStyleSheet(self.adjLabelstyle)
    else
        self.adjLabel:setStyleSheet([[border:0;]])
    end
    self:setTitle(" ")
    self.minimizeLabel:raise()
    self.exitLabel:raise()
    
    self:newCustomItem("setAbsolute", function(s) s:setAbsolute(true, true) self:save() end)
    self:newCustomItem("setPercent",  function(s) s:setPercent(true, true)  self:save() end)
    self:newCustomItem("deleteImage", function(s) deleteImage(s) GUIDropManager.createDropManager() Adjustable.Container:saveAll() end)
    self:newCustomItem("convertToLabel",  function(s) convertToLabel(s) GUIDropManager.createDropManager() Adjustable.Container:saveAll() end)
    self:newCustomItem("saveAll",  function(s) Adjustable.Container:saveAll() end)
    self:newCustomItem("loadAll",  function(s) Adjustable.Container:saveAll() end)
    self:newCustomItem("updateScript",  function(s) Adjustable.Container:saveAll() GUIDropManager.createDropManager() end)
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>deleteOldProfiles</name>
				<packageName>deleteOldProfiles</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>deleteOldProfiles script</name>
					<packageName></packageName>
					<script>function deleteOldProfiles(keepdays_arg, delete_folder)
  --[[
  Deletes old profiles/maps/modules in the "current"/"map"/"moduleBackups" folders of the Mudlet home directory.
  The following files are NOT deleted:
  - Files newer than the amount of days specified as an argument to deleteOldProfiles(), or 31 days if not specified.
  - One file for every month before that. Specifically: The first available file of every month prior to this.
  Setting the second argument to true will delete maps instead of profiles. (e.g. deleteOldProfiles(10, true))
  --]]

  -- Ensure correct value is passed for second argument
  assert(type(delete_folder) == "string", "Wrong type for delete_folder; expected string, got " .. type(delete_folder))
  assert(table.contains({"profiles", "maps", "modules"}, delete_folder), "delete_folder must be profiles, maps or modules")

  local keepdays = tonumber(keepdays_arg) or 31
  local profile_table = {}
  local used_last_mod_months = {}
  local slash = (string.char(getMudletHomeDir():byte()) == "/") and "/" or "\\"
  local delnum = 0

  local to_folder = {
    profiles = "current",
    maps = "map",
  }

  local dirpath = delete_folder == "modules"
    and getMudletHomeDir()..slash..".."..slash..".."..slash.."moduleBackups"
    or getMudletHomeDir()..slash..to_folder[delete_folder]

  -- Traverse the profiles folder and create a table of files:
  for filename in lfs.dir(dirpath) do
    if filename~="." and filename~=".." then
      profile_table[#profile_table+1] = {
        name = filename,
        last_mod = lfs.attributes(dirpath..slash..filename, "modification")
      }
    end
  end

  -- Sort the table according to last modification date from old to new:
  table.sort(profile_table, function (a,b) return a.last_mod &lt; b.last_mod end)

  echo(string.format(
    "\nDeleting old %s. Files newer than %d days and one for every month before that will be kept.",
    delete_folder,
    keepdays
  ))

  for i, v in ipairs(profile_table) do
    local days = math.floor(os.difftime(os.time(), v.last_mod) / 86400)
    local last_mod_month = os.date("%Y/%m", v.last_mod)
    if days &gt; keepdays then
      -- For profiles older than X days, check if we already kept a table for this month:
      if not table.contains(used_last_mod_months, last_mod_month) then
        -- If not, do nothing and mark this month as "kept".
        used_last_mod_months[#used_last_mod_months+1] = last_mod_month
      else
        -- Otherwise remove the file:
        local success, errorstring = os.remove(dirpath..slash..v.name)
        if success then
          delnum = delnum + 1
        else
          cecho("\n&lt;red&gt;ERROR: "..errorstring)
        end
      end
    end
  end

  echo(string.format("\nDeletion complete. %d/%d files were removed successfully.", delnum, #profile_table))
end
</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>generic_mapper</name>
				<packageName>generic_mapper</packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Map Script</name>
					<packageName></packageName>
					<script>-- Jor'Mox's Generic Map Script
-- the script self-updates, changing this value will bring an update to all installations
-- make sure versions.lua has the latest version in it
local version = "2.1.7"

    -- look into options for non-standard door usage for speedwalk
    -- come up with aliases to set translations and custom exits, add appropriate help info

mudlet = mudlet or {}
mudlet.mapper_script = true
map = map or {}

map.help = {[[
    &lt;cyan&gt;Generic Map Script&lt;reset&gt;

    This script allows for semi-automatic mapping using the included triggers.
    While different games can have dramatically different ways of displaying
    information, some effort has been put into giving the script a wide range of
    potential patterns to look for, so that it can work with minimal effort in
    many cases. The script locates the room name by searching up from the
    detected exits line until a prompt is found or it runs out of text to
    search, clearing saved text each time a prompt is detected or a movement
    command is sent, with the room name being set to the last line of text
    found. An accurate prompt pattern is necessary for this to work well, and
    sometimes other text can end up being shown between the prompt and the room
    name, or on the same line as the room name, which can be handled by
    providing appropriate patterns telling the script to ignore that text. Below
    is an overview of the included commands and important events that this
    script uses to work. Additional information on each command or event is
    available in individual help files.

    &lt;cyan&gt;Fundamental Commands:&lt;reset&gt;
        These are commands used to get the mapper functional on a basic level.

        &lt;link: show&gt;map show&lt;/link&gt; - Displays or hides a map window.
        &lt;link: quick start&gt;map basics&lt;/link&gt; - Shows a quick-start guide with some basic information to
            help get the script working.
        &lt;link: 1&gt;map help [command name]&lt;/link&gt; - Shows either this help file or the help file for the
            command given.
        &lt;link: find prompt&gt;find prompt&lt;/link&gt; - Instructs the script to look for a prompt that matches
            a known pattern.
        &lt;link: prompt&gt;map prompt &lt;pattern&gt;&lt;/link&gt; - Provides a specific pattern to the script that
            matches your prompt, uses &lt;urllink: https://www.lua.org/pil/20.2.html&gt;Lua string-library patterns&lt;/urllink&gt;.
        &lt;link: ignore&gt;map ignore &lt;pattern&gt;&lt;/link&gt; - Provides a specific pattern for the script to
            ignore, uses &lt;urllink: https://www.lua.org/pil/20.2.html&gt;Lua string-library patterns&lt;/urllink&gt;.
        &lt;link: movemethod&gt;map movemethod &lt;word&gt;&lt;/link&gt; - Adds a movement method for the script to
            look for when mapping.
        &lt;link: debug&gt;map debug&lt;/link&gt; - Toggles on debug mode, in which extra messages are shown with
            the intent of assisting in troubleshooting getting the script setup.
        &lt;link: me&gt;map me&lt;/link&gt; - Locates the user on the map, if possible.
        &lt;link: path&gt;map path &lt;room name&gt; [; area name]&lt;/link&gt; - Finds a walking path to the named
            room, in the named area if specified.
        &lt;link: character&gt;map character &lt;name&gt;&lt;/link&gt; - Sets a given name as the current character for
            the purposes of the script, used for different prompt patterns and
            recall locations.
        &lt;link: recall&gt;map recall&lt;/link&gt; - Sets the current room as the recall location of the
            current character
        &lt;link: config&gt;map config &lt;configuration&gt; [value]&lt;/link&gt; - Sets or toggles the given
            configuration either turning it on or off, if no value is given, or sets it to the given
            value.
        &lt;link: window&gt;map window &lt;configuration&gt; [value]&lt;/link&gt; - Sets the given configuration for the
            map window to the given value.
        &lt;link: translate&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;&lt;/link&gt;
        &lt;link: translate&gt;&lt;translated short direction&gt;&lt;/link&gt; - Sets the provided translations for the
            given english direction word.

    &lt;cyan&gt;Map Information Commands:&lt;reset&gt;
        These commands show detailed information about your current map.

        &lt;link: areas&gt;map areas&lt;/link&gt; - Shows a list of all areas, with links to show a list of
            rooms in the area.
        &lt;link: rooms&gt;map rooms &lt;area name&gt;&lt;/link&gt; - Shows a list of rooms in the named area.
        &lt;link: room_find&gt;room find|rf &lt;room name&gt;&lt;/link&gt; - Searches for a room of a given name.
        &lt;link: room_look&gt;room look|rl [roomID]&lt;/link&gt; - Displays detailed information about a room.
        &lt;link: showpath&gt;showpath &lt;roomID&gt;&lt;/link&gt; - Shows you a path from your current location to the
            roomID.
        &lt;link: showpath&gt;showpath &lt;fromID&gt; &lt;toID&gt;&lt;/link&gt; - Shows you a path from a given location to
            another location.
        &lt;link: spe_list&gt;spe list [filter]&lt;/link&gt; - Display a list of all known special exits.
        &lt;link: feature_list&gt;feature list&lt;/link&gt; - Lists all map features created via feature create and
            the associated room characters.

    &lt;cyan&gt;Map Creation Commands:&lt;reset&gt;
        These are commands used in the process of actually creating a map.

        &lt;link: start mapping&gt;start mapping [area name]&lt;/link&gt; - Starts adding content to the map, using
            either the area of the room the user is currently in or the area
            name provided.
        &lt;link: stop mapping&gt;stop mapping&lt;/link&gt; - Stops adding content to the map.
        &lt;link: area_add&gt;area add &lt;area name&gt;&lt;/link&gt; - Creates a new area.
        &lt;link: area_delete&gt;area delete &lt;area name&gt;&lt;/link&gt; - Deletes a given area and all rooms within.
        &lt;link: area_cancel&gt;cancel area deletion&lt;/link&gt; - Pauses deletion of an area.  This will NOT
            restore delete rooms.
        &lt;link: area_rename&gt;area rename &lt;new area name&gt;&lt;/link&gt; - Renames the current area you're in.
        &lt;link: set area&gt;set area &lt;area name&gt;&lt;/link&gt; - Moves the current room to the named area.
        &lt;link: mode&gt;map mode &lt;lazy, simple, normal or complex&gt;&lt;/link&gt; - Sets the mapping mode, which
            defines how new rooms are added to the map.
        &lt;link: add door&gt;add door &lt;direction&gt; [door status] [one way]&lt;/link&gt; - Creates a door in
            the given direction, with the given status(default closed), in both
            directions, unless a one-direction door is specified.
        &lt;link: add portal&gt;add portal [-f] &lt;entry command&gt;&lt;/link&gt; - Creates a portal in the current room,
            using the given command for entry.
        &lt;link: shift&gt;shift &lt;direction&gt;&lt;/link&gt; - Moves the current room on the map in the given direction.
        &lt;link: merge rooms&gt;merge rooms&lt;/link&gt; - Combines overlapping rooms that have the same name into
            a single room.
        &lt;link: clear moves&gt;clear moves&lt;/link&gt; - Clears the list of movement commands maintained by the
            script.
        &lt;link: set exit&gt;set exit &lt;direction&gt; &lt;roomID&gt;&lt;/link&gt; - Creates a one-way exit in the given
            direction to the room with the specified roomID, can also be used with portals.
        &lt;link: arealock&gt;arealock [area name]&lt;/link&gt; - Displays a list of areas you can lock/unlock.
        &lt;link: room_coords&gt;room coords|rc [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;/link&gt; - Move a room to new map coordinates.
        &lt;link: room_delete&gt;room delete|rld &lt;direction|roomID&gt;&lt;/link&gt; - Delete a room given a direction or roomID.
        &lt;link: room_weight&gt;rw [direction|roomID] &lt;weight&gt;&lt;/link&gt; - Set a room weight given a direction or roomID.
        &lt;link: room_weight_exit&gt;rwe [roomID] &lt;weight&gt; &lt;exit&gt;&lt;/link&gt; - Set the weight of a given exit in
            the current room, or optional roomID.
        &lt;link: room_link&gt;room link|rlk &lt;direction&gt; [one]&lt;/link&gt; - Create a link to a room given a direction.
            Optional 'one' to create a one-way link.
        &lt;link: room_unlink&gt;room unlink|urlk &lt;direction&gt;&lt;/link&gt; - Delete a link in the specified direction.
        &lt;link: room_door&gt;rd [roomID] &lt;direction&gt; &lt;open|closed|locked|clear&gt;&lt;/link&gt; - Create or delete a door
            from the current room, or optional location.
        &lt;link: room_character&gt;rcc &lt;character&gt; [roomID]&lt;/link&gt; - Assign a single character, letter or
            number to the current room, or optional location.
        &lt;link: exit_special&gt;exit special|spe &lt;direction|roomID&gt; &lt;command&gt;&lt;/link&gt; - Add a special exit
            to a room.
        &lt;link: spev&gt;spev &lt;fromID&gt; &lt;toID&gt; &lt;command&gt;&lt;/link&gt; - Add a special exit to two remote rooms.
        &lt;link: spe_clear&gt;exit special clear|spe clear &lt;direction|roomID&gt;&lt;/link&gt; - Delete a special exit.
        &lt;link: room_area&gt;room area [v&lt;roomID&gt;] &lt;area name&gt;&lt;/link&gt; - Moves a room to the given area.
        &lt;link: room_label&gt;room label [roomID] [fgColor] [bgColor] &lt;message&gt;&lt;/link&gt; - Adds a label to a room.
        &lt;link: area_labels&gt;area labels &lt;area name&gt;&lt;/link&gt; - Display all labels in a given area with an
            option to delete.
        &lt;link: feature_create&gt;feature create &lt;feature&gt; [char &lt;room character&gt;]&lt;/link&gt; - Create a new
            global map feature.
        &lt;link: room_feature_create&gt;room create feature|rcf [v&lt;room id&gt;] &lt;feature&gt;&lt;/link&gt; - Adds a map
            feature to the current room, or optional location.
        &lt;link: room_feature_delete&gt;room delete feature|rdf [v&lt;room id&gt;] &lt;feature&gt;&lt;/link&gt; - Removes a
            map feature from the current room or optional location.
        &lt;link: feature_delete&gt;feature delete &lt;feature&gt;&lt;/link&gt; - Deletes a global map feature and
            removes it from all rooms.

    &lt;cyan&gt;Sharing and Backup Commands:&lt;reset&gt;

        &lt;link: save&gt;map save&lt;/link&gt; - Creates a backup of the map.
        &lt;link: load&gt;map load &lt;remote address&gt;&lt;/link&gt; - Loads a map backup, or a map file from a
            remote address.
        &lt;link: export&gt;map export &lt;area name&gt;&lt;/link&gt; - Creates a file from the named area that can
            be shared.
        &lt;link: import&gt;map import &lt;area name&gt;&lt;/link&gt; - Loads an area from a file.

    &lt;cyan&gt;Mapping Events:&lt;reset&gt;
        These events are used by triggers to direct the script's behavior.

        &lt;link: onNewRoom&gt;onNewRoom&lt;/link&gt; - Signals that a room has been detected, optional exits
            argument.
        &lt;link: onMoveFail&gt;onMoveFail&lt;/link&gt; - Signals that an attempted move failed.
        &lt;link: onForcedMove&gt;onForcedMove&lt;/link&gt; - Signals that the character moved without a command
            being entered, required direction argument.
        &lt;link: onRandomMove&gt;onRandomMove&lt;/link&gt; - Signals that the character moved in an unknown
            direction without a command being entered.
        &lt;link: onVisionFail&gt;onVisionFail&lt;/link&gt; - Signals that the character moved but some or all of
            the room information was not able to be gathered.

    &lt;cyan&gt;Key Variables:&lt;reset&gt;
        These variables are used by the script to keep track of important
            information.

        &lt;yellow&gt;map.prompt.room&lt;reset&gt; - Can be set to specify the room name.
        &lt;yellow&gt;map.prompt.exits&lt;reset&gt; - Can be set to specify the room exits.
        &lt;yellow&gt;map.prompt.hash&lt;reset&gt; - Can be set to specify the room hash.
            Notice: if you set this, mapper will only find room by
            getRoomIDbyHash(hash)
        &lt;yellow&gt;map.character&lt;reset&gt; - Contains the current character name.
        &lt;yellow&gt;map.save.recall&lt;reset&gt; - Contains a table of recall roomIDs for all
            characters.
        &lt;yellow&gt;map.save.prompt_pattern&lt;reset&gt; - Contains a table of prompt patterns for all
            characters.
        &lt;yellow&gt;map.save.ignore_patterns&lt;reset&gt; - Contains a table of patterns of text the
            script ignores.
        &lt;yellow&gt;map.configs&lt;reset&gt; - Contains a number of different options that can be set
            to modify script behavior.
        &lt;yellow&gt;map.currentRoom&lt;reset&gt; - Contains the roomID of the room your character is
            in, according to the script.
        &lt;yellow&gt;map.currentName&lt;reset&gt; - Contains the name of the room your character is in,
            according to the script.
        &lt;yellow&gt;map.currentExits&lt;reset&gt; - Contains a table of the exits of the room your
            character is in, according to the script.
        &lt;yellow&gt;map.currentArea&lt;reset&gt; - Contains the areaID of the area your character is
            in, according to the script.
]]}
map.help.save = [[
    &lt;cyan&gt;Map Save&lt;reset&gt;
        syntax: &lt;yellow&gt;map save&lt;reset&gt;

        This command creates a copy of the current map and stores it in the
        profile folder as map.dat. This can be useful for creating a backup
        before adding new content, in case of problems, and as a way to share an
        entire map at once.
]]
map.help.load = [[
    &lt;cyan&gt;Map Load&lt;reset&gt;
        syntax: &lt;yellow&gt;map load &lt;optional download address&gt;&lt;reset&gt;

        This command replaces the current map with the map stored as map.dat in
        the profile folder. Alternatively, if a download address is provided, a
        map is downloaded from that location and loaded to replace the current
        map. If no filename is given with the download address, the script tries
        to download map.dat. If a filename is given it MUST end with .dat.
]]
map.help.show = [[
    &lt;cyan&gt;Map Show&lt;reset&gt;
        syntax: &lt;yellow&gt;map show&lt;reset&gt;

        This command shows a map window, as specified by the window configs set
        via the &lt;link: window&gt;map window command&lt;/link&gt;. It isn't necessary to use this method to
        show a map window to use this script, any map window will work.
]]
map.help.export = [[
    &lt;cyan&gt;Map Export&lt;reset&gt;
        syntax: &lt;yellow&gt;map export &lt;area name&gt;&lt;reset&gt;

        This command creates a file containing all the informatino about the
        named area and stores it in the profile folder, with a file name based
        on the area name. This file can then be imported, allowing for easy
        sharing of single map areas. The file name will be the name of the area
        in all lower case, with spaces replaced with underscores, and a .dat
        file extension.
]]
map.help.import = [[
    &lt;cyan&gt;Map Import&lt;reset&gt;
        syntax: &lt;yellow&gt;map import &lt;area name&gt;&lt;reset&gt;

        This command imports a file from the profile folder with a name matching
        the name of the file, and uses it to create an area on the map. The area
        name used can be capitalized or not, and may have either spaces or
        underscores between words. The actual area name is stored within the
        file, and is not set by the area name used in this command.
]]
map.help.start_mapping = [[
    &lt;cyan&gt;Start Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;start mapping [area name]&lt;reset&gt;

        This command instructs the script to add new content to the map when it
        is seen. When first used, an area name is mandatory, so that an area is
        created for new rooms to be placed in. If used with an area name while
        the map shows the character within a room on the map, that room will be
        moved to be in the named area, if it is not already in it. If used
        without an area name, the room is not moved, and mapping begins in the
        area the character is currently located in.
]]
map.help.stop_mapping = [[
    &lt;cyan&gt;Stop Mapping&lt;reset&gt;
        syntax: &lt;yellow&gt;stop mapping&lt;reset&gt;

        This command instructs the script to stop adding new content until
        mapping is resumed at a later time. The map will continue to perform
        other functions.
]]
map.help.find_prompt = [[
    &lt;cyan&gt;Find Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;find prompt&lt;reset&gt;

        This command instructs the script to begin searching newly arriving text
        for something that matches one of its known prompt patterns. If one is
        found, that pattern will be set as the current prompt pattern. This
        should typically be the first command used to set up this script with a
        new profile. If your prompt appears after using this command, but there
        is no message saying that the prompt has been found, it will be
        necessary to use the map prompt command to manually set a pattern.
]]
map.help.prompt = [[
    &lt;cyan&gt;Map Prompt&lt;reset&gt;
        syntax: &lt;yellow&gt;map prompt &lt;prompt pattern&gt;&lt;reset&gt;

        This command manually sets a prompt pattern for the script to use.
        Because of the way this script works, the prompt pattern should match
        the entire prompt, so that if the text matching the pattern were
        removed, the line with the prompt would be blank. The patterns must be
        of the type used by the Lua string library. If you are unsure about what
        pattern to use, seek assistance on the Mudlet Forums or the Mudlet
        Discord channel.
]]
map.help.debug = [[
    &lt;cyan&gt;Map Debug&lt;reset&gt;
        syntax: &lt;yellow&gt;map debug&lt;reset&gt;

        This command toggles the map script's debug mode on or off when it is
        used. Debug mode provides some extra messages to help with setting up
        the script and identifying problems to help with troubleshooting. If you
        are getting assistance with setting up this script, using debug mode may
        make the process faster and easier.
]]
map.help.ignore = [[
    &lt;cyan&gt;Map Ignore&lt;reset&gt;
        syntax: &lt;yellow&gt;map ignore &lt;ignore pattern&gt;&lt;reset&gt;

        This command adds the given pattern to a list the script maintains to
        help it locate the room name. Any text that might appear after a command
        is sent to move and before the room name appears, or after the prompt
        and before the room name if several movement commands are sent at once,
        should have an ignore pattern added for it.

        If the given pattern is already in the list of ignore patterns, that
        pattern will be removed from the list.

        Example: &lt;yellow&gt;map ignore ^You are hungry%.$&lt;reset&gt; - match exactly one line
                 &lt;yellow&gt;map ignore ^The clock strikes %d+%.$&lt;reset&gt; - match a number
                 &lt;yellow&gt;map ignore ^You walk %a+%.$&lt;reset&gt; - match a word, e.g. east
]]
map.help.movemethod = [[
    &lt;cyan&gt;Move Method&lt;reset&gt;
        syntax: &lt;yellow&gt;map movemethod &lt;movement word&gt;&lt;reset&gt;

        This command will add a movement method for the script to look for
        when moving between rooms. If your game has methods such as "walk north",
        "swim south" or similar, add "walk" or "swim" as necessary. For single
        room movement only.

        If the given method is already in the list of movement methods, that
        method will be removed from the list.
]]
map.help.areas = [[
    &lt;cyan&gt;Map Areas&lt;reset&gt;
        syntax: &lt;yellow&gt;map areas&lt;reset&gt;

        This command displays a linked list of all areas in the map. When
        clicked, the rooms in the selected area will be displayed, as if the
        'map rooms' command had been used with that area as an argument.
]]
map.help.rooms = [[
    &lt;cyan&gt;Map Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;map rooms &lt;area name&gt;&lt;reset&gt;

        This command shows a list of all rooms in the area, with the roomID and
        the room name, as well as a count of how many rooms are in the area
        total. Note that the area name argument is not case sensitive.
]]
map.help.set_area = [[
    &lt;cyan&gt;Set Area&lt;reset&gt;
        syntax: &lt;yellow&gt;set area &lt;area name&gt;&lt;reset&gt;

        This command move the current room into the named area, creating the
        area if needed.
]]
map.help.mode = [[
    &lt;cyan&gt;Map Mode&lt;reset&gt;
        syntax: &lt;yellow&gt;map mode &lt;lazy, simple, normal, or complex&gt;&lt;reset&gt;

        This command changes the current mapping mode, which determines what
        happens when new rooms are added to the map.

        In lazy mode, connecting exits aren't checked and a room is only added if
        there isn't an adjacent room with the same name.

        In simple mode, if an adjacent room has an exit stub pointing toward the
        newly created room, and the new room has an exit in that direction,
        those stubs are connected in both directions.

        In normal mode (default), the newly created room is connected to the room you left
        from, so long as it has an exit leading in that direction.

        In complex mode, none of the exits of the newly connected room are
        connected automatically when it is created.
]]
map.help.add_door = [[
    &lt;cyan&gt;Add Door&lt;reset&gt;
        syntax: &lt;yellow&gt;add door &lt;direction&gt; [none|open|closed|locked] [yes|no]&lt;reset&gt;

        This command places a door on the exit in the given direction, or
        removes it if "none" is given as the second argument. The door status is
        set as given by the second argument, default "closed". The third
        argument determines if the door is a one-way door, default "no".
]]
map.help.add_portal = [[
    &lt;cyan&gt;Add Portal&lt;reset&gt;
        syntax: &lt;yellow&gt;add portal [-f] &lt;entry command&gt;&lt;reset&gt;

        This command creates a special exit in the current room that is entered
        by using the given entry command. The given entry command is then sent,
        moving to the destination room. If the destination room matches an
        existing room, the special exit will link to that room, and if not a new
        room will be created. If the optional "-f" argument is given, a new room
        will be created for the destination regardless of if an existing room
        matches the room seen when arriving at the destination.
]]
map.help.shift = [[
    &lt;cyan&gt;Shift&lt;reset&gt;
        syntax: &lt;yellow&gt;shift &lt;direction&gt;&lt;reset&gt;

        This command moves the current room one step in the direction given, on
        the map.
]]
map.help.merge_rooms = [[
    &lt;cyan&gt;Merge Rooms&lt;reset&gt;
        syntax: &lt;yellow&gt;merge rooms&lt;reset&gt;

        This command combines all rooms that share the same coordinates and the
        same room name into a single room, with all of the exits preserved and
        combined.
]]
map.help.clear_moves = [[
    &lt;cyan&gt;Clear Moves&lt;reset&gt;
        syntax: &lt;yellow&gt;clear moves&lt;reset&gt;

        This command clears the script's queue of movement commands, and is
        intended to be used after you attempt to move while mapping but the
        movement is prevented in some way that is not caught and handled by a
        trigger that raises the onMoveFail event.
]]
map.help.set_exit = [[
    &lt;cyan&gt;Set Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;set exit &lt;direction&gt; &lt;destination roomID&gt;&lt;reset&gt;

        This command sets the exit in the current room in the given direction to
        connect to the target room, as specified by the roomID. This is a
        one-way connection.
]]
map.help.onnewroom = [[
    &lt;cyan&gt;onNewRoom Event&lt;reset&gt;

        This event is raised to inform the script that a room has been detected.
        When raised, a string containing the exits from the detected room should
        be passed as a second argument to the raiseEvent function, unless those
        exits have previously been stored in map.prompt.exits.
]]
map.help.onmovefail = [[
    &lt;cyan&gt;onMoveFail Event&lt;reset&gt;

        This event is raised to inform the script that a move was attempted but
        the character was unable to move in the given direction, causing that
        movement command to be removed from the script's movement queue.
]]
map.help.onforcedmove = [[
    &lt;cyan&gt;onForcedMove Event&lt;reset&gt;

        This event is raised to inform the script that the character moved in a
        specified direction without a command being entered. When raised, a
        string containing the movement direction must be passed as a second
        argument to the raiseEvent function.

        The most common reason for this event to be raised is when a character
        is following someone else.
]]
map.help.onrandommove = [[
    &lt;cyan&gt;onRandomMove Event&lt;reset&gt;

        This event is raised to inform the script that the character has moved
        in an unknown direction. The script will compare the next room seen with
        rooms that are adjacent to the current room to try to determine the best
        match for where the character has gone.

        In some situations, multiple options are equally viable, so mistakes may
        result. The script will automatically keep verifying positioning with
        each step, and automatically correct the shown location on the map when
        possible.
]]
map.help.onvisionfail = [[
    &lt;cyan&gt;onVisionFail Event&lt;reset&gt;

        This event is raised to inform the script that some or all of the room
        information was not able to be gathered, but the character still
        successfully moved between rooms in the intended direction.
]]
map.help.onprompt = [[
    &lt;cyan&gt;onPrompt Event&lt;reset&gt;

        This event can be raised when using a non-conventional setup to trigger
        waiting messages from the script to be displayed. Additionally, if
        map.prompt.exits exists and isn't simply an empty string, raising this
        event will cause the onNewRoom event to be raised as well. This
        functionality is intended to allow people who have used the older
        version of this script to use this script instead, without having to
        modify the triggers they created for it.
]]
map.help.me = [[
    &lt;cyan&gt;Map Me&lt;reset&gt;
        syntax: &lt;yellow&gt;map me&lt;reset&gt;

        This command forces the script to look at the currently captured room
        name and exits, and search for a potentially matching room, moving the
        map if applicable. Note that this command is generally never needed, as
        the script performs a similar search any time the room name and exits
        don't match expectations.
]]
map.help.path = [[
    &lt;cyan&gt;Map Path&lt;reset&gt;
        syntax: &lt;yellow&gt;map path &lt;room name&gt; [; area name]&lt;reset&gt;

        This command tries to find a walking path from the current room to the
        named room. If an area name is given, only rooms within that area that
        is given are checked. Neither the room name nor the area name are case
        sensitive, but otherwise an exact match is required. Note that a
        semicolon is required between the room name and area name, if an area
        name is given, but spaces before or after the semicolon are optional.

        Example: &lt;yellow&gt;map path main street ; newbie town&lt;reset&gt;
]]
map.help.character = [[
    &lt;cyan&gt;Map Character&lt;reset&gt;
        syntax: &lt;yellow&gt;map character &lt;name&gt;&lt;reset&gt;

        This command tells the script what character is currently being used.
        Setting a character is optional, but recall locations and prompt
        patterns are stored by character name, so using this command allows for
        easy switching between different setups. The name given is stored in
        map.character. The name is a case sensitive exact match. The value of
        map.character is not saved between sessions, so this must be set again
        if needed each time the profile is opened.
]]
map.help.recall = [[
    &lt;cyan&gt;Map Recall&lt;reset&gt;
        syntax: &lt;yellow&gt;map recall&lt;reset&gt;

        This command tells the script that the current room is the recall point
        for the current character, as stored in map.character. This information
        is stored in map.save.recall[map.character], and is remembered between
        sessions.
]]
map.help.config = [[
    &lt;cyan&gt;Map Config&lt;reset&gt;
        syntax: &lt;yellow&gt;map config &lt;setting&gt; &lt;optional value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below.
        If no value is given, and the setting is either 'on' or 'off', then the
        value is switched. When naming a setting, spaces can be used in place of
        underscores. Details of what options are available and what each one
        does are provided.

        &lt;yellow&gt;speedwalk_delay&lt;reset&gt; - When using the speedwalk function of the script,
            this is the amount of time the script waits after either sending
            a command or, if speedwalk_wait is set, after arriving in a new
            room, before the next command is sent. This may be any number 0
            or higher.

        &lt;yellow&gt;speedwalk_wait&lt;reset&gt; - When using the speedwalk function of the script,
            this indicates if the script waits for your character to move
            into a new room before sending the next command. This may be true
            or false.

        &lt;yellow&gt;speedwalk_random&lt;reset&gt; - When using the speedwalk function of the script
            with a speedwalk_delay value, introduces a randomness to the wait
            time by adding some amount up to the speedwalk_delay value. This
            may be true or false.

        &lt;yellow&gt;stretch_map&lt;reset&gt; - When adding a new room that would overlap an existing
            room, if this is set the map will stretch out to prevent the
            overlap, with all rooms further in the direction moved getting
            pushed one further in that direction. This may be true or false.

        &lt;yellow&gt;max_search_distance&lt;reset&gt; - When mapping, this is the maximum number of
            rooms that the script will search in the movement direction for a
            matching room before deciding to create a new room. This may be
            false, or any positive whole number. This can also be set to 0,
            which is the same as setting it to false.

        &lt;yellow&gt;search_on_look&lt;reset&gt; - When this is set, using the "look" command causes
            the map to verify your position using the room name and exits
            seen following using the command. This may be true or false.

        &lt;yellow&gt;clear_lines_on_send&lt;reset&gt; - When this is set, any time a command is sent,
            any lines stored from the game used to search for the room name
            are cleared. This may be true or false.

        &lt;yellow&gt;mode&lt;reset&gt; - This is the default mapping mode on startup, and defines how
            new rooms are added to the map. May be "lazy", "simple",
            "normal" or "complex".

        &lt;yellow&gt;download_path&lt;reset&gt; - This is the path that updates are downloaded from.
            This may be any web address where the versions.lua and
            generic_mapper.xml files can be downloaded from.

        &lt;yellow&gt;prompt_test_patterns&lt;reset&gt; - This is a table of default patterns checked
            when using the "find prompt" command. The patterns in this table
            should start with a '^', and be written to be used with the Lua
            string library. Most importantly, '%' is used as the escape
            character instead of '\' as in trigger regex patterns.

        &lt;yellow&gt;custom_exits&lt;reset&gt; - This is a table of custom exit directions and their
            relevant extra pieces of info. Each entry should have the short
            direction as the keyword for a table containing first the long
            direction, then the long direction of the reverse of this
            direction, and then the x, y, and z change in map position
            corresponding to the movement. As an example: us = {'upsouth',
            'downnorth', 0, -1, 1}

        &lt;yellow&gt;custom_name_search&lt;reset&gt; - When this is set, instead of running the default
            function name_search, a user-defined function called
            'mudlet.custom_name_search' is used instead. This may be true or false.

        &lt;yellow&gt;use_translation&lt;reset&gt; - When this is set, the lang_dirs table is used to
            translate movement and status commands in some other language
            into the English used by the script. This may be true or false.

        &lt;yellow&gt;debug&lt;reset&gt; - When this is set, the script will start in debug mode. This
            may be true or false.
]]
map.help.window = [[
    &lt;yellow&gt;Map Window&lt;reset&gt;
        syntax: &lt;yellow&gt;map window &lt;setting&gt; &lt;value&gt;&lt;reset&gt;

        This command changes any of the available configurations listed below,
        which determine the appearance and positioning of the map window when
        the 'map show' command is used. Details of what options are available
        and what each one does are provided.

        &lt;yellow&gt;x&lt;reset&gt; - This is the x position of the map window, and should be a
            positive number of pixels or a percentage of the screen width.

        &lt;yellow&gt;y&lt;reset&gt; - This is the y position of the map window, and should be a
            positive number of pixels or a percentage of the screen height.

        &lt;yellow&gt;w&lt;reset&gt; - This is the width of the map window, and should be a positive
            number of pixels or a percentage of the screen width.

        &lt;yellow&gt;h&lt;reset&gt; - This is the height of the map window, and should be a positive
            number of pixels or a percentage of the screen height.

        &lt;yellow&gt;origin&lt;reset&gt; - This is the corner from which the window position is
            measured, and may be 'topright', 'topleft', 'bottomright', or
            'bottomleft'.

        &lt;yellow&gt;shown&lt;reset&gt; - This determines if the map window is shown immediately upon
            connecting to the game. This may be true or false. If you intend
            to have some other script control the map window, this should be
            set to false.
]]
map.help.translate = [[
    &lt;yellow&gt;Map Translate&lt;reset&gt;
        syntax: &lt;yellow&gt;map translate &lt;english direction&gt; &lt;translated long direction&gt;
            &lt;translated short direction&gt;&lt;reset&gt;

        This command sets direction translations for the script to use, either
        for commands entered to move around, or listed exits the game shows when
        you enter a room. Available directions: north, south, east, west,
        northwest, northeast, southwest, southeast, up, down, in, and out.
        Also you can customize special commands sent to mud like 'look'.
]]
map.help.quick_start = [[
    &lt;link: quick_start&gt;map basics&lt;/link&gt; (quick start guide)
    ----------------------------------------

    Mudlet Mapper works in tandem with a script, and this generic mapper script needs
    to know 2 things to work:
      - &lt;dim_grey&gt;room name&lt;reset&gt; $ROOM_NAME_STATUS ($ROOM_NAME)
      - &lt;dim_grey&gt;exits&lt;reset&gt;     $ROOM_EXITS_STATUS ($ROOM_EXITS)

    1. &lt;link: start mapping&gt;start mapping &lt;optional area name&gt;&lt;/link&gt;
       If both room name and exits are good, you can start mapping! Give it the
       area name you're currently in, usually optional but required for the first one.
    2. &lt;link: find prompt&gt;find prompt&lt;/link&gt;
       Room name or exits aren't recognised? Try this command then. It will make
       the script start looking for a prompt using several standard prompt
       patterns. If a prompt is found, you will be notified, if not, you will
       need to set a prompt pattern yourself using &lt;link: prompt&gt;map prompt&lt;/link&gt;.
       Reach out to the &lt;urllink: https://discord.gg/kuYvMQ9&gt;Mudlet community&lt;/urllink&gt; for help, we'd be happy to help
       you figure it out!
    3. &lt;link: debug&gt;map debug&lt;/link&gt;
       This toggles debug mode. When on, messages will be displayed showing what
       information is captured and a few additional error messages that can help
       with getting the script fully compatible with your game.
    4. &lt;link: 1&gt;map help&lt;/link&gt;
       This will bring up a more detailed help file, starting with the available
       help topics.
]]
map.help.room_find = [[
    &lt;cyan&gt;Room Find&lt;reset&gt;
        syntax: &lt;yellow&gt;room find &lt;room name&gt;&lt;reset&gt;
                &lt;yellow&gt;rf &lt;room name&gt;&lt;reset&gt;

        This command will search all rooms and return a list of matches.
]]
map.help.room_look = [[
    &lt;cyan&gt;Room Look&lt;reset&gt;
        syntax: &lt;yellow&gt;room look [roomID]&lt;reset&gt;
                &lt;yellow&gt;rl [roomID]&lt;reset&gt;

        This command will display detailed information about the current room.
        Optionally a roomID can be provided.
]]
map.help.showpath = [[
    &lt;cyan&gt;Showpath&lt;reset&gt;
        syntax: &lt;yellow&gt;showpath &lt;roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;showpath &lt;fromID&gt; &lt;toID&gt;&lt;reset&gt;

        This command displays a path from your current room to the roomID specified.
        If two roomID's are specifed it will display a path from a remote room to another room.
]]
map.help.spe_list = [[
    &lt;cyan&gt;Special Exits List&lt;reset&gt;
        syntax: &lt;yellow&gt;spe list [filter]&lt;reset&gt;

        This command displays a list of all known special exits.  You can alternatively provide an
        optional filter to return a list containing those words.

        Example: &lt;yellow&gt;spe list worm warp&lt;reset&gt;
]]
map.help.feature_list = [[
    &lt;cyan&gt;Feature List&lt;reset&gt;
        syntax: &lt;yellow&gt;feature list&lt;reset&gt;

        This command displays a list of all map features created via feature create and the associated room characters.
]]
map.help.area_add = [[
    &lt;cyan&gt;Area Add&lt;reset&gt;
        syntax: &lt;yellow&gt;area add &lt;area name&gt;&lt;reset&gt;

        This command will create a new area and automatically give it an ID.

        Example: &lt;yellow&gt;area add My City&lt;reset&gt; - create a new area called My City
]]
map.help.area_delete = [[
    &lt;cyan&gt;Area Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;area delete &lt;area name&gt;&lt;reset&gt;

        This command will delete the given area. If the area is really big
        (thousands of rooms), deleting it at once would take a really long
        while and freeze your Mudlet while doing so. To combat the unpleasant
        experience, the script breaks up area deletion into batches of rooms
        (100 by default). While this still heavily impacts Mudlets performance,
        it allows you to see a progress meter of how far it has gotten and gives
        you an ability to pause it at any time by doing 'cancel area deletion'.

        Example: &lt;yellow&gt;area delete My City&lt;reset&gt; - delete an area called My City
]]
map.help.area_cancel = [[
    &lt;cyan&gt;Cancel Area Deletion&lt;reset&gt;
        syntax: &lt;yellow&gt;cancel area deletion&lt;reset&gt;

        This comand will stop an area deletion that has started. This will NOT
        restore deleted rooms - it merely pauses the process, so you can resume
        it with 'area delete' later on. You can type this in while Mudlet is
        deleting an area - it'll take a short while for letters to show up, but
        they will eventually.
]]
map.help.area_rename = [[
    &lt;cyan&gt;Area Rename&lt;reset&gt;
        syntax: &lt;yellow&gt;area rename &lt;name&gt;&lt;reset&gt;

        This command will rename the current area you're in to the new name.

        Example: &lt;yellow&gt;area rename My City&lt;reset&gt; - call the area you're in My City from now on

]]
map.help.arealock = [[
    &lt;cyan&gt;Arealock&lt;reset&gt;
        syntax: &lt;yellow&gt;arealock [filter]&lt;reset&gt;

        This command displays a list of areas you can lock/unlock, you can also
        give it an area name to filter by. If an area is locked the mapper will
        not attempt to speedwalk or go through any of the rooms in the area.

        Example: &lt;yellow&gt;arealock City&lt;reset&gt;
]]
map.help.room_coords = [[
    &lt;cyan&gt;Room Coordinates&lt;reset&gt;
        syntax: &lt;yellow&gt;room coords [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;reset&gt;
                &lt;yellow&gt;rc [v&lt;roomID&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;&lt;reset&gt;

        This command will move a room to the new map coordinates. x,y and z will
        specify the new location of the room. The room ID is optional, it'll move
        the current room if you don't provide one.

        Example: &lt;yellow&gt;rc nw&lt;reset&gt; - move the room to be nw of the current location
                 &lt;yellow&gt;rc v34 w&lt;reset&gt; - move the room ID 34 west, note the letter 'v' in the command
                 &lt;yellow&gt;rc 1 -5 10&lt;reset&gt; - move the current room to those exact coordinates
                 &lt;yellow&gt;rc v12 8 3 -8&lt;reset&gt; - move the room #12 to 8x, 3y and -8z
                 &lt;yellow&gt;rc 14x 5y&lt;reset&gt; - move the current room to be at 14x and 5y, but the
                    same z-level you're on. You can include all three of x, y, z coordinates
                    or only one as you wish
]]
map.help.room_delete = [[
    &lt;cyan&gt;Room Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;room delete &lt;direction|roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;rld &lt;direction|roomID&gt;&lt;reset&gt;

        This command will delete a room given a relative direction or roomID.

        Example: &lt;yellow&gt;rld&lt;reset&gt; - current room, will delete the room you're currently in
                 &lt;yellow&gt;rld n&lt;reset&gt; - relative direction, will delete the room that's north of you
                 &lt;yellow&gt;rld 513&lt;reset&gt; - using roomID, will delete the room with ID 513
]]
map.help.room_weight = [[
    &lt;cyan&gt;Room Weight&lt;reset&gt;
        syntax: &lt;yellow&gt;room weight [direction|roomID] &lt;weight&gt;&lt;reset&gt;
                &lt;yellow&gt;rw [direction|roomID] &lt;weight&gt;&lt;reset&gt;

        This command updates the weight of a room, making it more or less
        desirable to travel through.  Direction or roomID is optional and
        defaults to the current room.

        Example: &lt;yellow&gt;rw 10&lt;reset&gt; - will set the room weight of the room you're standing in to 10
                 &lt;yellow&gt;rw n 4&lt;reset&gt; - relative direction, will set the room weight of the room that's
                    to the north of you to four
                 &lt;yellow&gt;rw 2343 2&lt;reset&gt; - using roomID, will set the room weight of room 2343 to 2
]]
map.help.room_weight_exit = [[
    &lt;cyan&gt;Room Weight Exit&lt;reset&gt;
        syntax: &lt;yellow&gt;rwe [roomID] &lt;weight&gt; &lt;exit&gt;&lt;reset&gt;

        This command updates the weight of a room exit, where weight is a
        positive number (default for exits is 0). Setting a higher weight will
        make the exit be less likely to be used. The exit can be a cardinal
        direction of either n,e,s,w,ne,se,sw,ne,up,down,in,out or the exact
        special exit text (including the script: part). This alias sets a weight
        one way only, so if you want to set it both ways, use it on the opposite
        side as well. Use 'rl' to check exit weights.

        Example: &lt;yellow&gt;rwe 1 n&lt;reset&gt; -  will set the weight of the exit north to 1
                 &lt;yellow&gt;rwe 2434 0 e&lt;reset&gt; - will reset the exit weight of an east exit that
                    leads out from the 2434 room
]]
map.help.room_link = [[
    &lt;cyan&gt;Room Link&lt;reset&gt;
        syntax: &lt;yellow&gt;room link [roomID] &lt;direction&gt; [one]&lt;reset&gt;
                &lt;yellow&gt;rlk [roomID] &lt;direction&gt; [one]&lt;reset&gt;

        This command will link a room given a direction and optional roomID.
        You can also add 'one' at the end of the command to make it be a one-way
        link.

        Example: &lt;yellow&gt;rlk n&lt;reset&gt; - relative direction, will link if exists
                    a room to the north of this one to your current location
                 &lt;yellow&gt;rlk 351 n&lt;reset&gt; - exact roomID and direction, will
                    link the current room to room #351 via a north exit
                 &lt;yellow&gt;rlk n one&lt;reset&gt; - will make an exit north one-way
]]
map.help.room_unlink = [[
    &lt;cyan&gt;Room Unlink&lt;reset&gt;
        syntax: &lt;yellow&gt;room unlink &lt;direction&gt;&lt;reset&gt;
                &lt;yellow&gt;urlk &lt;direction&gt;&lt;reset&gt;

                Unlink a room given a direction.  This function will unlink
                exits both ways, or one way if there is no incoming exit.

        Example: &lt;yellow&gt;urlk nw&lt;reset&gt; - relative direction, will unlink to the
                    northwest, and from the northwest room to the southeast
]]
map.help.room_door = [[
    &lt;cyan&gt;Room Door&lt;reset&gt;
        syntax: &lt;yellow&gt;rd [roomID] &lt;direction&gt; &lt;open|closed|locked|clear&gt;&lt;reset&gt;

                Will create a door from the current room to a direction
                specified.  Door status can be open or o, closed or c, locked or
                l, clear or gone. To delete a room, use clear or gone. Setting
                doors is one-way - to set two-way doors, use the alias from the
                opposite direction.


        Example: &lt;yellow&gt;rd n&lt;reset&gt; - add a one-way door north from the current room
                 &lt;yellow&gt;rd 23 w closed&lt;reset&gt; - add a closed door leading west in room 23
                 &lt;yellow&gt;rd n clear&lt;reset&gt; - remove the door to the north from the current
                    room on this side only
]]
map.help.room_character = [[
    &lt;cyan&gt;Room Character&lt;reset&gt;
        syntax: &lt;yellow&gt;rcc &lt;character|clear&gt; [roomID]&lt;reset&gt;

        This command will assign a single character, letter or number to the
        current room, or an optional given room.  Using clear will remove any
        characters.

        Example: &lt;yellow&gt;rcc $&lt;reset&gt; - put the dollar sign in the current room 
                    (e.g. to indicate a shop or bank)
                 &lt;yellow&gt;rcc C 234&lt;reset&gt; - put the letter C onto room 234
                 &lt;yellow&gt;rcc clear&lt;reset&gt; - remove any letter from the current
                 room
]]
map.help.exit_special = [[
    &lt;cyan&gt;Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;exit special &lt;direction|roomID&gt; &lt;command&gt;&lt;reset&gt;
                &lt;yellow&gt;spe &lt;direction|roomID&gt; &lt;command&gt;&lt;reset&gt;

        This command will link two rooms via custom or special exit/script.

        Example: &lt;yellow&gt;spe n push rock&lt;reset&gt; - relative direction, will go to
                    the room that's north of you by doing 'push rock'
                 &lt;yellow&gt;spe 125 pull lever&lt;reset&gt; - will go to room 125 from the
                    current one by pulling a lever

        You can also specify a script to do code for you, by starting the exit
        command with script.

        Example: &lt;yellow&gt;spe 125 script: sendAll("pull lever", "enter gate")&lt;reset&gt;


]]
map.help.spev = [[
    &lt;cyan&gt;Remote Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;spev &lt;fromID&gt; &lt;toID&gt; &lt;command&gt;&lt;reset&gt;

        This command will add a special exit between two remote rooms.

        Example: &lt;yellow&gt;spe 125 560 push rock&lt;reset&gt; - will link room 125 to room 560 with
                    the command 'push rock'
]]
map.help.spe_clear = [[
    &lt;cyan&gt;Clear Special Exits&lt;reset&gt;
        syntax: &lt;yellow&gt;exit special clear &lt;direction|roomID&gt;&lt;reset&gt;
                &lt;yellow&gt;spe clear &lt;direction|roomID&gt;&lt;reset&gt;

        This command will clear all special exits from the current, relative or
        given roomID.

        Example: &lt;yellow&gt;spe clear&lt;reset&gt; - delete all special exits in the room you're currently in
                 &lt;yellow&gt;spe clear n&lt;reset&gt; - delete all special exits in the room that's north of you
                 &lt;yellow&gt;spe clear 513&lt;reset&gt; - delete all special exits in room #513
]]
map.help.room_area = [[
    &lt;cyan&gt;Room Area&lt;reset&gt;
        syntax: &lt;yellow&gt;room area [v&lt;roomID&gt;] &lt;area name|areaID&gt;&lt;reset&gt;

        This command moves the current room to another area or a given optional
        room.

        Example: &lt;yellow&gt;room area My New Area&lt;reset&gt; - move the room you're in to 'My New Area'.
                 &lt;yellow&gt;room area v123 My New Area&lt;reset&gt; - move room 123 to My New Area
                 &lt;yellow&gt;room area 44&lt;reset&gt; - move the current room to the area ID 44
]]
map.help.room_label = [[
    &lt;cyan&gt;Room Label&lt;reset&gt;
        syntax: &lt;yellow&gt;room label [roomID] [fgColor] [bgColor] &lt;message&gt;&lt;reset&gt;

        This command adds a label to the current or specified room.  Foreground
        and background color are optional.

        Example: &lt;yellow&gt;room label My Label&lt;reset&gt; - adds a 'My Label' label to the current room
                 &lt;yellow&gt;room label 342 My Label&lt;reset&gt; - adds a label to room #342
                 &lt;yellow&gt;room label green My Label&lt;reset&gt; - adds a green label with a transparent
                    background to the current room
                 &lt;yellow&gt;room label green black My Label&lt;reset&gt; - adds a label with a green
                    foreground and black background to the current room
                 &lt;yellow&gt;room label 34 green black My Label&lt;reset&gt; - adds a label with a green
                    foreground and black background to room #34
]]
map.help.area_labels = [[
    &lt;cyan&gt;Area Labels&lt;reset&gt;
        syntax: &lt;yellow&gt;area labels &lt;area name&gt;&lt;reset&gt;

        This command displays all labels in a given area, with a link to delete.

        Example: &lt;yellow&gt;area label My Area&lt;reset&gt;
]]
map.help.feature_create = [[
    &lt;cyan&gt;Feature Create&lt;reset&gt;
        syntax: &lt;yellow&gt;feature create &lt;feature&gt; [char &lt;room character&gt;]&lt;reset&gt;

        This command will create a new map feature for use on rooms. You can
        also optionally add a character mark to the feature, which will be set
        when a map feature is added to a room. Note: Map feature names are not
        allowed to contain numbers.

        Example: &lt;yellow&gt;feature create A Nexus Point char N&lt;reset&gt; - creates a new feature
                    'A Nexus Point' with an assigned room character 'N'
]]
map.help.room_feature_create = [[
    &lt;cyan&gt;Room Create Feature&lt;reset&gt;
        syntax: &lt;yellow&gt;room create feature [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;
                &lt;yellow&gt;rcf [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;

        This command will add a created map feature to the room. If the map
        feature is associated with a character mark, it will be set on the room
        and existing marks get overwritten. The room number to add the feature
        to can be given with the optional argument (note: there is no space
        between the v and the ID).

        Example: &lt;yellow&gt;rcf A Nexus Point&lt;reset&gt; - add the feature 'A Nexus Point' to
                    the current room
                 &lt;yellow&gt;rcf v123 A Nexus Point&lt;reset&gt; - add the feature 'A Nexus Point'
                    to room #123
]]
map.help.room_feature_delete = [[
    &lt;cyan&gt;Room Delete Feature&lt;reset&gt;
        syntax: &lt;yellow&gt;room delete feature [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;
                &lt;yellow&gt;rdf [v&lt;room id&gt;] &lt;feature&gt;&lt;reset&gt;

        This command removes a map feature from the room. If the map feature is
        associated with a character mark and its set on the room, a random
        character mark from the other map features on the room is chosen to
        replace it. The room number to delete the feature from can be given with
        the optional argument (note: there is no space between the v and the
        ID).

        Example: &lt;yellow&gt;rdf v123 A Nexus Point&lt;reset&gt; - removes the feature 'A Nexus Point'
                    from the room #123
]]
map.help.feature_delete = [[
    &lt;cyan&gt;Feature Delete&lt;reset&gt;
        syntax: &lt;yellow&gt;feature delete &lt;feature&gt;&lt;reset&gt;

        This command deletes a global map feature and removes it from all rooms.

        Example: &lt;yellow&gt;feature delete A Nexus Point&lt;reset&gt; - removes the global feature
                    'A Nexus Point' and removes it from all rooms
]]



map.character = map.character or ""
map.prompt = map.prompt or {}
map.save = map.save or {}
map.save.recall = map.save.recall or {}
map.save.prompt_pattern = map.save.prompt_pattern or {}
map.save.ignore_patterns = map.save.ignore_patterns or {}
map.save.move_methods = map.save.move_methods or {}
map.silentUpdate = map.silentUpdate or true

local oldstring = string
local string = utf8
string.format = oldstring.format
string.trim = oldstring.trim
string.starts = oldstring.starts
string.split = oldstring.split
string.ends = oldstring.ends


local profilePath = getMudletHomeDir()
profilePath = profilePath:gsub("\\","/")

map.defaults = {
    mode = "normal", -- can be lazy, simple, normal, or complex
    stretch_map = true,
    search_on_look = true,
    speedwalk_delay = 1,
    speedwalk_wait = true,
    speedwalk_random = true,
    max_search_distance = 1,
    clear_lines_on_send = true,
    map_window = {
        x = 0,
        y = 0,
        w = "30%",
        h = "40%",
        origin = "topright",
        shown = false,
    },
    prompt_test_patterns = {"^%[?%a*%]?&lt;.*&gt;", "^%[.*%]%s*&gt;", "^%w*[%.?!:]*&gt;", "^%[.*%]", "^[Hh][Pp]:.*&gt;"},
    custom_exits = {},  -- format: short_exit = {long_exit, reverse_exit, x_dif, y_dif, z_dif}
                        -- ex: { us = {"upsouth", "downnorth", 0, -1, 1}, dn = {"downnorth", "upsouth", 0, 1, -1} }
    custom_name_search = false,
    use_translation = true,
    lang_dirs = {n = 'n', ne = 'ne', nw = 'nw', e = 'e', w = 'w', s = 's', se = 'se', sw = 'sw',
        u = 'u', d = 'd', ["in"] = 'in', out = 'out', north = 'north', northeast = 'northeast',
        east = 'east', west = 'west', south = 'south', southeast = 'southeast', southwest = 'southwest',
        northwest = 'northwest', up = 'up', down = 'down', l = 'l', look = 'look',
        ed = 'ed', eu = 'eu', eastdown = 'eastdown', eastup = 'eastup',
        nd = 'nd', nu = 'nu', northdown = 'northdown', northup = 'northup',
        sd = 'sd', su = 'su', southdown = 'southdown', southup = 'southup',
        wd = 'wd', wu = 'wu', westdown = 'westdown', westup = 'westup',
    },
    debug = false,
    download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper",
}

local move_queue, lines = {}, {}
local find_portal, vision_fail, room_detected, random_move, force_portal, find_prompt, downloading, walking, help_shown
local mt = getmetatable(map) or {}

local exitmap = {
    n = 'north',    ne = 'northeast',   nw = 'northwest',   e = 'east',
    w = 'west',     s = 'south',        se = 'southeast',   sw = 'southwest',
    u = 'up',       d = 'down',         ["in"] = 'in',      out = 'out',
    l = 'look',
    ed = 'eastdown',    eu = 'eastup',  nd = 'northdown',   nu = 'northup',
    sd = 'southdown',   su = 'southup', wd = 'westdown',    wu = 'westup',
}

local short = {}
for k,v in pairs(exitmap) do
    short[v] = k
end

local stubmap = {
    north = 1,      northeast = 2,      northwest = 3,      east = 4,
    west = 5,       south = 6,          southeast = 7,      southwest = 8,
    up = 9,         down = 10,          ["in"] = 11,        out = 12,
    northup = 13,   southdown = 14,     southup = 15,       northdown = 16,
    eastup = 17,    westdown = 18,      westup = 19,        eastdown = 20,
    [1] = "north",  [2] = "northeast",  [3] = "northwest",  [4] = "east",
    [5] = "west",   [6] = "south",      [7] = "southeast",  [8] = "southwest",
    [9] = "up",     [10] = "down",      [11] = "in",        [12] = "out",
    [13] = "northup", [14] = "southdown", [15] = "southup", [16] = "northdown",
    [17] = "eastup", [18] = "westdown", [19] = "westup",    [20] = "eastdown",
}

local coordmap = {
    [1] = {0,1,0},      [2] = {1,1,0},      [3] = {-1,1,0},     [4] = {1,0,0},
    [5] = {-1,0,0},     [6] = {0,-1,0},     [7] = {1,-1,0},     [8] = {-1,-1,0},
    [9] = {0,0,1},      [10] = {0,0,-1},    [11] = {0,0,0},     [12] = {0,0,0},
    [13] = {0,1,1},     [14] = {0,-1,-1},   [15] = {0,-1,1},    [16] = {0,1,-1},
    [17] = {1,0,1},     [18] = {-1,0,-1},   [19] = {-1,0,1},    [20] = {1,0,-1},
}

local reverse_dirs = {
    north = "south", south = "north", west = "east", east = "west", up = "down",
    down = "up", northwest = "southeast", northeast = "southwest", southwest = "northeast",
    southeast = "northwest", ["in"] = "out", out = "in",
    northup = "southdown", southdown = "northup", southup = "northdown", northdown = "southup",
    eastup = "westdown", westdown = "eastup", westup = "eastdown", eastdown = "westup",
}

local wait_echo = {}
local mapper_tag = "&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;"
local debug_tag = "&lt;255,165,0&gt;(&lt;200,120,0&gt;debug&lt;255,165,0&gt;): &lt;255,255,255&gt;"
local err_tag = "&lt;255,0,0&gt;(&lt;178,34,34&gt;error&lt;255,0,0&gt;): &lt;255,255,255&gt;"

local function config()
    local defaults = map.defaults
    local configs = map.configs or {}
    local path = profilePath.."/map downloads"
    if not io.exists(path) then lfs.mkdir(path) end
    -- load stored configs from file if it exists
    if io.exists(path.."/configs.lua") then
        table.load(path.."/configs.lua",configs)
    end
    -- overwrite default values with stored config values
    configs = table.update(defaults, configs)
    map.configs = configs
    map.configs.translate = {}
    for k, v in pairs(map.configs.lang_dirs) do
        map.configs.translate[v] = k
    end
    -- incorporate custom exits
    for k,v in pairs(map.configs.custom_exits) do
        exitmap[k] = v[1]
        reverse_dirs[v[1]] = v[2]
        short[v[1]] = k
        local count = #coordmap + 1
        coordmap[count] = {v[3],v[4],v[5]}
        stubmap[count] = v[1]
        stubmap[v[1]] = count
    end
    -- update to the current download path
    if map.configs.download_path == "https://raw.githubusercontent.com/JorMox/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
        map.configs.download_path = "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper"
    end

    -- setup metatable to store sensitive values
    local protected = {"mapping", "currentRoom", "currentName", "currentExits", "currentArea",
        "prevRoom", "prevName", "prevExits", "mode", "version"}
    mt = getmetatable(map) or {}
    mt.__index = mt
    mt.__newindex = function(tbl, key, value)
            if not table.contains(protected, key) then
                rawset(tbl, key, value)
            else
                error("Protected Map Table Value")
            end
        end
    mt.set = function(key, value)
            if table.contains(protected, key) then
                mt[key] = value
            end
        end
    setmetatable(map, mt)
    map.set("mode", configs.mode)
    map.set("version", version)

    local saves = {}
    if io.exists(path.."/map_save.dat") then
        table.load(path.."/map_save.dat",saves)
    end
    saves.prompt_pattern = saves.prompt_pattern or {}
    saves.ignore_patterns = saves.ignore_patterns or {}
    saves.move_methods = saves.move_methods or {}
    saves.recall = saves.recall or {}
    map.save = saves

    if map.configs.map_window.shown then
        map.showMap(true)
    end
end

local function parse_help_text(text)
  text = text:gsub("%$ROOM_NAME_STATUS", (map.currentName and map.currentName ~= "") and '✔️' or '❌')
  text = text:gsub("%$ROOM_NAME", map.currentName or '')

  text = text:gsub("%$ROOM_EXITS_STATUS", (not map.currentExits or table.is_empty(map.currentExits)) and '❌' or '✔️')
  text = text:gsub("%$ROOM_EXITS", map.currentExits and table.concat(map.currentExits, ' ') or '')

  return text
end

function map.show_help(cmd)
    if cmd and cmd ~= "" then
        if cmd:starts("map ") then cmd = cmd:sub(5) end
        cmd = cmd:lower():gsub(" ","_")
        if not map.help[cmd] then
            map.echo("No help file on that command.")
        end
    else
        cmd = 1
    end

    for w in parse_help_text(map.help[cmd]):gmatch("[^\n]*\n") do
        local url, target = rex.match(w, [[&lt;(url)?link: ([^&gt;]+)&gt;]])
        -- lrexlib returns a non-capture as 'false', so determine which variable the capture went into
        if target == nil then target = url end
        if target then
            local before, linktext, _, link, _, after, ok = rex.match(w,
                          [[(.*)&lt;((url)?link): [^&gt;]+&gt;(.*)&lt;\/(url)?link&gt;(.*)]], 0, 'm')
            -- could not get rex.match to capture the newline - fallback to string.match
            local _, _, after = w:match("(.*)&lt;u?r?l?link: [^&gt;]+&gt;(.*)&lt;/u?r?l?link&gt;(.*)")

            cecho(before)
            fg("yellow")
            setUnderline(true)
            if linktext == "urllink" then
                echoLink(link, [[openWebPage("]]..target..[[")]], "Open webpage", true)
            elseif target ~= "1" then
                echoLink(link,[[map.show_help("]]..target..[[")]],"View: map help " .. target,true)
            else
                echoLink(link,[[map.show_help()]],"View: map help",true)
            end
            setUnderline(false)
            resetFormat()
            if after then cecho(after) end
        else
            cecho(w)
        end
    end
    echo("\n")
end

local bool_configs = {'stretch_map', 'search_on_look', 'speedwalk_wait', 'speedwalk_random',
    'clear_lines_on_send', 'debug', 'custom_name_search', 'use_translation'}
-- function intended to be used by an alias to change config values and save them to a file for later
function map.setConfigs(key, val, sub_key)
    if val == "off" or val == "false" then
        val = false
    elseif val == "on" or val == "true" then
        val = true
    end
    local toggle = false
    if val == nil or val == "" then toggle = true end
    key = key:gsub(" ","_")
    if tonumber(val) then val = tonumber(val) end
    if not toggle then
        if key == "map_window" then
            if map.configs.map_window[sub_key] then
                map.configs.map_window[sub_key] = val
                map.echo(string.format("Map config %s set to: %s", sub_key, tostring(val)))
            else
                map.echo("Unknown map config.",false, true)
            end
        elseif key =="lang_dirs" then
            sub_key = exitmap[sub_key] or sub_key
            if map.configs.lang_dirs[sub_key] then
                local long_dir, short_dir = val[1],val[2]
                if #long_dir &lt; #short_dir then long_dir, short_dir = short_dir, long_dir end
                map.configs.lang_dirs[sub_key] = long_dir
                map.configs.lang_dirs[short[sub_key]] = short_dir
                map.echo(string.format("Direction/command %s, abbreviated as %s, now interpreted as %s.", long_dir, short_dir, sub_key))
                map.configs.translate = {}
                for k, v in pairs(map.configs.lang_dirs) do
                    map.configs.translate[v] = k
                end
            else
                map.echo("Invalid direction/command.", false, true)
            end
        elseif key == "prompt_test_patterns" then
            if not table.contains(map.configs.prompt_test_patterns) then
                table.insert(map.configs.prompt_test_patterns, val)
                map.echo("Prompt pattern added to list: " .. val)
            else
                table.remove(map.configs.prompt_test_patterns, table.index_of(map.configs.prompt_test_patterns, val))
                map.echo("Prompt pattern removed from list: " .. val)
            end
        elseif key == "custom_exits" then
            if type(val) == "table" then
                for k, v in pairs(val) do
                    map.configs.custom_exits[k] = v
                    map.echo(string.format("Custom Exit short direction %s, long direction %s",k,v[1]))
                    map.echo(string.format("    set to: x: %s, y: %s, z: %s, reverse: %s",v[3],v[4],v[5],v[2]))
                end
            else
                map.echo("Custom Exit config must be in the form of a table.", false, true)
            end
        elseif map.configs[key] ~= nil then
            map.configs[key] = val
            map.echo(string.format("Config %s set to: %s", key, tostring(val)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    elseif toggle then
        if (type(map.configs[key]) == "boolean" and table.contains(bool_configs, key)) then
            map.configs[key] = not map.configs[key]
            map.echo(string.format("Config %s set to: %s", key, tostring(map.configs[key])))
        elseif key == "map_window" and sub_key == "shown" then
            map.configs.map_window.shown = not map.configs.map_window.shown
            map.echo(string.format("Map config %s set to: %s", "shown", tostring(map.configs.map_window.shown)))
        else
            map.echo("Unknown configuration.",false,true)
            return
        end
    end
    table.save(profilePath.."/map downloads/configs.lua",map.configs)
    config()
end

local function show_err(msg,debug)
    map.echo(msg,debug,true)
    error(msg,2)
end

local function print_echoes(what, debug, err)
    moveCursorEnd("main")
    local curline = getCurrentLine()
    if curline ~= "" then echo("\n") end
    decho(mapper_tag)
    if debug then decho(debug_tag) end
    if err then decho(err_tag) end
    cecho(what)
    echo("\n")
end

local function print_wait_echoes()
    for k,v in ipairs(wait_echo) do
        print_echoes(v[1],v[2],v[3])
    end
    wait_echo = {}
end

function map.echo(what, debug, err, wait)
    if debug and not map.configs.debug then return end
    what = tostring(what) or ""
    if wait then
        table.insert(wait_echo,{what, debug, err})
        return
    end
    print_wait_echoes()
    print_echoes(what, debug, err)
end

local function set_room(roomID)
    -- moves the map to the new room
    if map.currentRoom ~= roomID then
        map.set("prevRoom", map.currentRoom)
        map.set("currentRoom", roomID)
    end
    if getRoomName(map.currentRoom) ~= map.currentName then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        map.set("currentName", getRoomName(map.currentRoom))
        map.set("currentExits", getRoomExits(map.currentRoom))
        -- check handling of custom exits here
        for i = 13,#stubmap do
            map.currentExits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
        end
    end
    map.set("currentArea", getRoomArea(map.currentRoom))
    centerview(map.currentRoom)
    raiseEvent("onMoveMap", map.currentRoom)
end

local function add_door(roomID, dir, status)
    -- create or remove a door in the designated direction
    -- consider options for adding pickable and passable information
    dir = exitmap[dir] or dir
    if not table.contains(exitmap,dir) then
        error("Add Door: invalid direction.",2)
    end
    if type(status) ~= "number" then
        status = assert(table.index_of({"none","open","closed","locked"},status),
            "Add Door: Invalid status, must be none, open, closed, or locked") - 1
    end
    local exits = getRoomExits(roomID)
    -- check handling of custom exits here
    if not exits[dir] then
        setExitStub(roomID,stubmap[dir],true)
    end
    -- check handling of custom exits here
    if not table.contains({'u','d'},short[dir]) then
        setDoor(roomID,short[dir],status)
    else
        setDoor(roomID,dir,status)
    end
end

local function check_doors(roomID,exits)
    -- looks to see if there are doors in designated directions
    -- used for room comparison, can also be used for pathing purposes
    if type(exits) == "string" then exits = {exits} end
    local statuses = {}
    local doors = getDoors(roomID)
    local dir
    for k,v in pairs(exits) do
        dir = short[k] or short[v]
        if table.contains({'u','d'},dir) then
            dir = exitmap[dir]
        end
        if not doors[dir] or doors[dir] == 0 then
            return false
        else
            statuses[dir] = doors[dir]
        end
    end
    return statuses
end

local function find_room(name, area)
    -- looks for rooms with a particular name, and if given, in a specific area
    local rooms = searchRoom(name)
    if type(area) == "string" then
        local areas = getAreaTable() or {}
        for k,v in pairs(areas) do
            if string.lower(k) == string.lower(area) then
                area = v
                break
            end
        end
        area = areas[area] or nil
    end
    for k,v in pairs(rooms) do
        if string.lower(v) ~= string.lower(name) then
            rooms[k] = nil
        elseif area and getRoomArea(k) ~= area then
            rooms[k] = nil
        end
    end
    return rooms
end

local function getRoomStubs(roomID)
    -- turns stub info into table similar to exit table
    local stubs = getExitStubs(roomID)
    if type(stubs) ~= "table" then stubs = {} end
    -- check handling of custom exits here
    local tmp
    for i = 13,#stubmap do
        tmp = tonumber(getRoomUserData(roomID,"stub "..stubmap[i])) or tonumber(getRoomUserData(roomID,"stub"..stubmap[i])) -- for old version
        if tmp then table.insert(stubs,tmp) end
    end

    local exits = {}
    for k,v in pairs(stubs) do
        exits[stubmap[v]] = 0
    end
    return exits
end

local function connect_rooms(ID1, ID2, dir1, dir2, no_check)
    -- makes a connection between rooms
    -- can make backwards connection without a check
    local match = false
    if not ID1 and ID2 and dir1 then
        error("Connect Rooms: Missing Required Arguments.",2)
    end
    dir2 = dir2 or reverse_dirs[dir1]
    -- check handling of custom exits here
    if stubmap[dir1] &lt;= 12 then
        setExit(ID1,ID2,stubmap[dir1])
    else
        addSpecialExit(ID1, ID2, dir1)
        setRoomUserData(ID1,"exit " .. dir1,ID2)
    end
    if stubmap[dir1] &gt; 12 then
        -- check handling of custom exits here
        setRoomUserData(ID1,"stub "..dir1, stubmap[dir1])
    end
    local doors1, doors2 = getDoors(ID1), getDoors(ID2)
    local dstatus1, dstatus2 = doors1[short[dir1]] or doors1[dir1], doors2[short[dir2]] or doors2[dir2]
    if dstatus1 ~= dstatus2 then
        if not dstatus1 then
            add_door(ID1,dir1,dstatus2)
        elseif not dstatus2 then
            add_door(ID2,dir2,dstatus1)
        end
    end
    if map.mode ~= "complex" then
        local stubs = getRoomStubs(ID2)
        if stubs[dir2] then match = true end
        if (match or no_check) then
            -- check handling of custom exits here
            if stubmap[dir1] &lt;= 12 then
                setExit(ID2,ID1,stubmap[dir2])
            else
                addSpecialExit(ID2, ID1, dir2)
                setRoomUserData(ID2,"exit " .. dir2,ID1)
            end
            if stubmap[dir2] &gt; 12 then
                -- check handling of custom exits here
                setRoomUserData(ID2,"stub "..dir2, stubmap[dir2])
            end
        end
    end
end

local function check_room(roomID, name, exits, onlyName)
    -- check to see if room name or/and exits match expectations
    if not roomID then
        error("Check Room Error: No ID",2)
    end
    -- check with room hash id
    if map.prompt.hash then
        if map.prompt.hash == getRoomHashByID(roomID) then
            return true
        else
            return false
        end
    end

    if name ~= getRoomName(roomID) then return false end

    -- used in mode "lazy" to match only the room name
    if onlyName then return true end

    local t_exits = table.union(getRoomExits(roomID),getRoomStubs(roomID))
    -- check handling of custom exits here
    for i = 13,#stubmap do
        t_exits[stubmap[i]] = tonumber(getRoomUserData(roomID,"exit " .. stubmap[i])) or (tonumber(getRoomUserData(roomID,"stub " .. stubmap[i])) and 0) or (tonumber(getRoomUserData(roomID,"stub" .. stubmap[i])) and 0) -- for old version
    end
    for k,v in ipairs(exits) do
        if short[v] and not table.contains(t_exits,v) then return false end
        t_exits[v] = nil
    end
    return table.is_empty(t_exits) or check_doors(roomID,t_exits)
end

local function stretch_map(dir,x,y,z)
    -- stretches a map to make room for just added room that would overlap with existing room
    local dx,dy,dz
    if not dir then return end
    for k,v in pairs(getAreaRooms(map.currentArea)) do
        if v ~= map.currentRoom then
            dx,dy,dz = getRoomCoordinates(v)
            if dx &gt;= x and string.find(dir,"east") then
                dx = dx + 1
            elseif dx &lt;= x and string.find(dir,"west") then
                dx = dx - 1
            end
            if dy &gt;= y and string.find(dir,"north") then
                dy = dy + 1
            elseif dy &lt;= y and string.find(dir,"south") then
                dy = dy - 1
            end
            if dz &gt;= z and string.find(dir,"up") then
                dz = dz + 1
            elseif dz &lt;= z and string.find(dir,"down") then
                dz = dz - 1
            end
            setRoomCoordinates(v,dx,dy,dz)
        end
    end
end

local function create_room(name, exits, dir, coords)
    -- makes a new room with captured name and exits
    -- links with other rooms as appropriate
    -- links to adjacent rooms in direction of exits if in simple mode
    if map.mapping then
        name = map.sanitizeRoomName(name)
        map.echo("New Room: " .. name,false,false,(dir or find_portal or force_portal) and true or false)
        local newID = createRoomID()
        addRoom(newID)
        setRoomArea(newID, map.currentArea)
        setRoomName(newID, name)
        if map.prompt.hash then
            setRoomIDbyHash(newID, map.prompt.hash)
        end
        for k,v in ipairs(exits) do
            if stubmap[v] then
                if stubmap[v] &lt;= 12 then
                    setExitStub(newID, stubmap[v], true)
                else
                    -- add special char to prompt special exit
                    if string.find(v, "up") or string.find(v, "down") then
                        setRoomChar(newID, "◎")
                    end
                    -- check handling of custom exits here
                    setRoomUserData(newID, "stub "..v,stubmap[v])
                end
            end
        end
        if dir then
            connect_rooms(map.currentRoom, newID, dir)
        elseif find_portal or force_portal then
            addSpecialExit(map.currentRoom, newID, (find_portal or force_portal))
            setRoomUserData(newID,"portals",tostring(map.currentRoom)..":"..(find_portal or force_portal))
        end
        setRoomCoordinates(newID,unpack(coords))
        local pos_rooms = getRoomsByPosition(map.currentArea,unpack(coords))
        if not (find_portal or force_portal) and map.configs.stretch_map and table.size(pos_rooms) &gt; 1 then
            set_room(newID)
            stretch_map(dir,unpack(coords))
        end
        if map.mode == "simple" then
            local x,y,z = unpack(coords)
            local dx,dy,dz,rooms
            for k,v in ipairs(exits) do
                if stubmap[v] then
                    dx,dy,dz = unpack(coordmap[stubmap[v]])
                    rooms = getRoomsByPosition(map.currentArea,x+dx,y+dy,z+dz)
                    if table.size(rooms) == 1 then
                        connect_rooms(newID,rooms[0],v)
                    end
                end
            end
        end
        set_room(newID)
    end
end

local function find_area_limits(areaID)
    -- used to find min and max coordinate limits for an area
    if not areaID then
        error("Find Limits: Missing area ID",2)
    end
    local rooms = getAreaRooms(areaID)
    local minx, miny, minz = getRoomCoordinates(rooms[0])
    local maxx, maxy, maxz = minx, miny, minz
    local x,y,z
    for k,v in pairs(rooms) do
        x,y,z = getRoomCoordinates(v)
        minx = math.min(x,minx)
        maxx = math.max(x,maxx)
        miny = math.min(y,miny)
        maxy = math.max(y,maxy)
        minz = math.min(z,minz)
        maxz = math.max(z,maxz)
    end
    return minx, maxx, miny, maxy, minz, maxz
end

local function find_link(name, exits, dir, max_distance)
    -- search for matching room in desired direction
    -- in lazy mode check_room search only by name
    local x,y,z = getRoomCoordinates(map.currentRoom)
    if map.mapping and x then
        if max_distance &lt; 1 then
            max_distance = nil
        else
            max_distance = max_distance - 1
        end
        if not stubmap[dir] or not coordmap[stubmap[dir]] then return end
        local dx,dy,dz = unpack(coordmap[stubmap[dir]])
        local minx, maxx, miny, maxy, minz, maxz = find_area_limits(map.currentArea)
        local rooms, match, stubs
        if max_distance then
            minx, maxx = x - max_distance, x + max_distance
            miny, maxy = y - max_distance, y + max_distance
            minz, maxz = z - max_distance, z + max_distance
        end
        -- find link from room hash first
        if map.prompt.hash then
            local room = getRoomIDbyHash(map.prompt.hash)
            if room &gt; 0 then
                match = room
            end
        else
            repeat
                x, y, z = x + dx, y + dy, z + dz
                rooms = getRoomsByPosition(map.currentArea,x,y,z)
            until (x &gt; maxx or x &lt; minx or y &gt; maxy or y &lt; miny or z &gt; maxz or z &lt; minz or not table.is_empty(rooms))
            for k,v in pairs(rooms) do
                if check_room(v,name,exits,false) then
                    match = v
                    break
                elseif map.mode == "lazy" and check_room(v,name,exits,true) then
                    match = v
                    break
                end
            end
        end
        if match then
            connect_rooms(map.currentRoom, match, dir)
            set_room(match)
        else
            x,y,z = getRoomCoordinates(map.currentRoom)
            create_room(name, exits, dir,{x+dx,y+dy,z+dz})
        end
    end
end

local function move_map()
    -- tries to move the map to the next room
    local move = table.remove(move_queue,1)
    if move or random_move then
        local exits = (map.currentRoom and getRoomExits(map.currentRoom)) or {}
        -- check handling of custom exits here
        if map.currentRoom then
            for i = 13, #stubmap do
                exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,"exit " .. stubmap[i]))
            end
        end
        local special = (map.currentRoom and getSpecialExitsSwap(map.currentRoom)) or {}
        if move and not exits[move] and not special[move] then
            for k,v in pairs(special) do
                if string.starts(k,move) then
                    move = k
                    break
                end
            end
        end
        if find_portal then
            map.find_me(map.currentName,map.currentExits,move)
            find_portal = false
        elseif force_portal then
            find_portal = false
            map.echo("Creating portal destination")
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
            force_portal = false
        elseif move == "recall" and map.save.recall[map.character] then
            set_room(map.save.recall[map.character])
        elseif move == map.configs.lang_dirs['look'] and map.currentRoom and not check_room(map.currentRoom, map.currentName, map.currentExits) then
            -- this check isn't working as intended, find out why
            map.find_me(map.currentName,map.currentExits)
        else
            local onlyName
            if map.mode == "lazy" then
              onlyName = true
            else
              onlyName = false
            end
            if exits[move] and (vision_fail or check_room(exits[move], map.currentName, map.currentExits, onlyName)) then
                set_room(exits[move])
            elseif special[move] and (vision_fail or check_room(special[move], map.currentName, map.currentExits, onlyName)) then
                set_room(special[move])
            elseif not vision_fail then
                if map.mapping and move then
                    find_link(map.currentName, map.currentExits, move, map.configs.max_search_distance)
                else
                    map.find_me(map.currentName,map.currentExits, move)
                end
            end
        end
        vision_fail = false
    end
end

local function capture_move_cmd(dir,priority)
    -- captures valid movement commands
    local configs = map.configs
    if configs.clear_lines_on_send then
        lines = {}
    end
    dir = string.lower(dir)
    if dir == "/" then dir = "recall" end
    if dir == configs.lang_dirs['l'] then dir = configs.lang_dirs['look'] end
    if configs.use_translation then
        dir = configs.translate[dir] or dir
    end
    local door = string.match(dir,"open (%a+)")
    if map.mapping and door and (exitmap[door] or short[door]) then
        local doors = getDoors(map.currentRoom)
        if not doors[door] and not doors[short[door]] then
            map.set_door(door,"","")
        end
    end
    for i,v in ipairs(map.save.move_methods) do
    	local str = string.match(dir, v .. " (%a+)")
    	if str then 
    		dir = str
    		break
    	end
    end
    local portal = string.match(dir,"enter (%a+)")
    if map.mapping and portal then
        local portals = getSpecialExitsSwap(map.currentRoom)
        if not portals[dir] then
            map.set_portal(dir, true)
        end
    end
    if table.contains(exitmap,dir) or string.starts(dir,"enter ") or dir == "recall" then
      if dir ~= configs.lang_dirs['look'] then
        if priority then
            table.insert(move_queue,1,exitmap[dir] or dir)
        else
            table.insert(move_queue,exitmap[dir] or dir)
        end
      else
        if configs.search_on_look == true then
          table.insert(move_queue, dir)
        end
    end				
    elseif map.currentRoom then
        local special = getSpecialExitsSwap(map.currentRoom) or {}
        if special[dir] then
            if priority then
                table.insert(move_queue,1,dir)
            else
                table.insert(move_queue,dir)
            end
        end
    end
end

local function deduplicate_exits(exits)
  local deduplicated_exits = {}
  for _, v in ipairs(exits) do
    deduplicated_exits[v] = true
  end

  return table.keys(deduplicated_exits)
end
local function capture_room_info(name, exits)
    -- captures room info, and tries to move map to match
    if (not vision_fail) and name and exits then
        map.set("prevName", map.currentName)
        map.set("prevExits", map.currentExits)
        name = string.trim(name)
        map.set("currentName", name)
        if exits:ends(".") then exits = exits:sub(1,#exits-1) end
        if not map.configs.use_translation then
            exits = string.gsub(string.lower(exits)," and "," ")
        end
        map.set("currentExits", {})
        for w in string.gmatch(exits,"%a+") do
            if map.configs.use_translation then
                local dir = map.configs.translate and map.configs.translate[w]
                if dir then table.insert(map.currentExits,dir) end
            else
                table.insert(map.currentExits,w)
            end
        end
        undupeExits = deduplicate_exits(map.currentExits)
        map.set("currentExits", undupeExits)
        map.echo(string.format("Exits Captured: %s (%s)",exits, table.concat(map.currentExits, " ")),true)
        move_map()
    elseif vision_fail then
        move_map()
    end
end

local function find_area(name)
    -- searches for the named area, and creates it if necessary
    local areas = getAreaTable()
    local areaID
    for k,v in pairs(areas) do
        if string.lower(name) == string.lower(k) then
            areaID = v
            break
        end
    end
    if not areaID then areaID = addAreaName(name) end
    if not areaID then
        show_err("Invalid Area. No such area found, and area could not be added.",true)
    end
    map.set("currentArea", areaID)
end

function map.load_map(address)
    local path = profilePath .. "/map downloads/map.dat"
    if not address then
        loadMap(path)
        map.echo("Map reloaded from local copy.")
    else
        if not string.match(address,"/[%a_]+%.dat$") then
            address = address .. "/map.dat"
        end
        downloading = true
        downloadFile(path, address)
        map.echo(string.format("Downloading map file from: %s.",address))
    end
end

function map.set_exit(dir,roomID)
    -- used to set unusual exits from the room you are standing in
    if map.mapping then
        roomID = tonumber(roomID)
        if not roomID then
            show_err("Set Exit: Invalid Room ID")
        end
        if not table.contains(exitmap,dir) and not string.starts(dir, "-p ") then
            show_err("Set Exit: Invalid Direction")
        end

        if not string.starts(dir, "-p ") then
            local exit
            if stubmap[exitmap[dir] or dir] &lt;= 12 then
                exit = short[exitmap[dir] or dir]
                setExit(map.currentRoom,roomID,exit)
            else
                -- check handling of custom exits here
                exit = exitmap[dir] or dir
                exit = "exit " .. exit
                setRoomUserData(map.currentRoom,exit,roomID)
            end
            map.echo("Exit " .. dir .. " now goes to roomID " .. roomID)
        else
            dir = string.gsub(dir,"^-p ","")
            addSpecialExit(map.currentRoom,roomID,dir)
            map.echo("Special exit '" .. dir .. "' now goes to roomID " .. roomID)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.find_path(roomName,areaName,return_tables)
    areaName = (areaName ~= "" and areaName) or nil
    local rooms = find_room(roomName,areaName)
    local found,dirs = false,{}
    local path = {}
    for k,v in pairs(rooms) do
        found = getPath(map.currentRoom,k)
        if found and (#dirs == 0 or #dirs &gt; #speedWalkDir) then
            dirs = speedWalkDir
            path = speedWalkPath
        end
    end
    if return_tables then
        if table.is_empty(path) then
            path, dirs = nil, nil
        end
        return path, dirs
    else
        if #dirs &gt; 0 then
            map.echo("Path to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ": " .. table.concat(dirs,", "))
        else
            map.echo("No path found to " .. roomName .. ((areaName and " in " .. areaName) or "") .. ".",false,true)
        end
    end
end

function map.export_area(name)
    -- used to export a single area to a file
    local areas = getAreaTable()
    name = string.lower(name)
    for k,v in pairs(areas) do
        if name == string.lower(k) then name = k end
    end
    if not areas[name] then
        show_err("No such area.")
    end
    local rooms = getAreaRooms(areas[name])
    local tmp = {}
    for k,v in pairs(rooms) do
        tmp[v] = v
    end
    rooms = tmp
    local tbl = {}
    tbl.name = name
    tbl.rooms = {}
    tbl.exits = {}
    tbl.special = {}
    local rname, exits, stubs, doors, special, portals, door_up, door_down, coords, environment, roomChar
    for k,v in pairs(rooms) do
        rname = getRoomName(v)
        exits = getRoomExits(v)
        stubs = getExitStubs(v)
        doors = getDoors(v)
        special = getSpecialExitsSwap(v)
        portals = getRoomUserData(v,"portals") or ""
	environment = getRoomEnv(v)
	roomChar = getRoomChar(v)
        coords = {getRoomCoordinates(v)}
        tbl.rooms[v] = {name = rname, coords = coords, exits = exits, stubs = stubs, doors = doors, door_up = door_up,
            door_down = door_down, door_in = door_in, door_out = door_out, special = special, portals = portals, environment = environment, roomChar = roomChar}
        tmp = {}
        for k1,v1 in pairs(exits) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.exits[v] = tmp
        end
        tmp = {}
        for k1,v1 in pairs(special) do
            if not table.contains(rooms,v1) then
                tmp[k1] = {v1, getRoomName(v1)}
            end
        end
        if not table.is_empty(tmp) then
            tbl.special[v] = tmp
        end
    end
    local path = profilePath.."/"..string.gsub(string.lower(name),"%s","_")..".dat"
    table.save(path,tbl)
    map.echo("Area " .. name .. " exported to " .. path)
end

function map.import_area(name)
    name = profilePath .. "/" .. string.gsub(string.lower(name),"%s","_") .. ".dat"
    local tbl = {}
    table.load(name,tbl)
    if table.is_empty(tbl) then
        show_err("No file found")
    end
    local areas = getAreaTable()
    local areaID = areas[tbl.name] or addAreaName(tbl.name)
    local rooms = {}
    local ID
    for k,v in pairs(tbl.rooms) do
        ID = createRoomID()
        rooms[k] = ID
        addRoom(ID)
        setRoomName(ID,v.name)
        setRoomArea(ID,areaID)
        setRoomCoordinates(ID,unpack(v.coords))
        if type(v.stubs) == "table" then
            for i,j in pairs(v.stubs) do
                setExitStub(ID,j,true)
            end
        end
        for i,j in pairs(v.doors) do
            setDoor(ID,i,j)
        end
        setRoomUserData(ID,"portals",v.portals)
	setRoomEnv(ID,v.environment)
	setRoomChar(ID,v.roomChar)
    end
    for k,v in pairs(tbl.rooms) do
        for i,j in pairs(v.exits) do
            if rooms[j] then
                connect_rooms(rooms[k],rooms[j],i)
            end
        end
        for i,j in pairs(v.special) do
            if rooms[j] then
                addSpecialExit(rooms[k],rooms[j],i)
            end
        end
    end
    for k,v in pairs(tbl.exits) do
        for i,j in pairs(v) do
            if getRoomName(j[1]) == j[2] then
                connect_rooms(rooms[k],j[1],i)
            end
        end
    end
    for k,v in pairs(tbl.special) do
        for i,j in pairs(v) do
            addSpecialExit(k,j[1],i)
        end
    end
    map.fix_portals()
    map.echo("Area " .. tbl.name .. " imported from " .. name)
end

function map.set_recall()
    -- assigned the current room to be recall for the current character
    map.save.recall[map.character] = map.currentRoom
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Recall room set to: " .. getRoomName(map.currentRoom) .. ".")
end

function map.set_portal(name, is_auto)
    -- creates a new portal in the room
    if map.mapping then
        if not string.starts(name,"-f ") then
            find_portal = name
        else
            name = string.gsub(name,"^-f ","")
            force_portal = name
        end
        move_queue = {name}
        if not is_auto then
            send(name)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_mode(mode)
    -- switches mapping modes
    if not table.contains({"lazy","simple","normal","complex"},mode) then
        show_err("Invalid Map Mode, must be 'lazy', 'simple', 'normal' or 'complex'.")
    end
    map.set("mode", mode)
    map.echo("Current mode set to: " .. mode)
end

function map.start_mapping(area_name)
    -- starts mapping, and sets the current area to the given one, or uses the current one
    if not map.currentName then
        show_err("Room detection not yet working, see &lt;yellow&gt;map basics&lt;reset&gt; for guidance.")
    end
    local rooms
    move_queue = {}
    area_name = area_name ~= "" and area_name or nil
    if map.currentArea and not area_name then
        local areas = getAreaTableSwap()
        area_name = areas[map.currentArea]
    end
    if not area_name then
        show_err("You haven't started mapping yet, how should the first area be called? Set it with: &lt;yellow&gt;start mapping &lt;area name&gt;&lt;reset&gt;")
    end
    map.echo("Now mapping in area: " .. area_name)
    map.set("mapping", true)
    find_area(area_name)
    rooms = find_room(map.currentName, map.currentArea)
    if table.is_empty(rooms) then
        if map.currentRoom and getRoomName(map.currentRoom) == map.currentName then
            map.set_area(area_name)
        else
            create_room(map.currentName, map.currentExits, nil, {0,0,0})
        end
    elseif map.currentRoom and map.currentArea ~= getRoomArea(map.currentRoom) then
        map.set_area(area_name)
    end
end

function map.stop_mapping()
    map.set("mapping", false)
    map.echo("Mapping off.")
end

function map.clear_moves()
    local commands_in_queue = #move_queue
    move_queue = {}
    map.echo("Move queue cleared, "..commands_in_queue.." commands removed.")
end

function map.show_moves()
    map.echo("Moves: "..(move_queue and table.concat(move_queue, ', ') or '(queue empty)'))
end

function map.set_area(name)
    -- assigns the current room to the area given, creates the area if necessary
    if map.mapping then
        find_area(name)
        if map.currentRoom and getRoomArea(map.currentRoom) ~= map.currentArea then
            setRoomArea(map.currentRoom,map.currentArea)
            set_room(map.currentRoom)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.set_door(dir,status,one_way)
    -- adds a door on a given exit
    if map.mapping then
        if not map.currentRoom then
            show_err("Make Door: No room found.")
        end
        dir = exitmap[dir] or dir
        if not stubmap[dir] then
            show_err("Make Door: Invalid direction.")
        end
        status = (status ~= "" and status) or "closed"
        one_way = (one_way ~= "" and one_way) or "no"
        if not table.contains({"yes","no"},one_way) then
            show_err("Make Door: Invalid one-way status, must be yes or no.")
        end

        local exits = getRoomExits(map.currentRoom)
        local exit
        -- check handling of custom exits here
        for i = 13,#stubmap do
            exit = "exit " .. stubmap[i]
            exits[stubmap[i]] = tonumber(getRoomUserData(map.currentRoom,exit))
        end
        local target_room = exits[dir]
        if target_room then
            exits = getRoomExits(target_room)
            -- check handling of custom exits here
            for i = 13,#stubmap do
                exit = "exit " .. stubmap[i]
                exits[stubmap[i]] = tonumber(getRoomUserData(target_room,exit))
            end
        end
        if one_way == "no" and (target_room and exits[reverse_dirs[dir]] == map.currentRoom) then
            add_door(target_room,reverse_dirs[dir],status)
        end
        add_door(map.currentRoom,dir,status)
        map.echo(string.format("Adding %s door to the %s", status, dir))
    else
        map.echo("Not mapping",false,true)
    end
end

function map.shift_room(dir)
    -- shifts a room around on the map
    if map.mapping then
        dir = exitmap[dir] or (table.contains(exitmap,dir) and dir)
        if not dir then
            show_err("Shift Room: Exit not found")
        end
        local x,y,z = getRoomCoordinates(map.currentRoom)
        dir = stubmap[dir]
        local coords = coordmap[dir]
        x = x + coords[1]
        y = y + coords[2]
        z = z + coords[3]
        setRoomCoordinates(map.currentRoom,x,y,z)
        centerview(map.currentRoom)
        map.echo("Shifting room",true)
    else
        map.echo("Not mapping",false,true)
    end
end

local function check_link(firstID, secondID, dir)
    -- check to see if two rooms are connected in a given direction
    if not firstID then error("Check Link Error: No first ID",2) end
    if not secondID then error("Check Link Error: No second ID",2) end
    local name = getRoomName(firstID)
    local exits1 = table.union(getRoomExits(firstID),getRoomStubs(firstID))
    local exits2 = table.union(getRoomExits(secondID),getRoomStubs(secondID))
    local exit
    -- check handling of custom exits here
    for i = 13,#stubmap do
        exit = "exit " .. stubmap[i]
        exits1[stubmap[i]] = tonumber(getRoomUserData(firstID,exit))
        exits2[stubmap[i]] = tonumber(getRoomUserData(secondID,exit))
    end
    local checkID = exits2[reverse_dirs[dir]]
    local exits = {}
    for k,v in pairs(exits1) do
        table.insert(exits,k)
    end
    return checkID and check_room(checkID,name,exits)
end

function map.find_me(name, exits, dir, manual)
    -- tries to locate the player using the current room name and exits, and if provided, direction of movement
    -- if direction of movement is given, narrows down possibilities using previous room info
    if move ~= "recall" then move_queue = {} end
    -- find from room hash id - map.find_me(nil, nil, nil, false)
    if map.prompt.hash then
        local room = getRoomIDbyHash(map.prompt.hash)
        if room &gt; 0 then
            set_room(room)
            map.echo("Room found, ID: " .. room, true)
            return
        else
            map.echo("Room not found in map database!", not manual, true)
            return
        end
    end
    local check = dir and map.currentRoom and table.contains(exitmap,dir)
    name = name or map.currentName
    exits = exits or map.currentExits
    if not name and not exits then
        show_err("Room not found, complete room name and exit data not available.")
    end
    local rooms = find_room(name)
    local match_IDs = {}
    for k,v in pairs(rooms) do
        if check_room(k, name, exits) then
            table.insert(match_IDs,k)
        end
    end
    rooms = match_IDs
    match_IDs = {}
    if table.size(rooms) &gt; 1 and check then
        for k,v in pairs(rooms) do
            if check_link(map.currentRoom,v,dir) then
                table.insert(match_IDs,v)
            end
        end
    elseif random_move then
        for k,v in pairs(getRoomExits(map.currentRoom)) do
            if check_room(v,map.currentName,map.currentExits) then
                table.insert(match_IDs,v)
            end
        end
    end
    if table.size(match_IDs) == 0 then
        match_IDs = rooms
    end
    if table.index_of(match_IDs,map.currentRoom) then
        match_IDs = {map.currentRoom}
    end
    if not table.is_empty(match_IDs) and not find_portal then
        set_room(match_IDs[1])
        map.echo("Room found, ID: " .. match_IDs[1],true)
    elseif find_portal then
        if not table.is_empty(match_IDs) then
            map.echo("Found portal destination, linking rooms",false,false,true)
            addSpecialExit(map.currentRoom,match_IDs[1],find_portal)
            local portals = getRoomUserData(match_IDs[1],"portals") or ""
            portals = portals .. "," .. tostring(map.currentRoom)..":"..find_portal
            setRoomUserData(match_IDs[1],"portals",portals)
            set_room(match_IDs[1])
            map.echo("Room found, ID: " .. match_IDs[1],true)
        else
            map.echo("Creating portal destination",false,false,true)
            create_room(map.currentName, map.currentExits, nil, {getRoomCoordinates(map.currentRoom)})
        end
        find_portal = false
    elseif table.is_empty(match_IDs) then
        map.echo("Room not found in map database", not manual, true)
    end
end

function map.fix_portals()
    if map.mapping then
        -- used to clear and update data for portal back-referencing
        local rooms = getRooms()
        local portals
        for k,v in pairs(rooms) do
            setRoomUserData(k,"portals","")
        end
        for k,v in pairs(rooms) do
            for cmd,room in pairs(getSpecialExitsSwap(k)) do
                portals = getRoomUserData(room,"portals") or ""
                if portals ~= "" then portals = portals .. "," end
                portals = portals .. tostring(k) .. ":" .. cmd
                setRoomUserData(room,"portals",portals)
            end
        end
        map.echo("Portals Fixed")
    else
        map.echo("Not mapping",false,true)
    end
end

function map.merge_rooms()
    -- used to combine essentially identical rooms with the same coordinates
    -- typically, these are generated due to mapping errors
    if map.mapping then
        map.echo("Merging rooms")
        local x,y,z = getRoomCoordinates(map.currentRoom)
        local rooms = getRoomsByPosition(map.currentArea,x,y,z)
        local exits, portals, room, cmd, curportals
        local room_count = 1
        for k,v in pairs(rooms) do
            if v ~= map.currentRoom then
                if getRoomName(v) == getRoomName(map.currentRoom) then
                    room_count = room_count + 1
                    for k1,v1 in pairs(getRoomExits(v)) do
                        setExit(map.currentRoom,v1,stubmap[k1])
                        exits = getRoomExits(v1)
                        if exits[reverse_dirs[k1]] == v then
                            setExit(v1,map.currentRoom,stubmap[reverse_dirs[k1]])
                        end
                    end
                    for k1,v1 in pairs(getDoors(v)) do
                        setDoor(map.currentRoom,k1,v1)
                    end
                    for k1,v1 in pairs(getSpecialExitsSwap(v)) do
                        addSpecialExit(map.currentRoom,v1,k1)
                    end
                    portals = getRoomUserData(v,"portals") or ""
                    if portals ~= "" then
                        portals = string.split(portals,",")
                        for k1,v1 in ipairs(portals) do
                            room,cmd = unpack(string.split(v1,":"))
                            addSpecialExit(tonumber(room),map.currentRoom,cmd)
                            curportals = getRoomUserData(map.currentRoom,"portals") or ""
                            if not string.find(curportals,room) then
                                curportals = curportals .. "," .. room .. ":" .. cmd
                                setRoomUserData(map.currentRoom,"portals",curportals)
                            end
                        end
                    end
                    -- check handling of custom exits here for doors and exits, and reverse exits
                    for i = 13,#stubmap do
                        local door = "door " .. stubmap[i]
                        local tmp = tonumber(getRoomUserData(v,door))
                        if tmp then
                            setRoomUserData(map.currentRoom,door,tmp)
                        end
                        local exit = "exit " .. stubmap[i]
                        tmp = tonumber(getRoomUserData(v,exit))
                        if tmp then
                            setRoomUserData(map.currentRoom,exit,tmp)
                            if tonumber(getRoomUserData(tmp, "exit " .. reverse_dirs[stubmap[i]])) == v then
                                setRoomUserData(tmp, exit, map.currentRoom)
                            end
                        end
                    end
                    deleteRoom(v)
                end
            end
        end
        if room_count &gt; 1 then
            map.echo(room_count .. " rooms merged", true)
        end
    else
        map.echo("Not mapping",false,true)
    end
end

function map.findAreaID(areaname, exact)
    local areaname = areaname:lower()
    local list = getAreaTable()

    -- iterate over the list of areas, matching them with substring match.
    -- if we get match a single area, then return its ID, otherwise return
    -- 'false' and a message that there are than one are matches
    local returnid, fullareaname, multipleareas = nil, nil, {}
    for area, id in pairs(list) do
        if (not exact and area:lower():find(areaname, 1, true)) or (exact and areaname == area:lower()) then
            returnid = id
            fullareaname = area
            multipleareas[#multipleareas+1] = area
        end
    end

    if #multipleareas == 1 then
        return returnid, fullareaname
    else
        return nil, nil, multipleareas
    end
end

function map.echoRoomList(areaname, exact)
    local areaid, msg, multiples
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"
    if tonumber(areaname) then
        areaid = tonumber(areaname)
        msg = getAreaTableSwap()[areaid]
    else
        areaid, msg, multiples = map.findAreaID(areaname, exact)
    end
    if areaid then
        local roomlist, endresult = getAreaRooms(areaid) or {}, {}

        -- obtain a room list for each of the room IDs we got
        local getRoomName = getRoomName
        for _, id in pairs(roomlist) do
            endresult[id] = getRoomName(id)
        end
        roomlist[#roomlist+1], roomlist[0] = roomlist[0], nil
        -- sort room IDs so we can display them in order
        table.sort(roomlist)

        local echoLink, format, fg, echo = echoLink, string.format, fg, cecho
        -- now display something half-decent looking
        cecho(format("&lt;%s&gt;List of all rooms in &lt;%s&gt;%s&lt;%s&gt; (areaID &lt;%s&gt;%s&lt;%s&gt; - &lt;%s&gt;%d&lt;%s&gt; rooms):\n",
            listcolor, othercolor, msg, listcolor, othercolor, areaid, listcolor, othercolor, #roomlist, listcolor))
        -- use pairs, as we can have gaps between room IDs
        for _, roomid in pairs(roomlist) do
            local roomname = endresult[roomid]
            cechoLink(format("&lt;%s&gt;%7s",othercolor,roomid), 'map.speedwalk('..roomid..')',
                format("Go to %s (%s)", roomid, tostring(roomname)), true)
            cecho(format("&lt;%s&gt;: &lt;%s&gt;%s&lt;%s&gt;.\n", listcolor, othercolor, roomname, listcolor))
        end
    elseif not areaid and #multiples &gt; 0 then
        local allareas, format = getAreaTable(), string.format
        local function countrooms(areaname)
            local areaid = allareas[areaname]
            local allrooms = getAreaRooms(areaid) or {}
            local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
            return areac
        end
        map.echo("For which area would you want to list rooms for?")
        for _, areaname in ipairs(multiples) do
            echo("  ")
            setUnderline(true)
            cechoLink(format("&lt;%s&gt;%-40s (%d rooms)", othercolor, areaname, countrooms(areaname)),
                'map.echoRoomList("'..areaname..'", true)', "Click to view the room list for "..areaname, true)
            setUnderline(false)
            echo("\n")
        end
    else
        map.echo(string.format("Don't know of any area named '%s'.", areaname),false,true)
    end
    resetFormat()
end

function map.echoAreaList()
    local totalroomcount = 0
    local rlist = getAreaTableSwap()
    local listcolor, othercolor = "DarkSlateGrey","LightSlateGray"

    -- count the amount of rooms in an area, taking care to count the room in the 0th
    -- index as well if there is one
    -- saves the total room count on the side as well
    local function countrooms(areaid)
        local allrooms = getAreaRooms(areaid) or {}
        local areac = (#allrooms or 0) + (allrooms[0] and 1 or 0)
        totalroomcount = totalroomcount + areac
        return areac
    end

    local getAreaRooms, cecho, fg, echoLink = getAreaRooms, cecho, fg, echoLink
    cecho(string.format("&lt;%s&gt;List of all areas we know of (click to view room list):\n",listcolor))
    for id = 1,table.maxn(rlist) do
        if rlist[id] then
            cecho(string.format("&lt;%s&gt;%7d ", othercolor, id))
            fg(listcolor)
            echoLink(string.format("%-40s (%d rooms)",rlist[id],countrooms(id)), 'map.echoRoomList("'..id..'", true)',
                "View the room list for "..rlist[id], true)
            echo("\n")
        end
    end
    cecho(string.format("&lt;%s&gt;Total amount of rooms in this map: %s\n", listcolor, totalroomcount))
end

function map.search_timer_check()
    if find_prompt then
        map.echo("Prompt not auto-detected, use 'map prompt' to set a prompt pattern.",false,true)
        find_prompt = false
    end
end

function map.find_prompt()
    find_prompt = true
    map.echo("Searching for prompt.")
    send("\n", false)
    tempTimer(5, "map.search_timer_check()")
end

function map.make_prompt_pattern(str)
    if not str:starts("^") then str = "^"..str end
    map.save.prompt_pattern[map.character] = str
    find_prompt = false
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
    map.echo("Prompt pattern set: " .. str)
end

function map.make_ignore_pattern(str)
    map.save.ignore_patterns = map.save.ignore_patterns or {}
    if not table.contains(map.save.ignore_patterns,str) then
        table.insert(map.save.ignore_patterns,str)
        map.echo("Ignore pattern added: " .. str)
    else
        table.remove(map.save.ignore_patterns, table.index_of(map.save.ignore_patterns, str))
        map.echo("Ignore pattern removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

function map.make_move_method(str)
    map.save.move_methods = map.save.move_methods or {}
    if not table.contains(map.save.move_methods,str) then
        table.insert(map.save.move_methods,str)
        map.echo("Move method added: " .. str)
    else
        table.remove(map.save.move_methods, table.index_of(map.save.move_methods, str))
        map.echo("Move method removed: " .. str)
    end
    table.save(profilePath .. "/map downloads/map_save.dat",map.save)
end

local function grab_line()
    table.insert(lines,line)
    if map.save.prompt_pattern[map.character] and string.match(line, map.save.prompt_pattern[map.character]) then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt captured",true)
    end
    if find_prompt then
        for k,v in ipairs(map.configs.prompt_test_patterns) do
            if string.match(line,v) then
                map.save.prompt_pattern[map.character] = v
                table.save(profilePath .. "/map downloads/map_save.dat",map.save)
                find_prompt = false
                map.echo("Prompt found")
                break
            end
        end
    end
end

local function name_search()
    local room_name
    if map.configs.custom_name_search then
        room_name = mudlet.custom_name_search(lines)
    else
        local line_count = #lines + 1
        local cur_line, last_line
        local prompt_pattern = map.save.prompt_pattern[map.character]
        if not prompt_pattern then return end
        while not room_name do
            line_count = line_count - 1
            if not lines[line_count] then break end
            cur_line = lines[line_count]
            for k,v in ipairs(map.save.ignore_patterns) do
                cur_line = string.trim(string.gsub(cur_line,v,""))
            end
            if string.find(cur_line,prompt_pattern) then
                cur_line = string.trim(string.gsub(cur_line,prompt_pattern,""))
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif line_count == 1 then
                cur_line = string.trim(cur_line)
                if cur_line ~= "" then
                    room_name = cur_line
                else
                    room_name = last_line
                end
            elseif not string.match(cur_line,"^%s*$") then
                last_line = cur_line
            end
        end
        lines = {}
        room_name = room_name:sub(1,100)
    end
    return room_name
end

local function handle_exits(exits)
    local room = map.prompt.room or name_search()
    room = map.sanitizeRoomName(room)
    exits = map.prompt.exits or exits
    exits = string.lower(exits)
    exits = string.gsub(exits,"%a+", exitmap)
    if room then
        map.echo("Room Name Captured: " .. room, true)
        room = string.trim(room)
        capture_room_info(room, exits)
        map.prompt.room = nil
        map.prompt.exits = nil
    end
end

local continue_walk, timerID
continue_walk = function(new_room)
    if not walking then return end
    -- calculate wait time until next command, with randomness
    local wait = map.configs.speedwalk_delay or 0
    if wait &gt; 0 and map.configs.speedwalk_random then
        wait = wait * (1 + math.random(0,100)/100)
    end
    -- if no wait after new room, move immediately
    if new_room and map.configs.speedwalk_wait and wait == 0 then
        new_room = false
    end
    -- send command if we don't need to wait
    if not new_room then
        --handle script exits
        if string.starts(map.walkDirs[1], "script:") then
          map.walkDirs[1] = string.gsub(map.walkDirs[1], "script:", "")
          loadstring(table.remove(map.walkDirs,1))()
        else
          send(table.remove(map.walkDirs,1))
        end
        -- check to see if we are done
        if #map.walkDirs == 0 then
            walking = false
            speedWalkPath, speedWalkWeight = {}, {}
            raiseEvent("sysSpeedwalkFinished")
        end
    end
    -- make tempTimer to send next command if necessary
    if walking and (not map.configs.speedwalk_wait or (map.configs.speedwalk_wait and wait &gt; 0)) then
        if timerID then killTimer(timerID) end
        timerID = tempTimer(wait, function() continue_walk() end)
    end
end

function map.speedwalk(roomID, walkPath, walkDirs)
    roomID = roomID or speedWalkPath[#speedWalkPath]
    getPath(map.currentRoom, roomID)
    walkPath = speedWalkPath
    walkDirs = speedWalkDir
    if #speedWalkPath == 0 then
        map.echo("No path to chosen room found.",false,true)
        return
    end
    table.insert(walkPath, 1, map.currentRoom)
    -- go through dirs to find doors that need opened, etc
    -- add in necessary extra commands to walkDirs table
    local k = 1
    repeat
        local id, dir = walkPath[k], walkDirs[k]
        if exitmap[dir] or short[dir] then
            local door = check_doors(id, exitmap[dir] or dir)
            local status = door and door[dir]
            if status and status &gt; 1 then
                -- if locked, unlock door
                if status == 3 then
                    table.insert(walkPath,k,id)
                    table.insert(walkDirs,k,"unlock " .. (exitmap[dir] or dir))
                    k = k + 1
                end
                -- if closed, open door
                table.insert(walkPath,k,id)
                table.insert(walkDirs,k,"open " .. (exitmap[dir] or dir))
                k = k + 1
            end
        end
        k = k + 1
    until k &gt; #walkDirs
    if map.configs.use_translation then
        for k, v in ipairs(walkDirs) do
            walkDirs[k] = map.configs.lang_dirs[v] or v
        end
    end
    -- perform walk
    walking = true
    if map.configs.speedwalk_wait or map.configs.speedwalk_delay &gt; 0 then
        map.walkDirs = walkDirs
        continue_walk()
    else
        for _,dir in ipairs(walkDirs) do
           if string.starts(dir, "script:") then
              dir = string.gsub(dir, "script:", "")
              loadstring(dir)()
            else
              send(dir)
           end
        end
        walking = false
        raiseEvent("sysSpeedwalkFinished")
    end
end

function doSpeedWalk()
    if #speedWalkPath ~= 0 then
        raiseEvent("sysSpeedwalkStarted")
        map.speedwalk(nil, speedWalkPath, speedWalkDir)
    else
        map.echo("No path to chosen room found.",false,true)
    end
end

function map.pauseSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        raiseEvent("sysSpeedwalkPaused")
        map.echo("Speedwalking paused.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.resumeSpeedwalk(delay)
    if #speedWalkDir ~= 0 then
        map.find_me(nil, nil, nil, true)
        raiseEvent("sysSpeedwalkResumed")
        map.echo("Speedwalking resumed.")
        tempTimer(delay or 0, function() map.speedwalk(nil, speedWalkPath, speedWalkDir) end)
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.stopSpeedwalk()
    if #speedWalkDir ~= 0 then
        walking = false
        map.walkDirs, speedWalkDir, speedWalkPath, speedWalkWeight = {}, {}, {}, {}
        raiseEvent("sysSpeedwalkStopped")
        map.echo("Speedwalking stopped.")
    else
        map.echo("Not currently speedwalking.")
    end
end

function map.toggleSpeedwalk(what)
    assert(what == nil or what == "on" or what == "off", "map.toggleSpeedwalk wants 'on', 'off' or nothing as an argument")

    if what == "on" or (what == nil and walking) then
        map.pauseSpeedwalk()
    elseif what == "off" or (what == nil and not walking) then
        map.resumeSpeedwalk()
    end
end

local function check_version()
    downloading = false
    local path = profilePath .. "/map downloads/versions.lua"
    local versions = {}
    table.load(path, versions)
    local pos = table.index_of(versions, map.version) or 0
    if pos ~= #versions then
        enableAlias("Map Update Alias")
        if not map.silentUpdate then
          map.echo(string.format("The Generic Mapping Script is currently &lt;red&gt;%d&lt;reset&gt; versions behind.",#versions - pos))
          map.echo("To update now, please type: &lt;yellow&gt;map update&lt;reset&gt;")
        else
          map.updateVersion()
        end
    end
    map.update_timer = tempTimer(3600, [[map.checkVersion()]])
end

function map.checkVersion()
    if #getRooms() &gt; 0 then
      map.silentUpdate = false
    end    
    if map.update_timer then
        killTimer(map.update_timer)
        map.update_timer = nil
    end
    if not map.update_waiting and map.configs.download_path ~= "" then
        local path, file = profilePath .. "/map downloads", "/versions.lua"
        downloading = true
        downloadFile(path .. file, map.configs.download_path .. file)
        map.update_waiting = true
    end
end

local function update_version()
    downloading = false
    local path = profilePath .. "/map downloads/generic_mapper.xml"
    disableAlias("Map Update Alias")
    map.updatingMapper = true
    uninstallPackage("generic_mapper")
    installPackage(path)
    map.updatingMapper = nil
    if not map.silentUpdate then
      map.echo("Generic Mapping Script updated successfully.")
    end
end

function map.updateVersion()
    local path, file = profilePath .. "/map downloads", "/generic_mapper.xml"
    downloading = true
    downloadFile(path .. file, map.configs.download_path .. file)
end

function map.showMap(shown)
    local configs = map.configs.map_window
    shown = shown or not configs.shown
    map.configs.map_window.shown = shown
    map.silentUpdate = false
    local x, y, w, h, origin = configs.x, configs.y, configs.w, configs.h, configs.origin
    if string.find(origin,"bottom") then
        if y == 0 or y == "0%" then
            y = h
        end
        if type(y) == "number" then
            y = -y
        else
            y = "-"..y
        end
    end
    if string.find(origin,"right") then
        if x == 0 or x == "0%" then
            x = w
        end
        if type(x) == "number" then
            x = -x
        else
            x = "-"..x
        end
    end
    local mapper = Geyser.Mapper:new({name = "my_mapper", x = x, y = y, w = w, h = h})
    mapper:resize(w,h)
    mapper:move(x,y)
    if shown then
        mapper:show()
    else
        mapper:hide()
    end
end

-- some games embed an ASCII map on the same line, which messes up the room room name
-- extract the longest continuous piece of text from the line to be the room name
function map.sanitizeRoomName(roomtitle)
  -- sometimes we get 'nil' for a room title - ignore that silently
  if type(roomtitle) ~= "string" then
    return roomtitle
  end

  if not roomtitle:match("   ") then
    -- if the whole line does not contain a run of three consecutive spaces then
    -- consider the whole line as the room name; this was previously two spaces
    -- but some MUDs do have titles that are multiple (short) sentances AND
    -- put TWO spaces after a full-stop for the first (e.g. After the Plague MUD
    -- on telnet://atp.pedia.szote.u-szeged.hu:3000)
    return roomtitle
  end

  -- otherwise split the text up in double-spaced chunks and return the longest
  -- run of bytes found in those chunks
  local parts = roomtitle:split("  ")
  table.sort(parts, function(a,b) return #a &lt; #b end)
  local longestpart = parts[#parts]

  local trimmed = utf8.match(longestpart, "[%w ]+"):trim()
  return trimmed
end

function map.eventHandler(event, ...)
    if event == "onNewRoom" then
        handle_exits(arg[1])
        if walking and map.configs.speedwalk_wait then
            continue_walk(true)
        end
    elseif event == "onPrompt" then
        if map.prompt.exits and map.prompt.exits ~= "" then
            raiseEvent("onNewRoom")
        end
        print_wait_echoes()
        map.echo("Prompt Captured",true)
    elseif event == "onMoveFail" then
        map.echo("onMoveFail",true)
        table.remove(move_queue,1)
    elseif event == "onVisionFail" then
        map.echo("onVisionFail",true)
        vision_fail = true
        capture_room_info()
    elseif event == "onRandomMove" then
        map.echo("onRandomMove",true)
        random_move = true
        move_queue = {}
    elseif event == "onForcedMove" then
        map.echo("onForcedMove",true)
        capture_move_cmd(arg[1],arg[2]=="true")
    elseif event == "onNewLine" then
        grab_line()
    elseif event == "sysDataSendRequest" then
        capture_move_cmd(arg[1])
        -- check to prevent multiple version checks in a row without user intervention
        if map.update_waiting and map.update_timer then
            map.update_waiting = nil
        -- check to ensure version check cycle is started
        elseif not map.update_waiting and not map.update_timer then
            map.checkVersion()
        end
    elseif event == "sysDownloadDone" and downloading then
        local file = arg[1]
        if string.ends(file,"/map.dat") then
            loadMap(file)
            downloading = false
            map.echo("Map File Loaded.")
        elseif string.ends(file,"/versions.lua") then
            check_version()
        elseif string.ends(file,"/generic_mapper.xml") then
            update_version()
        end
    elseif event == "sysDownloadError" and downloading then
        local file = arg[1]
        if string.ends(file,"/versions.lua") and mudlet.translations.interfacelanguage == "zh_CN" then
            -- update to the current download path for chinese user
            if map.configs.download_path == "https://raw.githubusercontent.com/Mudlet/Mudlet/development/src/mudlet-lua/lua/generic-mapper" then
                map.configs.download_path = "https://gitee.com/mudlet/Mudlet/raw/development/src/mudlet-lua/lua/generic-mapper"
                map.checkVersion()
            end
        end
    elseif event == "sysLoadEvent" or event == "sysInstall" then
        config()
        raiseEvent("mapperScriptLoaded", "generic_mapper")
    elseif event == "mapOpenEvent" then
        if not help_shown and not map.save.prompt_pattern[map.character or ""] then
            map.find_prompt()
            send(map.configs.lang_dirs['look'], true)
            tempTimer(3, function() map.show_help("quick_start"); help_shown = true end)
        end
    elseif event == "mapStop" then
        map.set("mapping", false)
        walking = false
        map.echo("Mapping and speedwalking stopped.")
    elseif event == "sysManualLocationSetEvent" then
      set_room(arg[1])
    elseif event == "sysUninstallPackage" and not map.updatingMapper and arg[1] == "generic_mapper" then
        for _,id in ipairs(map.registeredEvents) do
            killAnonymousEventHandler(id)
        end
    end
end

map.registeredEvents = {
registerAnonymousEventHandler("sysDownloadDone", "map.eventHandler"),
registerAnonymousEventHandler("sysDownloadError", "map.eventHandler"),
registerAnonymousEventHandler("sysLoadEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysConnectionEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysInstall", "map.eventHandler"),
registerAnonymousEventHandler("sysDataSendRequest", "map.eventHandler"),
registerAnonymousEventHandler("onMoveFail", "map.eventHandler"),
registerAnonymousEventHandler("onVisionFail", "map.eventHandler"),
registerAnonymousEventHandler("onRandomMove", "map.eventHandler"),
registerAnonymousEventHandler("onForcedMove", "map.eventHandler"),
registerAnonymousEventHandler("onNewRoom", "map.eventHandler"),
registerAnonymousEventHandler("onNewLine", "map.eventHandler"),
registerAnonymousEventHandler("mapOpenEvent", "map.eventHandler"),
registerAnonymousEventHandler("mapStop", "map.eventHandler"),
registerAnonymousEventHandler("onPrompt", "map.eventHandler"),
registerAnonymousEventHandler("sysManualLocationSetEvent", "map.eventHandler"),
registerAnonymousEventHandler("sysUninstallPackage", "map.eventHandler")
}


function map.echon(what)
  moveCursorEnd("main") if getCurrentLine() ~= "" then echo"\n" end
  decho("&lt;112,229,0&gt;(&lt;73,149,0&gt;mapper&lt;112,229,0&gt;): &lt;255,255,255&gt;")
  cecho(tostring(what))
end

function map.roomexists(num)
  if not num then return false end
  if roomExists then return roomExists(num) end

  local s,m = pcall(getRoomArea, tonumber(num))
  return (s and true or false)
end

-- translates n to north and so forth
-- should incorporate generic_mappers exit_map, stub_map
local tempDir = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    i = "in",
    o = "out",
    ["in"] = "in"
}
local anytolongmap = {}
for s, l in pairs(tempDir) do anytolongmap[l] = l; anytolongmap[s] = l end

function map.anytolong(exit)

  return anytolongmap[exit]
end

function map.anytoshort(exit)
  local t = {
    n = "north",
    e = "east",
    s = "south",
    w = "west",
    ne = "northeast",
    se = "southeast",
    sw = "southwest",
    nw = "northwest",
    u = "up",
    d = "down",
    ["in"] = "in",
    out = "out"
  }
  local rt = {}
  for s,l in pairs(t) do
    rt[l] = s; rt[s] = s
  end

  return rt[exit]
end


function map.ranytolong(exit)
  local t = {
    n = "south",
    north = "south",
    e = "west",
    east = "west",
    s = "north",
    south = "north",
    w = "east",
    west = "east",
    ne = "southwest",
    northeast = "southwest",
    se = "northwest",
    southeast = "northwest",
    sw = "northeast",
    southwest = "northeast",
    nw = "southeast",
    northwest = "southeast",
    u = "down",
    up = "down",
    d = "up",
    down = "up",
    i = "out",
    ["in"] = "out",
    o = "in",
    out = "in"
  }

  return t[exit]
end

-- returns nil or the room number relative to this one
function map.relativeroom(from, dir)
  if not map.roomexists(from) then return end

  local exits = getRoomExits(tonumber(from))
  return exits[map.anytolong(dir)]
end

function map.roomFind(query, lines)
  if query:ends('.') then
    query = query:sub(1, -2)
  end
  local defaultLine = 30 -- this could this to a setting instead of a static number
  local result = map.searchRoom(query)
  if lines == 'all' then
    lines = table.size(result)
  end
  lines = (lines ~= '') and tonumber(lines) or defaultLine

  --create a new table (roomsTable) with keys and add areas to the table
  local roomsTable = {}
  for k, v in pairs(result) do
    local a = getRoomArea(k) or "unknown"
    roomsTable[#roomsTable + 1] = {num = k, area = a, name = v}
  end
  --sort roomsTable by area name
  table.sort(
    roomsTable,
    function(a, b)
      return a.area &lt; b.area
    end
  )
  --start displaying info
  if type(result) == "string" or not next(result) then
    cecho("&lt;grey&gt;You have no recollection of any room with that name.")
    return
  end
  cecho("&lt;DarkSlateGrey&gt;You know the following relevant rooms:\n")

  local i = 1
  if not tonumber(select(2, next(result))) then
    cecho(string.format("&lt;white&gt; %-10s%-40s%s\n", "ROOM ID", "ROOM NAME", "ROOM AREA"))
    for _, v in ipairs(roomsTable) do
      if i &gt; lines then
        break
      end
      roomid = tonumber(v.num)
      roomname = v.name
      roomarea = v.area
      cechoLink(
        string.format("&lt;cyan&gt; %-10s", roomid),
        'gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(string.format("&lt;LightSlateGray&gt;%-40s", string.sub(tostring(roomname), 1, 39)))
      cechoLink(
        string.format(
          "&lt;DarkSlateGrey&gt;%s&lt;DarkSlateGrey&gt;\n", getRoomAreaName(getRoomArea(roomid))
        ),
        [[map.echoPath(map.currentRoom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
      i = i + 1
    end
  else
    -- new style
    --- not sure what this new area code is but it doesn't seem to fire
    for roomname, roomid in pairs(result) do
      roomid = tonumber(roomid)
      cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
      cechoLink(
        "&lt;cyan&gt;" .. roomid,
        'gotoRoom(' .. roomid .. ')',
        string.format("Go to %s (%s)", roomid, tostring(roomname)),
        true
      )
      cecho(
        string.format(
          "&lt;DarkSlateGrey&gt;) in &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.", getRoomAreaName(getRoomArea(roomid))
        )
      )
      fg("DarkSlateGrey")
      echoLink(
        " &gt; Show path\n",
        [[map.echoPath(map.currentRoom, ]] .. roomid .. [[)]],
        "Display directions from here to " .. roomname,
        true
      )
      resetFormat()
    end
  end
  if table.size(result) &lt;= lines then
    cecho(string.format("&lt;DarkSlateGrey&gt;%d rooms found.\n", table.size(result)))
  else
    lastRoomQuery = query
    cechoLink(
      string.format(
        "&lt;DarkSlateGrey&gt;%d of %d rooms shown. Click to see all rooms.\n", lines, table.size(result)
      ),
      'map.roomFind(lastRoomQuery, "all")',
      string.format("Show all %d rooms.", table.size(result)),
      true
    )
  end
end

function map.searchRoom(what)
  local result = searchRoom(what)
  local realResult = {}
  for key, value in pairs(type(result) == "table" and result or {}) do
      -- both ways, because searchRoom can return either id-room name or the reverse
      if type(key) == "string" then
        realResult[key:ends(" (road)") and key:sub(1, -8) or key] = value
      else
        realResult[key] = value:ends(" (road)") and value:sub(1, -8) or value
      end
  end
  result = realResult
  return result
end


-- Lock Area

map.locked = map.locked or {}
map.lastLockSearch = map.lastLockSearch or nil

function map.doLockArea(search)
	local areaList
	if search ~= nil then
		local r = rex.new(string.lower(search))
		map.lastLockSearch = search
		for name, id in pairs(getAreaTable()) do
			if r:match(string.lower(name)) then
				areaList = areaList or {}
				areaList[name] = id
			end
		end
		if areaList == nil then
			map.echo("'" .. search .. "' did not match any known areas!")
			return
		end
	else
		map.lastLockSearch = nil
		areaList = getAreaTable()
	end

	for name, id in pairs(areaList) do
    map.echon(string.format("%-40s %s", name, " "))
--		map.echon(name .. string.rep(" ", 40 - string.len(name)))
		if not map.locked[id] then
			setFgColor(0, 200, 0)
			setUnderline(true)
			echoLink("Lock!", [[map.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', true )]], "Click to lock area '" .. name .. "'", true)
		else
			setFgColor(200, 0, 0)
			setUnderline(true)
			echoLink("Unlock!", [[map.lockArea( ']] .. name:gsub("'", [[\']]) .. [[', false )]], "Click to unlock area '" .. name .. "'", true)
		end
	end

	if not search then
		echo"\n\n" map.echo("Use &lt;green&gt;arealock &lt;area&gt;&lt;white&gt; to filter areas.")
	end
end

function map.lockArea(name, lock, dontreshow)
	local areas = getAreaTable()
	local rooms = getAreaRooms(areas[name]) or {}
    local lockRoom = lockRoom
    local count = 0
	for _, room in pairs(rooms) do
		lockRoom(room, lock)
        count = count + 1
	end

	map.locked[areas[name]] = lock and true or nil
	map.echo(string.format("Area '%s' %slocked! All %s room%s within it.", name, (lock and '' or 'un'), count, (count == 1 and '' or 's')))

	if not dontreshow then map.doLockArea(map.lastLockSearch) end
end


function map.roomLook(input)
  -- we can do a report with a number

  local function handle_number(num)
    -- compile all available data
    if not map.roomexists(num) then
      map.echo(num .. " doesn't seem to exist.")
      return
    end
    local s, areanum = pcall(getRoomArea, num)
    if not s then
      map.echo(areanum);
      return ;
    end
    local exits = getRoomExits(num)
    local name = getRoomName(num)
    local islocked = roomLocked(num)
    local weight = (getRoomWeight(num) and getRoomWeight(num) or "?")
    -- getRoomWeight is buggy in one of the versions, is actually linked to setRoomWeight and thus returns nil
    local exitweights = (getExitWeights and getExitWeights(num) or {})
    local coords = {getRoomCoordinates(num)}
    local specexits = getSpecialExits(num)
    local env = getRoomEnv(num)
    -- generic_mapper doesn't have support for environments like IRE_mapper
    local envname = (map.envidsr and map.envidsr[env]) or "?"
    -- generate a report
    map.echo(
      string.format(
        "Room: %s #: %d area: %s (%d)", name, num, getRoomAreaName(areanum), areanum
      )
    )
    map.echo(
      string.format(
        "Coordinates: x:%d, y:%d, z:%d, locked: %s, weight: %s",
        coords[1],
        coords[2],
        coords[3],
        (islocked and "yes" or "no"),
        tostring(weight)
      )
    )
    map.echo(
      string.format(
        "Environment: %s (%d)%s",
        tostring(envname),
        env,
        (getRoomUserData(num, "indoors") ~= '' and ", indoors" or '')
      )
    )
    map.echo(string.format("Exits (%d):", table.size(exits)))
    for exit, leadsto in pairs(exits) do
      echo(
        string.format(
          "  %s -&gt; %s (%d)%s%s\n",
          exit,
          getRoomName(leadsto),
          leadsto,
          (
            (getRoomArea(leadsto) or "?") == areanum and
            "" or
            " (in " ..
            (getRoomAreaName(getRoomArea(leadsto)) or "?") ..
            ")"
          ),
          (
            (not exitweights[map.anytoshort(exit)] or exitweights[map.anytoshort(exit)] == 0) and
            "" or
            " (weight: " ..
            exitweights[map.anytoshort(exit)] ..
            ")"
          )
        )
      )
    end
    -- display special exits if we got any
    if next(specexits) then
      map.echo(string.format("Special exits (%d):", table.size(specexits)))
      for leadsto, command in pairs(specexits) do
        if type(command) == "string" then
          echo(string.format("  %s -&gt; %s (%d)\n", command, getRoomName(leadsto), leadsto))
        else
          -- new format - exit name, command
          for cmd, locked in pairs(command) do
            if locked == '1' then
              cecho(
                string.format(
                  "&lt;DarkSlateGrey&gt;  %s -&gt; %s (%d) (locked)\n", cmd, getRoomName(leadsto), leadsto
                )
              )
            else
              echo(string.format("  %s -&gt; %s (%d)\n", cmd, getRoomName(leadsto), leadsto))
            end
          end
        end
      end
    end
    local message = "This room has the feature '%s'."
    for _, mapFeature in pairs(map.getRoomMapFeatures(num)) do
      map.echo(string.format(message, mapFeature))
    end
    -- actions we can do. This will be a short menu of sorts for actions
    map.echo("Stuff you can do:")
    echo("  ")
    echo("Clear all labels ")
    setUnderline(true)
    echoLink("(in area)", 'map.clearLabels(' .. areanum .. ')', '', true)
    setUnderline(false)
    echo(" ")
    setUnderline(true)
    echoLink(
      "(whole map)",
      [[
    if not map.clearinglabels then
      map.echo("Are you sure you want to clear all of your labels on this map? If yes, click the link again.")
      map.clearinglabels = true
    else
      map.clearLabels("map")
      map.clearinglabels = nil
    end
    ]],
      '',
      true
    )
    setUnderline(false)
    echo("\n")
  end

  -- see if we can do anything with the name

  local function handle_name(name)
    local result = map.searchRoom(name)
    if type(result) == "string" then
      cecho("&lt;grey&gt;You have no recollection of any room with that name.")
      return
    end
    -- if we got one result, then act on it
    if table.size(result) == 1 then
      if type(next(result)) == "number" then
        handle_number(next(result))
      else
        handle_number(select(2, next(result)))
      end
      return
    end
    -- if not, then ask the user to clarify which one would they want
    map.echo("Which room specifically would you like to look up?")
    if not select(2, next(result)) or not tonumber(select(2, next(result))) then
      for roomid, roomname in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;cyan&gt;" .. roomid,
          'map.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            getRoomAreaName(getRoomArea(roomid))
          )
        )
      end
    else
      for roomname, roomid in pairs(result) do
        roomid = tonumber(roomid)
        cecho(string.format("  &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt; (", tostring(roomname)))
        cechoLink(
          "&lt;cyan&gt;" .. roomid,
          'map.roomLook(' .. roomid .. ')',
          string.format("View room details for %s (%s)", roomid, tostring(roomname)),
          true
        )
        cecho(
          string.format(
            "&lt;DarkSlateGrey&gt;) in the &lt;LightSlateGray&gt;%s&lt;DarkSlateGrey&gt;.\n",
            getRoomAreaName(getRoomArea(roomid))
          )
        )
      end
    end
  end

  if not input then
    if not map.roomexists(map.currentRoom) then
      map.echo(map.currentRoom .. " doesn't seem to be mapped yet.")
      echo("\n")
      map.echo(string.format("version %s.", tostring(map.version)))
      return
    else
      input = map.currentRoom
    end
  end
  if tonumber(input) then
    handle_number(tonumber(input))
  else
    handle_name(input)
  end
  map.echo(string.format("version %s.", tostring(map.version)))
end


local function loadMapFeatures()
  local mapFeaturesString = getMapUserData("mapFeatures")
  local mapFeatures
  if mapFeaturesString and mapFeaturesString ~= "" then
    mapFeatures = yajl.to_value(mapFeaturesString)
  else
    mapFeatures = {}
  end
  return mapFeatures
end

local function saveMapFeatures(mapFeaturesToSave)
  local mapFeaturesString = yajl.to_string(mapFeaturesToSave)
  setMapUserData("mapFeatures", mapFeaturesString)
end

function map.createMapFeature(featureName, roomCharacter)
  if not featureName or featureName == "" then
    map.echo("Can't create an empty map feature.")
    return
  end
  if featureName:find("%d") then
    map.echo("Map feature names must not contain numbers.")
    return
  end
  roomCharacter = roomCharacter or ""
  if type(roomCharacter) ~= "string" then
    map.echo(
      "The new room character must be either a string or nil. " ..
      type(roomCharacter) ..
      " is not allowed."
    )
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    mapFeatures[lowerFeatureName] = roomCharacter
    saveMapFeatures(mapFeatures)
    map.echo(
      "Created map feature '" ..
      featureName ..
      "' with the room character '" ..
      roomCharacter ..
      "'."
    )
  else
    map.echo("A map feature with the name '" .. featureName .. "' already exists.")
    return
  end
  return true
end

function map.listMapFeatures()
  local mapFeatures = loadMapFeatures()
  map.echo("This map has the following features:")
  echo(string.format("    %-25s | %s\n", "feature name", "room character"))
  echo(string.format("    ---------------------------------------------\n"))
--  echo(string.format("    %s\n", string.rep("-", 45)))
  for featureName, roomCharacter in pairs(mapFeatures) do
    echo(string.format("    %-25s | %s\n", featureName, roomCharacter))
  end
  return true
end

function map.roomCreateMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    map.echo("Which feature would you like to create?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    map.echo(
      "A feature with name '" ..
      featureName ..
      "' does not exist. You need to use 'feature create' first."
    )
    return
  end
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentRoom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for creating a map feature on a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature already exists
  if table.contains(map.getRoomMapFeatures(roomId), lowerFeatureName) then
    map.echo("Room '" .. roomId .. "' has already map feature '" .. featureName .. "'.")
    return
  end
  -- create map feature in room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "true")
  map.echo(string.format("Map feature '%s' created in room number '%d'.", featureName, roomId))
  local featureRoomChar = mapFeatures[lowerFeatureName]
  if featureRoomChar ~= "" then
    setRoomChar(roomId, featureRoomChar)
    map.echo("The room now carries the room char '" .. featureRoomChar .. "'.")
  end
  return true
end

function map.roomDeleteMapFeature(featureName, roomId)
  -- checks for the feature name
  if not featureName then
    map.echo("Which feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentroom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for deleting a map feature from a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  -- check if feature exists
  local roomMapFeatures = map.getRoomMapFeatures(roomId)
  if not table.contains(roomMapFeatures, lowerFeatureName) then
    map.echo("Room '" .. roomId .. "' doesn't have map feature '" .. featureName .. "'.")
    return
  end
  -- delete map feature from room
  setRoomUserData(roomId, "feature-" .. lowerFeatureName, "")
  map.echo(string.format("Map feature '%s' deleted from room number '%d'.", featureName, roomId))
  -- now update room char if needed.
  -- first update current map features of this room
  roomMapFeatures = map.getRoomMapFeatures(roomId)
  local mapFeatures = loadMapFeatures()
  -- find out if we need to set a new room character
  if getRoomChar(roomId) == mapFeatures[lowerFeatureName] and getRoomChar(roomId) ~= "" then
    local index, otherRoomMapFeature
    -- find another usable room character
    repeat
      index, otherRoomMapFeature = next(roomMapFeatures, index)
    until not otherRoomMapFeature or mapFeatures[otherRoomMapFeature] ~= ""
    if otherRoomMapFeature then
      -- we found a usable room character, now set it
      local newRoomChar = mapFeatures[otherRoomMapFeature]
      setRoomChar(roomId, newRoomChar)
      map.echo("Using '" .. newRoomChar .. "' as new room character.")
    else
      -- we didn't find a usable room character, delete it.
      setRoomChar(roomId, "")
      map.echo("Deleted the current room character.")
    end
  end
  return true
end

function map.getRoomMapFeatures(roomId)
  -- checks for the room ID
  if not roomId then
    if not map.currentRoom then
      map.echo("Don't know where we are at the moment.")
      return
    end
    roomId = map.currentRoom
  else
    if type(roomId) ~= "number" then
      map.echo("Need a room ID as number for getting all map features of a room.")
      return
    end
  end
  if not getRoomName(roomId) then
    map.echo("Room number '" .. roomId .. "' does not exist.")
    return
  end
  local result = {}
  local mapFeatures = loadMapFeatures()
  for mapFeature in pairs(mapFeatures) do
    if getRoomUserData(roomId, "feature-" .. mapFeature) == "true" then
      result[#result + 1] = mapFeature
    end
  end
  return result
end

function map.deleteMapFeature(featureName)
  if not featureName or featureName == "" then
    map.echo("Which map feature would you like to delete?")
    return
  end
  local lowerFeatureName = featureName:lower()
  local mapFeatures = loadMapFeatures()
  if not mapFeatures[lowerFeatureName] then
    map.echo("Map feature '" .. featureName .. "' does not exist.")
    return
  end
  local roomsWithFeature = searchRoomUserData("feature-" .. lowerFeatureName, "true")
  for _, roomId in pairs(roomsWithFeature) do
    local deletionResult = map.roomDeleteMapFeature(lowerFeatureName, roomId)
    if not deletionResult then
      map.echo(
        "Something went wrong deleting the map feature '" ..
        featureName ..
        "' from all rooms. Deletion incomplete."
      )
      return
    end
  end
  mapFeatures[lowerFeatureName] = nil
  saveMapFeatures(mapFeatures)
  map.echo("Deleted map feature '" .. featureName .. "' from map.")
  return true
end

function map.getMapFeatures()
  return loadMapFeatures()
end


function map.echoPath(from, to)
  assert(tonumber(from) and tonumber(to), "map.echoPath: both from and to have to be room IDs")
  if getPath(from, to) then
    map.echo(
      "&lt;white&gt;Directions from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;:"
    )
    map.echo(table.concat(speedWalkDir, ", "))
    return map.speedWalkDir
  else
    map.echo(
      "&lt;white&gt;I can't find a way from &lt;yellow&gt;" ..
      string.upper(searchRoom(from)) ..
      " &lt;white&gt;to &lt;yellow&gt;" ..
      string.upper(searchRoom(to)) ..
      "&lt;white&gt;"
    )
  end
end


function map.listSpecialExits(filter)
  local c = 0
  map.echo("Listing special exits...")
  for area, areaname in pairs(getAreaTableSwap()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            if getRoomArea(exit) ~= area then
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d, in %s)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s -&lt;MediumSlateBlue&gt;&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d, in %s)\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  areaname,
                  cmd,
                  getRoomName(exit),
                  exit,
                  getRoomAreaName(getRoomArea(exit)) or '?'
                )
              )
            else
              cecho(
                string.format(
                  "&lt;dark_slate_grey&gt;%s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; &lt;MediumSlateBlue&gt;-&gt; &lt;coral&gt;%s &lt;MediumSlateBlue&gt;-&gt;&lt;dark_slate_grey&gt; %s &lt;LightSlateGray&gt;(%d)&lt;dark_slate_grey&gt; in %s\n",
                  getRoomName(rooms[i]),
                  rooms[i],
                  cmd,
                  getRoomName(exit),
                  exit,
                  areaname
                )
              )
            end
            c = c + 1
          end
        end
      end
    end
  end
  map.echo(
    string.format(
      "%d exits listed%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end

function map.delSpecialExits(filter)
  local c = 0
  for area, areaname in pairs(getAreaTableSwap()) do
    local rooms = getAreaRooms(area) or {}
    for i = 0, #rooms do
      local exits = getSpecialExits(rooms[i] or 0)
      if exits and next(exits) then
        for exit, cmd in pairs(exits) do
          if type(cmd) == "table" then
            cmd = next(cmd)
          end
          if cmd:match("^%d") then
            cmd = cmd:sub(2)
          end
          if not filter or cmd:lower():find(filter, 1, true) then
            local rid, action
            local originalExits = {}
            local e = getSpecialExits(rooms[i])
            for t, n in pairs(e) do
              rid = tonumber(t)
              for a, l in pairs(n) do
                action = tostring(a)
              end
              if not action:find(filter, 1, true) then
                originalExits[rid] = action
              end
            end
            clearSpecialExits(rooms[i])
            for rid, act in pairs(originalExits) do
              addSpecialExit(rooms[i], tonumber(rid), tostring(act))
            end
            c = c + 1
          end
        end
      end
    end
  end
  map.echo(
    string.format(
      "%d exits deleted%s.", c, (not filter and '' or ", with for the filter '" .. filter .. "'")
    )
  )
end


do
local oldsetExit = setExit

local exitmap = {
  n = 1,
  north = 1,
  ne = 2,
  northeast = 2,
  nw = 3,
  northwest = 3,
  e = 4,
  east = 4,
  w = 5,
  west = 5,
  s = 6,
  south = 6,
  se = 7,
  southeast = 7,
  sw = 8,
  southwest = 8,
  u = 9,
  up = 9,
  d = 10,
  down = 10,
  ["in"] = 11,
  out = 12
}

function map.setExit(from, to, direction)
  if type(direction) == "string" and not exitmap[direction] then return false end

  return oldsetExit(from, to, type(direction) == "string" and exitmap[direction] or direction)
end
end


function map.deleteArea(name, exact)
  local id, fname, ma = map.findAreaID(name, exact)
  if id then
    map.doareadelete(id)
  elseif next(ma) then
    map.echo("Which one of these specifically would you like to delete?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(name, [[map.deleteArea("]] .. name .. [[", true)]], "Delete " .. name, true)
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    map.echo("Don't know of that area.")
  end
end

-- the function actually doing area deletion

function map.doareadelete(areaid)
  map.deletingarea = {}
  local t = map.deletingarea
  local rooms = getAreaRooms(areaid)
  t.roomcount = table.size(rooms)
  t.roombatches = {}
  t.currentbatch = 1
  t.areaid = areaid
  t.areaname = getAreaTableSwap()[areaid]
  -- delete the area right away if there's nothing in it
  if t.roomcount == 0 then
    deleteArea(t.areaid)
    map.echo("All done! The area was already gone/empty.")
  end
  local rooms_per_batch = 100
  -- split up rooms into tables of tables, to be deleted in batches so
  -- that our print statements in between get a chance to be processed
  for batch = 1, t.roomcount, 100 do
    t.roombatches[#t.roombatches + 1] = {}
    local onebatch = t.roombatches[#t.roombatches]
    for inbatch = 1, 100 do
      onebatch[#onebatch + 1] = rooms[batch + inbatch]
    end
  end

  function map.deletenextbatch()
    local t = map.deletingarea
    if not t then
      return
    end
    local currentbatch = t.roombatches[t.currentbatchi]
    if currentbatch == nil then
      deleteArea(t.areaid)
      map.echo("All done! Deleted the '" .. t.areaname .. "' area.")
      map.deletingarea = nil
      centerview(map.currentRoom)
      return
    end
    local deleteRoom = deleteRoom
    for i = 1, #currentbatch do
      deleteRoom(currentbatch[i])
    end
    map.echo(
      string.format(
        "Deleted %d batch%s so far, %d left to go - %.2f%% done out of %d needed",
        t.currentbatchi,
        (t.currentbatchi == 1 and '' or 'es'),
        #t.roombatches - t.currentbatchi,
        (100 / #t.roombatches) * t.currentbatchi,
        #t.roombatches
      )
    )
    t.currentbatchi = t.currentbatchi + 1
    tempTimer(0.010, map.deletenextbatch)
  end

  t.currentbatchi = 1
  map.echo("Prepped room batches, starting deletion...")
  tempTimer(0.010, map.deletenextbatch)
end

function map.renameArea(name, exact)
  if not (map.currentroom or getRoomArea(map.currentRoom)) then
    map.echo("Don't know what area are we in at the moment, to rename it.")
  else
    map.echo(
      string.format(
        "Renamed %s to %s (%d).",
        getRoomAreaName(getRoomArea(map.currentRoom)),
        name,
        getRoomArea(map.currentRoom)
      )
    )
    setAreaName(getRoomArea(map.currentRoom), name)			
    centerview(map.currentRoom)
  end
end

function map.roomArea(otherroom, name, exact)
  local id, fname, ma
  if tonumber(name) then
    id = tonumber(name);
    fname = getAreaTableSwap()[id]
  else
    id, fname, ma = map.findAreaID(name, exact)
  end
  if fname == nil then
    map.echo("Area unknown, can't move room.")
    return
  end
  if otherroom ~= "" and not map.roomexists(otherroom) then
    map.echo("Room id " .. otherroom .. " doesn't seem to exist.")
    return
  elseif otherroom == "" and not map.roomexists(map.currentRoom) then
    map.echo("Don't know where we are at the moment.")
    return
  end
  otherroom = otherroom ~= "" and otherroom or map.currentRoom
  if id then
    setRoomArea(otherroom, id)
    map.echo(
      string.format(
        "Moved %s to %s (%d).",
        (getRoomName(otherroom) ~= "" and getRoomName(otherroom) or "''"),
        fname,
        id
      )
    )
    centerview(otherroom)
  elseif next(ma) then
    map.echo("Into which area exactly would you like to move the room?")
    fg("DimGrey")
    for _, name in ipairs(ma) do
      echo("  ")
      setUnderline(true)
      echoLink(
        name, [[map.roomArea('', "]] .. name .. [[", true)]], "Move the room to " .. name, true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
  else
    map.echo("Don't know of that area.")
  end
end


function map.clearLabels(areaid)
  local function clearlabels(areaid)
    local t = getMapLabels(areaid)
    if type(t) ~= "table" then
      return
    end
    for labelid, _ in pairs(t) do
      deleteMapLabel(areaid, labelid)
    end
  end

  if areaid == "map" then
    for areaid in pairs(getAreaTableSwap()) do
      clearlabels(areaid)
    end
    map.echo("Cleared labels in all of the map.")
    return
  end
  clearlabels(areaid)
  map.echo(string.format("Cleared all labels in '%s'.", map.getAreaTableSwap()[areaid]))
end

function map.roomLabel(input)
  if not createMapLabel then
    map.echo(
      "Your Mudlet doesn't support createMapLabel() yet - please update to 2.0-test3 or better."
    )
    return
  end
  local tk = input:split(" ")
  local room, fg, bg, message = map.currentRoom, "yellow", "red", "Some room label"
  -- input always have to be something, so tk[1] at least always exists
  if tonumber(tk[1]) then
    room = tonumber(table.remove(tk, 1))
    -- remove the number, so we're left with the colors or msg
  end
  -- next: is this a foreground color?
  if tk[1] and color_table[tk[1]] then
    fg = table.remove(tk, 1)
  end
  -- next: is this a background color?
  if tk[1] and color_table[tk[1]] then
    bg = table.remove(tk, 1)
  end
  -- the rest would be our message
  if tk[1] then
    message = table.concat(tk, " ")
  end
  -- if we haven't provided a room ID and we don't know where we are yet, we can't make a label
  if not room then
    map.echo("We don't know where we are to make a label here.")
    return
  end
  local x, y, z = getRoomCoordinates(room)
  local f1, f2, f3 = unpack(color_table[fg])
  local b1, b2, b3 = unpack(color_table[bg])
  -- finally: do it :)
  local lid = createMapLabel(getRoomArea(room), message, x, y, z, f1, f2, f3, b1, b2, b3)
  map.echo(
    string.format(
      "Created new label #%d '%s' in %s.", lid, message, getRoomAreaName(getRoomArea(room))
    )
  )
end

function map.areaLabels(where, exact)
  if not getMapLabels then
    map.echo(
      "Your Mudlet doesn't support getMapLabels() yet - please update to 2.0-test3 or better."
    )
    return
  end
  if (not where or not type(where) == "string") and not map.currentRoom then
    map.echo("For which area would you like to view labels?")
    return
  end
  if not where then
    exact = true
    where = getRoomAreaName(getRoomArea(map.currentRoom))
  end
  local areaid, msg, multiples = map.findAreaID(where, exact)
  if areaid then
    local t = getMapLabels(areaid)
    if type(t) ~= "table" or not next(t) then
      map.echo(string.format("'%s' doesn't seem to have any labels.", getRoomAreaName(areaid)))
      return
    end
    map.echo(string.format("Area labels for '%s'", getRoomAreaName(areaid)))
    for labelid, labeltext in pairs(t) do
      fg("DimGrey")
      echo(string.format("  %d) %s (", labelid, labeltext))
      fg("orange_red")
      setUnderline(true)
      echoLink(
        'delete',
        string.format(
          'deleteMapLabel(%d, %d); map.echo("Deleted label #' .. labelid .. '")', areaid, labelid
        ),
        "Delete label #" .. labelid .. " from " .. getRoomAreaName(areaid)
      )
      setUnderline(false)
      echo(")\n")
    end
    resetFormat()
  elseif not areaid and #multiples &gt; 0 then
    map.echo("Which area would you like to view exactly?")
    fg("DimGrey")
    for _, areaname in ipairs(multiples) do
      echo("  ");
      setUnderline(true)
      echoLink(
        areaname,
        'map.areaLabels("' .. areaname .. '", true)',
        "Click to view labels in " .. areaname,
        true
      )
      setUnderline(false)
      echo("\n")
    end
    resetFormat()
    return
  else
    map.echo(string.format("Don't know of any area named '%s'.", where))
    return
  end
end

</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<Script isActive="yes" isFolder="no">
			<name>XKX scripts</name>
			<packageName></packageName>
			<script>local is_full = false
local skill = "strike"

general_scripts = {
  skills_to_learn = "yc;;lian "..skill.." 50"
}

function reset_is_full()
  is_full = false
end
function basic_skill_is_higher()
  general_scripts.skills_to_learn = "yc;;lian "..skill.." 50"
end

function advanced_skill_is_higher()
  general_scripts.skills_to_learn = "yr;;lingwu "..skill..";;yr;;lingwu "..skill
end

function release_force()
  expandAlias("yr;;lingwu throwing")
  --expandAlias("yr;;do 4 learn huang for literate 50")
  --expandAlias("yc;;lian parry 50")
  --expandAlias(general_scripts.skills_to_learn)
end
function blood_force_full()
  is_full = true
end

function start_jiqi()
  is_full = false
  expandAlias("yr;;yc")
end

function yunqi()
  if is_full then
    echo("====\n")
    return
  end
  echo("---")
  expandAlias("yc")
end

function dazuo_max()
  if is_full then
    return
  end
  expandAlias("dm")  
end



local skill = "dodge"

function lingwu_basic_skill()
  return "lingwu "..skill
end

function lian_advanced_skill()
  return "lian "..skill.." 50"
end

function pick_one_skill()
  -- learning_index = math.fmod(learning_index,8)+1
  -- return skill_learning_set[learning_index]
  learning_index = math.fmod(learning_index,2)+1
  if learning_index == 1 then
    return "lian cuff 40"
  else
    return "lingwu cuff"
  end
end
-- split string
-- str = "庄子·杂篇·庚桑楚"
-- sep = "·"
-- return - {"庄子", "杂篇", "庚桑楚"}
function split_string(str, sep)
  local t = {}
  for part in string.gmatch(str, '([^'..sep..']+)') do
    table.insert(t, part)
  end
  return t
end

function eat_and_drink()
  send("drink;;drink")
  send("eat gan liang;;eat gan liang;;eat gan liang")
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>爵士任务</name>
			<packageName></packageName>
			<script>function identify_all_luren_with_true_clue()
  echo("----所有嫌疑人有----\n")
  for k, v in pairs(luren_set) do
    --local tclue = analyze_clue(v["msg"])
    --tag_luren_true(k, tclue)
    echo(k.."\t")
  end
  echo("\n------------------\n\n")
  
  for k, v in pairs(luren_set) do
    if v["msg"] == nil then
      echo(v.."没有捕捉到消息\n")
    end
    local tclue = analyze_clue(v["msg"])
    if tclue ~= nil then
      tag_luren_true(k, tclue)
    end
    
  end
end

function tag_luren_true(name, clue)
  local luren = luren_set[name]
  -- 路人A提供特征X，而路人A自身符合特征X，则路人A不是盗贼，特征X为真。
  if luren[clue["key"]] == clue["value"] then
    echo(""..name.."提供真特征 - "..clue["key"]..":"..clue["value"].." - 排除如下人等- \n")
    --echo("排除如下人等:\n")
    for k, v in pairs(luren_set) do   
      if k == name then
         echo(k.."\t")
         -- luren_set[k]["identified"]="negative" 
      elseif luren_set[k][clue["key"]] ~= clue["value"] then
         echo(k.."\t")
         --luren_set[k]["identified"]="negative"
      end   
    end
    echo("\n\n") 
  end
end

function identify_all_luren_with_opposite_clue()
  echo("\n*****************************\n")  
  for k, v in pairs(luren_set) do
    if v["msg"] == nil then
      echo(v.."没有捕捉到消息\n")
    end
    local tclue = analyze_clue(v["msg"])
    if tclue then
      tag_luren_false(k, tclue)
    end
  end
  echo("============================\n\n") 
end

function tag_luren_false(name, clue)
  local luren = luren_set[name]
  if luren[clue["key"]] ~= clue["value"] then
  --路人A提供特征X，那么除了路人A外，所有不符合特征X的其他路人都不是盗贼。
    echo(""..name.."提供反特征 - "..clue["key"]..":"..clue["value"].." - 排除如下人等- \n")
    for k, v in pairs(luren_set) do   
      if k ~= name and luren_set[k][clue["key"]] ~= clue["value"] then
        echo(k.."\t")
        --luren_set[k]["identified"]="negative"
      end   
    end  
    echo("\n\n") 
  end
end

function add_to_luren_set()
  echo("--")
  local person = table.deepcopy(current_luren)
  
  person["identified"] = "undefined"
  echo("++")
  luren_set[person["chinese_name"]]=person
  echo("==")
end

function analyze_luren_cloth(cloth)
  current_luren["cloth"]=cloth
  set_cloth_type(cloth)
  local color = analyze_fg_ansi_color(cloth)
  current_luren["cloth_color"] = color
  current_luren["cloth_color_type"] = color_type(color)
end

function analyze_luren_shoes(shoes)
  current_luren["shoes"]=shoes
  set_shoes_type(shoes)
  local color = analyze_fg_ansi_color(shoes)
  current_luren["shoes_color"] = color
  current_luren["shoes_color_type"] = color_type(color)
end

function color_type(color)
  if table.index_of({1,2,3,4,9,10,11,12}, color) then
    --echo("--&gt; color: ".. color)
    return "深色"
  else
    --echo("++&gt; color: ".. color)
    return "浅色"
  end 
end



function analyze_fg_ansi_color(text) 
  selectString(text, 1)
  if isAnsiFgColor( 1 ) then -- light black
    return 1
  elseif isAnsiFgColor( 2 ) then -- dark black
    return 2
  elseif isAnsiFgColor( 3 ) then -- light red
    return 3
  elseif isAnsiFgColor( 4 ) then -- dark red
    return 4
  elseif isAnsiFgColor( 5 ) then -- light green
    return 5
  elseif isAnsiFgColor( 6 ) then -- dark green
    return 6
  elseif isAnsiFgColor( 7 ) then -- light yellow
    return 7
  elseif isAnsiFgColor( 8 ) then --dark yellow
    return 8
  elseif isAnsiFgColor( 9 ) then -- light blue
    return 9
  elseif isAnsiFgColor( 10 ) then --dark blue
    return 10
  elseif isAnsiFgColor( 11 ) then -- light magenta
    return 11
  elseif isAnsiFgColor( 12 ) then -- dark magenta
    return 12
  elseif isAnsiFgColor( 13 ) then -- light cyan
    return 13
  elseif isAnsiFgColor( 14 ) then -- dark cyan
    return 14
  elseif isAnsiFgColor( 15 ) then --light white
    return 15
  elseif isAnsiFgColor( 16 ) then --dark white
    return 16
  else 
    return 0  --0 = default text color
  end  
end

function set_age_type(age)
  if string.find(age,"二十") then
    current_luren["age_type"] = 20
  elseif string.find(age,"三十") then  
    current_luren["age_type"] = 20
  elseif string.find(age,"四十") then  
    current_luren["age_type"] = 40
  elseif string.find(age,"五十") then  
    current_luren["age_type"] = 40
  elseif string.find(age,"六十") then  
    current_luren["age_type"] = 60
  elseif string.find(age,"七十") then  
    current_luren["age_type"] = 60
  elseif string.find(age,"八十") then  
    current_luren["age_type"] = 80                  
  else
    current_luren["age_type"] = 80
  end
end

function set_gender_type(gender)
  if string.find(gender,"他") then
    current_luren["gender_type"] = "男"
  else
    current_luren["gender_type"] = "女"
  end
end

function set_shoes_type(shoes)
  if string.find(shoes,"靴") then
    current_luren["shoes_type"] = "靴子"
  elseif string.find(shoes,"木屐") then
    current_luren["shoes_type"] = "凉鞋"
  elseif string.find(shoes,"草鞋") then
    current_luren["shoes_type"] = "凉鞋"
  elseif string.find(shoes,"破鞋") then
    current_luren["shoes_type"] = "凉鞋"
  else
    current_luren["shoes_type"] = "布鞋"  
  end            
end

function set_cloth_type(cloth)
  if string.find(cloth,"纱") then
    current_luren["cloth_type"] = "丝绸衣服"
  elseif string.find(cloth,"绸") then
    current_luren["cloth_type"] = "丝绸衣服"
  elseif string.find(cloth,"旗袍") then
    current_luren["cloth_type"] = "丝绸衣服"
  elseif string.find(cloth,"丝") then
    current_luren["cloth_type"] = "丝绸衣服"    
  elseif string.find(cloth,"鹤氅") then
    current_luren["cloth_type"] = "夹袄"
  elseif string.find(cloth,"长袄") then
    current_luren["cloth_type"] = "夹袄"
  elseif string.find(cloth,"棉袄") then
    current_luren["cloth_type"] = "夹袄"
  elseif string.find(cloth,"狼皮袄") then
    current_luren["cloth_type"] = "夹袄"
  elseif string.find(cloth,"短袄") then
    current_luren["cloth_type"] = "夹袄"
  elseif string.find(cloth,"比甲") then
    current_luren["cloth_type"] = "夹袄"   
  else  
    current_luren["cloth_type"] = "布衣"    
  end
end

function categorize_body(shape)
  if string.find(shape,"魁梧高大") then
    current_luren["height"] = "高"
    current_luren["shape"]="胖"
  elseif string.find(shape,"娇小玲珑") then  
    current_luren["height"] = "矮"
    current_luren["shape"]="瘦"
  elseif string.find(shape,"丰满矮小") then  
    current_luren["height"] = "矮"
    current_luren["shape"]="胖"
  elseif string.find(shape,"丰胸细腰，身材苗条挺拔") then  
    current_luren["height"] = "高"
    current_luren["shape"]="瘦"  
  elseif string.find(shape,"一根竹竿") then  
    current_luren["height"] = "高"
    current_luren["shape"]="瘦"  
  elseif string.find(shape,"矮小粗胖") then  
    current_luren["height"] = "矮"
    current_luren["shape"]="胖" 
  elseif string.find(shape,"高大魁梧") then  
    current_luren["height"] = "高"
    current_luren["shape"]="胖"      
  elseif string.find(shape,"矮小灵活") then  
    current_luren["height"] = "矮"
    current_luren["shape"]="瘦"                 
  end
end



function clear_luren_set()
  for k, v in pairs(luren_set) do   
    luren_set[k] = nil   
  end   
end

function analyze_clue(msg) 
  if msg == nil then
    return nil
  end
  local clue = {}
  if string.find(msg,"深色衣服") then 
    clue["key"] = "cloth_color_type"
    clue["value"] = "深色"
  elseif string.find(msg,"浅色衣服") then
    clue["key"] = "cloth_color_type"
    clue["value"] = "浅色"  
  elseif string.find(msg,"深色鞋子") then
    clue["key"] = "shoes_color_type"
    clue["value"] = "深色" 
  elseif string.find(msg,"浅色鞋子") then
    clue["key"] = "shoes_color_type"
    clue["value"] = "浅色"         
  elseif string.find(msg,"丝绸衣服") then
    clue["key"] = "cloth_type"
    clue["value"] = "丝绸衣服"    
  elseif string.find(msg,"布衣") then
    clue["key"] = "cloth_type"
    clue["value"] = "布衣"   
  elseif string.find(msg,"夹袄") then
    clue["key"] = "cloth_type"
    clue["value"] = "夹袄"   
  elseif string.find(msg,"靴子") then
    clue["key"] = "shoes_type"
    clue["value"] = "靴子"   
  elseif string.find(msg,"布鞋") then
    clue["key"] = "shoes_type"
    clue["value"] = "布鞋"    
  elseif string.find(msg,"凉鞋") then
    clue["key"] = "shoes_type"
    clue["value"] = "凉鞋"    
  elseif string.find(msg,"高个子") then
    clue["key"] = "height"
    clue["value"] = "高"     
  elseif string.find(msg,"矮个子") then
    clue["key"] = "height"
    clue["value"] = "矮"   
  elseif string.find(msg,"个子不太高") then
    clue["key"] = "height"
    clue["value"] = "矮"    
  elseif string.find(msg,"竹竿") then
    clue["key"] = "shape"
    clue["value"] = "瘦"   
  elseif string.find(msg,"猴子") then
    clue["key"] = "shape"
    clue["value"] = "瘦"   
  elseif string.find(msg,"偏瘦") then
    clue["key"] = "shape"
    clue["value"] = "瘦"   
  elseif string.find(msg,"有点胖") then
    clue["key"] = "shape"
    clue["value"] = "胖"   
  elseif string.find(msg,"有点发胖") then
    clue["key"] = "shape"
    clue["value"] = "胖"     
  elseif string.find(msg,"发福") then
    clue["key"] = "shape"
    clue["value"] = "胖"   
  elseif string.find(msg,"女") then
    clue["key"] = "gender_type"
    clue["value"] = "女"    
  elseif string.find(msg,"流浪汉") then
    clue["key"] = "gender_type"
    clue["value"] = "男"    
  elseif string.find(msg,"男") then
    clue["key"] = "gender_type"
    clue["value"] = "男"    
  elseif string.find(msg,"花白") then
    clue["key"] = "age_type"
    clue["value"] = "60"     
  elseif string.find(msg,"白发苍苍") then
    clue["key"] = "age_type"
    clue["value"] = "60"   
  elseif string.find(msg,"入棺材") then
    clue["key"] = "age_type"
    clue["value"] = "60"   
  elseif string.find(msg,"老大不小") then
    clue["key"] = "age_type"
    clue["value"] = "40"   
  elseif string.find(msg,"中年") then
    clue["key"] = "age_type"
    clue["value"] = "40"   
  elseif string.find(msg,"青年") then
    clue["key"] = "age_type"
    clue["value"] = "20"   
  elseif string.find(msg,"年轻") then
    clue["key"] = "age_type"
    clue["value"] = "20"   
  else
    --echo("无法分析线索："..msg)
    return nil
  end
  return clue
end


function set_message(name, msg)
  if msg and validate_message(msg) then
    luren_set[name]["msg"] = msg
  end
end


function identify_all_luren()
  for k, v in pairs(luren_set) do
    if v["msg"] == nil then
      echo(v.."没有捕捉到消息\n")
    end
    local tclue = analyze_clue(v["msg"])
    if tclue ~= nil then
      tag_luren(k, tclue)
    end
  end
end



function tag_luren(name, clue)
  local luren = luren_set[name]
  -- 路人A提供特征X，而路人A自身符合特征X，则路人A不是盗贼，特征X为真。
  if luren[clue["key"]] == clue["value"] then
    for k, v in pairs(luren_set) do   
      if k == name then
         luren_set[k]["identified"]="negative" 
      elseif luren_set[k][clue["key"]] ~= clue["value"] then
         luren_set[k]["identified"]="negative"
      end   
    end 
  else --路人A提供特征X，那么除了路人A外，所有不符合特征X的其他路人都不是盗贼。
    for k, v in pairs(luren_set) do   
      if k ~= name and luren_set[k][clue["key"]] ~= clue["value"] then
        luren_set[k]["identified"]="negative"
      end   
    end   
  end  
end

function list_suspect()
  for k, v in pairs(luren_set) do
    if v["identified"] ~= "negative" then
      echo("\n"..v["full_name"]..":"..v["chinese_name"]..":"..v["msg"])
    end
  end
end

function validate_message(msg)
  if msg == nil
    or string.find(msg,"你找错人了吧") 
    or string.find(msg,"敢拦住老子的去路")
    or string.find(msg,"你已经问过了") then
      return false
  end
  return true
end

function get_result()
  identify_all_luren()
  list_suspect()
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>武当任务</name>
			<packageName></packageName>
			<script>current_position = ""

wuxing = { 
    mu = {p_pos = "huo", n_pos = "tu", name="木"},
    huo = {p_pos = "tu", n_pos = "jin", name="火"},
    tu = {p_pos = "jin", n_pos = "shui", name="土"},
    jin = {p_pos = "shui", n_pos = "mu", name="金"},
    shui = {p_pos = "mu", n_pos = "huo", name="水"},
}

local function wuxing_ch_2_en(name)
  if name == "木" then 
    return "mu"
  elseif name == "火" then
    return "huo"
  elseif name == "土" then
    return "tu"
  elseif name == "金" then
    return "jin"
  else
    return "shui"   
  end   
end
-- direction = {正, 反}
-- position = {"木", "火", "土", "金", "水"}
-- return = new position as {"木", "火", "土", "金", "水"}
function initialize_wuxing(direction, position)
  wuxing_direction = direction
  current_position = wuxing_ch_2_en(position)
  return current_position
end

-- direction = {正, 反}
-- return = new position as {"木", "火", "土", "金", "水"}

function wuxing_zouwei(direction)
  local dir = "p_pos"
  if direction == "反" then dir = "n_pos" end
  current_position =  wuxing[current_position][dir]
  return current_position
end

jing_content = ""
function reset_jing_content()
  jing_content = ""
end
function build_jing_content(sentence)
  jing_content = jing_content..sentence
  --echo("build_jing_content =&gt; :"..jing_content.."\n")
end
function get_jing_content()
  return jing_content
end

songjing_info = {
  address = "", 
  book_name = "", -- 庄子·外篇「上卷」
  book_chapter = "", -- 庄子·外篇·天地
  page_number_in_chapter = 0,
  chapter_start_page_number = 0,
  chapter = "" -- 天地
}

function page_number()
  return songjing_info.chapter_start_page_number + songjing_info.page_number_in_chapter - 1
end

local function parse_jing(addr, book, whole_chapter, page)
  songjing_info.address = addr
  songjing_info.book_name = book
  songjing_info.book_chapter = whole_chapter
  songjing_info.page_number_in_chapter = page
  songjing_info.chapter = get_chapter(whole_chapter)
  songjing_info.chapter_start_page_number = find_zhuangzi_chapter_start_page(songjing_info.chapter)
end

local zhuangzi = {
  --庄子·外篇「下卷」(Zhuang zi)
  {start = 1, name = "秋水"},
  {start = 51, name = "至乐"},
  {start = 69, name = "达生"},
  {start = 107, name = "山木"},
  {start = 143, name = "田子方"},
  {start = 177, name = "知北游"},
  --庄子·杂篇「上卷」
  {start = 1, name = "庚桑楚"},
  {start = 42, name = "徐无鬼"},
  {start = 98, name = "则阳"},
  {start = 141, name = "外物"},
  {start = 168, name = "寓言"},
  --庄子·外篇「上卷」
  {start = 1, name = "骈拇"},
  {start = 4, name = "马蹄"},
  {start = 12, name = "胠箧"},
  {start = 31, name = "在宥"},
  {start = 66, name = "天地"},
  {start = 116, name = "天道"},
  {start = 151, name = "天运"},
  {start = 190, name = "刻意"},
  {start = 201, name = "缮性"},
  --庄子·内篇「下卷」(Zhuang zi)
  {start = 1, name = "人间世"},
  {start = 46, name = "德充符"},
  {start = 77, name = "大宗师"},
  {start = 124, name = "应帝王"},
  --庄子·杂篇「下卷」(Zhuang zi)
  {start = 1, name = "让王"},
  {start = 47, name = "盗跖"},
  {start = 99, name = "说剑"},
  {start = 114, name = "渔父"},
  {start = 139, name = "列御寇"},
  {start = 169, name = "天下"},
  --庄子·内篇「上卷」(Zhuang zi)
  {start = 169, name = "逍遥游"},
  {start = 169, name = "齐物论"},
  {start = 169, name = "养身主"}
}

local function get_chapter(whole_chapter)
  local str = split_string(whole_chapter, "·")
  local chapter = str[#str]
  echo("===&gt; chapter: "..chapter)
  return chapter
end

local function find_zhuangzi_chapter_start_page(chapter)
  for k, v in pairs(zhuangzi) do
    if chapter == v["name"] then
      echo("--&gt;page: "..v["start"].."\n")
      return v["start"]
    end
  end
  echo("===&gt; 没有发现章节: "..chapter.."\n")
  return nil
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>通用任务</name>
			<packageName></packageName>
			<script>function ask_job()
  local room = get_current_room_name()
  --echo("---&gt;room = "..room.."\n")
  send(node_city[room].ask_job)
end 

function job_done()
  local room = get_current_room_name()
  send(node_city[room].job_done)
end

function job_fail()
  local room = get_current_room_name()
  send(node_city[room].job_fail)
end

function back_to_yangzhou()
  local room = get_current_room_name()
  send(node_city[room].back_yangzhou)
end

function back_to_mrf()
  local room = get_current_room_name()
  echo("[通用任务]----&gt;::"..room)
  send(node_city[room].back_mrf)
end

function back_to_hz()
  local room = get_current_room_name()
  echo("[通用任务]----&gt;::"..room)
  send(node_city[room].back_hangzhou)
end

function back_to_pozhen()
  local room = get_current_room_name()
  echo("[通用任务]----&gt;::"..room)
  send(node_city[room].back_pozhen)
end

function back_to_changan()
  local room = get_current_room_name()
  send(node_city[room].back_changan)
end

function back_to_luoyang()
  local room = get_current_room_name()
  send(node_city[room].back_luoyang)
end

function back_to_hua()
  local room = get_current_room_name()
  send(node_city[room].back_hua)
end

function back_to_hsz()
  local room = get_current_room_name()
  send(node_city[room].back_hsz)
end

function back_to_mzj()
  local room = get_current_room_name()
  local back_path = mzj_path_back(room)
  if back_path == nil then
    expandAlias("@ mzj")
  else
    send(back_path)
  end
end

function short_cut_to(target)
  local room = get_current_room_name()
  if node_city[room].short_name == nil then
    echo(" ==&gt; no short name\n")
  else
    send("node walk "..node_city[room].short_name.."_"..target)
  end
end

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>陆家庄任务</name>
			<packageName></packageName>
			<script>lujiazhuang = {}
pozhen_task = {}
local pozhen_destination = {}

mrf_or_pozhen=""
function init_pozhen(city, room)
  pozhen_task.city = city
  pozhen_task.room = room
end

function pozhen_go()
  return pozhen_destination[pozhen_task.city].path
end

pozhen_destination["上饶"] = { path = "node walk pozhen_sr" }
pozhen_destination["临安府"] = { path = "node walk pozhen_hz" }
pozhen_destination["义兴县"] = { path = "node walk pozhen_yx" }
pozhen_destination["南昌"] = { path = "node walk pozhen_nc" }
pozhen_destination["嘉兴"] = { path = "node walk pozhen_jx" }
pozhen_destination["姑苏慕容"] = { path = "node walk pozhen_mr" }
pozhen_destination["岳王墓"] = { path = "node walk pozhen_yfm" }
pozhen_destination["岳阳"] = { path = "node walk pozhen_yy" }
pozhen_destination["建康府北城"] = { path = "node walk pozhen_jk" }
pozhen_destination["建康府南城"] = { path = "node walk lcf_cym" }
pozhen_destination["无锡"] = { path = "node walk pozhen_wx" }
pozhen_destination["明州"] = { path = "node walk pozhen_mz" }
pozhen_destination["杭州提督府"] = { path = "node walk pozhen_tdf" }
pozhen_destination["江州"] = { path = "node walk pozhen_jz" }
pozhen_destination["湖州"] = { path = "node walk pozhen_hzf" }
pozhen_destination["绍兴府"] = { path = "node walk pozhen_sx" }
pozhen_destination["苏州"] = { path = "node walk pozhen_mrf" }
pozhen_destination["衢州"] = { path = "node walk pozhen_qz" }
pozhen_destination["西湖"] = { path = "node walk pozhen_xhab" }
pozhen_destination["诸军统制府"] = { path = "node walk pozhen_mzj" }
pozhen_destination["铜官山"] = { path = "node walk pozhen_tgz" }
pozhen_destination["镇江"] = { path = "node walk pozhen_zj"}
pozhen_destination["长沙府"] = { path = "node walk pozhen_cs"}

local bagua = {
  qian = {"e","ne","w","s"},
  dui = {"n","sw","nw","s"},
  li = {"s","n","se","nw"},
  zhen = {"w","se","n","n"},
  xun = {"se","e","s","sw"},
  kan = {"ne","n","sw","nw"},
  gen = {"sw","w","w","s"},
  kun = {"nw","nw","s","e"}
}

step = 1
selected_gua = {}

function select_one_gua(gua)
  selected_gua = init_taohuazhen_task(gua)
end

function init_taohuazhen_task(gua)
  step = 1
  if gua == "乾天" then 
    return bagua.qian
  elseif gua == "兑泽" then
    return bagua.dui
  elseif gua == "离火" then
    return bagua.li
  elseif gua == "震雷" then
    return bagua.zhen
  elseif gua == "巽风" then
    return bagua.xun
  elseif gua == "坎水" then
    return bagua.kan
  elseif gua == "艮山" then
    return bagua.gen
  elseif gua == "坤地" then
    return bagua.kun
  end
end

function increase_step()
  step = step + 1
  if step == 5 then
    step = 1
  end
end

function take_one_step()
  send(selected_gua[step])
end

function restart_zhen()
  step = 1
  take_one_step()
end

lujiazhuang.gudong = ""
function identify_gudong(gudong)
  lujiazhuang.gudong = gudong
end

function map_gudong_to_id(name, id)
  if string.find(name, lujiazhuang.gudong) then
    lujiazhuang.gudong_id = id
    --echo("\n======= find:"..lujiazhuang.gudong_id.."--\n")
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>status_handler</name>
			<packageName></packageName>
			<script>-- stat = {
  -- food = -100,
  -- water= -100,
  -- jing = -100,
  -- qi = -100,
  -- neili = -100,
  -- jingli = -100,
  -- is_busy = ""
-- }

function status_handler()
  --display(gmcp)
  if gmcp.GMCP.Status.food then
    stat.food = gmcp.GMCP.Status.food
  end
  
  if gmcp.GMCP.Status.water then
    stat.water = gmcp.GMCP.Status.water
  end

  if gmcp.GMCP.Status.jing then
    stat.jing = gmcp.GMCP.Status.jing
  end
  
  if gmcp.GMCP.Status.qi then
    stat.qi = gmcp.GMCP.Status.qi
  end

  if gmcp.GMCP.Status.neili then
    stat.neili = gmcp.GMCP.Status.neili
  end

  if gmcp.GMCP.Status.jingli then
    stat.jingli = gmcp.GMCP.Status.jingli
  end

  if gmcp.GMCP.Status.is_busy then
    stat.is_busy = gmcp.GMCP.Status.is_busy
  end
  
end</script>
			<eventHandlerList>
				<string>gmcp.GMCP.Status</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>交战-perform</name>
			<packageName></packageName>
			<script>function taohua_perform_skills(qishi)
  local qs = qishi+0
  if qs ~= 0 and math.fmod(qs,8) == 0 then
    expandAlias("phf") 
  end
  if qs &gt; 8 then
    expandAlias("phf") 
  end
end

function wudang_perform_skills(qishi)
  if qishi+0 &gt;= 12 then
    expandAlias("pc") 
  end
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>move_handler</name>
			<packageName></packageName>
			<script>maps = {}
local city="wuxi"
local current_room = {}
local prev_room = {}
function move_handler()
  current_room = gmcp.GMCP.Move[1]
  display(current_room)
  echo(city.."[\""..current_room.short.."\"] = ")
  display(current_room.dir)

  -- if not current_room.result then
    -- return
  -- end 
  -- if room_exists(current_room.short) then
    -- return
  -- end  
  -- local room = {}
  -- room.short = current_room.short
  -- room.dirs = current_room.dir
  -- table.insert(maps, room)
-- end
end

</script>
			<eventHandlerList>
				<string>gmcp.GMCP.Move</string>
			</eventHandlerList>
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>围绕key room生产路径</name>
			<packageName></packageName>
			<script>
local current_room = {}

local current_key_room = ""
local exit_selected = ""
local path_from_key_room = ""
local path_back_to_key_room = ""
local back_path = ""

function get_current_room_name()
  return current_room.name
end

function set_xkx_room(name)
  echo(" \n -- in set_xkx_room :"..name.."\n")
  current_room.name = name
  if is_key_room(name) then
    cecho("\n===&gt; in setup_key_room: Key room changed to : &lt;green&gt;"..name.."\n")
    current_key_room = name
    reset_path()
  else
    update_path()    
  end
end

function go_dir(dir)
  echo("===&gt; in go_dir\n")
  exit_selected = dir
  send(dir,false)
end

function is_key_room(room)
  if room == nil then
    return false
  end 

  if node_city[room] ~= nil then
    return true
  else
    return false  
  end  
end

function reset_path()
    path_from_key_room = ""
    path_back_to_key_room = ""
    back_path = ""
end

function update_path()
    -- path_from_key_room = path_from_key_room..";;"..exit_selected
    -- path_back_to_key_room = path_pair[exit_selected]..";;"..path_back_to_key_room
end


function display_key_room()
  echo("current room: "..current_room.name.."\n")
  echo("key room: "..current_key_room.."\n")
  echo("path from key room to target: "..path_from_key_room.."\n")
  echo("path back to key room:"..path_back_to_key_room.."\n")
end

function keep_back_path()
  back_path = path_back_to_key_room
end

function back_to_key_room()
  send(back_path)
end

function show_back_path()
  echo(" -- current key room: "..current_key_room.."\n")
  echo(" --back path: "..back_path)
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>常量</name>
			<packageName></packageName>
			<script>
local node_list = {}

local current_room = {}

function set_city(city)
  current_room.city = city
  --echo("--&gt; current_room.city = "..current_room.city)
end

function set_room1(room)
  current_room.room = room
  --echo("--&gt; current_room.room = "..current_room.room)
end

function reset_node_list()
  node_list = {}
end

function create_city_node(city, room, path)
  local node = {} 
  node.city = city
  node.room = room
  node.path = path
  table.insert(node_list, node)
end

function display_node_list()
  echo("\ncity[\""..current_room.city.."\"] = { room = \""..current_room.room.."\",")
  echo("\n  adjacent_cities = {")
  for i = 1, #node_list do
    echo("\n\t")
    echo("{")
    echo("city = \""..node_list[i].city.."\", ")
    echo("room = \""..node_list[i].room.."\", ")
    echo("path = \""..node_list[i].path.."\"")
    echo("},")
  end
  echo("\n  }\n}")
end

path_pair = {
  e = "w",
  w = "e",
  n = "s",
  s = "n",
  u = "d",
  d = "u",
  eu = "wd",
  ed = "wu",
  wu = "ed",
  wd = "eu",
  su = "nd",
  sd = "nu",
  nu = "sd",
  nd = "su",
  enter = "out",
  out = "enter",
  ne = "sw",
  nw = "se",
  sw = "ne",
  se = "nw",
  ned = "swu",
  neu = "swd",
  nwd = "seu",
  nwu = "sed",
  swu = "ned",
  swd = "neu",
  seu = "nwd",
  sed = "nwu"
}

key_rooms =  {
 wdgc = {}, --"武当广场"
 zhengyang = {}, -- "正阳门"
 qingliang = {}, -- "清凉门"
 chaoyang = {}, -- "朝阳门"
 shence = {}, -- "神策门"
 jinhuafu = {},-- "金华府"
 mingzhou = {}, -- "明州"
 fuzhou = {}, -- "闽中"
 shaoxing = {}, -- "绍兴"
 quzhou = {}, -- "衢州"
 wuyi = {}, -- "武夷山"
 quanzhou = {}, -- "泉州"
 longquan = {}, -- "龙泉镇"
 chaozhou = {}, -- "潮州"
 yandang = {}, -- "雁荡山"
 wenzhou = {}, -- "温州"
 shangrao = {}, -- "上饶"
 qianshan = {}, -- "铅山"
 jnf = {}, -- "建宁府"
 xhab = {}, -- "西湖岸边"
 czf = {}, -- "处州府"
 jn_wx = {}, -- "无锡"
 jn_yx = {}, -- "义兴"
 szclt = {}, -- "沧浪亭"
 hzf = {}, -- "湖州"
 zjdk = {}, -- "京口渡"
 tgk = {}, -- "塘沽口"
 hj_xz = {}, -- "回疆小镇"
 lyhp = {}, -- "富贵花圃"
 cazqdj = {}, -- "朱雀大街"
 cajgm = {}, -- "金光门"
 qzxgc = {}, -- "小广场"
 mrf = {}, -- "慕容复"
 pozhen = {dir = "s"}, -- "归云庄"
 gyz = {}, -- "归云庄大门"
 yangziji = {}, -- "扬子津"
 zjdk = {}, -- "镇江渡口"
 hz = {}, -- "大理寺"
 lydk = {}, -- "孟津渡"
 yz = {}, -- "扬州"
 jydk = {}, -- "孟津渡对面"
 daizhou = {}, -- "代州"
 yueyang = {}, -- "岳阳"
 ferry = {}, -- "ferry"
 hhdk = {}, -- "黄河渡口"
 jkf = {}, -- "建康"
 thd = {}, -- "桃花岛"
 mr = {}, -- "燕子坞"
 tdf = {}, -- "提督府"
 ywm = {}, -- "岳王墓"
 zj = {}, -- "镇江"
 jz = {}, -- "江州"
 tgz = {}, -- "铜关镇"
 jx = {}, -- "嘉兴"
}

</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>韩世忠任务</name>
			<packageName></packageName>
			<script>_task = {}
function init_hsz(city, room)
  _task.city = city
  _task.room = room
end
local hsz_destination = {}

hsz_destination["上饶"] = { path = "node walk hsz_sr" }
hsz_destination["台州"] = { path = "node walk hsz_mz" }
hsz_destination["杭州提督府"] = { path = "node walk hsz_tdf" }
hsz_destination["归云庄"] = { path = "node walk hsz_gyz" }
hsz_destination["闽中"] = { path = "node walk hsz_fz" }
hsz_destination["建宁"] = { path = "node walk hsz_jn" }
hsz_destination["桃花岛"] = { path = "node walk hsz_mz" }
hsz_destination["龙泉镇"] = { path = "node walk hsz_lq" }
hsz_destination["温州府"] = { path = "node walk hsz_wz" }
hsz_destination["泉州"] = { path = "node walk hsz_qz" }
hsz_destination["雁荡山"] = { path = "node walk hsz_mz" }
hsz_destination["武夷山"] = { path = "node walk hsz_wy" }
hsz_destination["临安府"] = { path = "node walk hsz_hz" }
hsz_destination["处州府"] = { path = "node walk hsz_lq" }
hsz_destination["天台山"] = { path = "node walk hsz_mz" }
hsz_destination["义兴县"] = { path = "node walk hsz_yx" }
hsz_destination["南昌"] = { path = "node walk hsz_nc" }
hsz_destination["嘉兴"] = { path = "node walk hsz_jx" }
hsz_destination["姑苏慕容"] = { path = "node walk hsz_mr" }
hsz_destination["岳王墓"] = { path = "node walk hsz_yfm" }
hsz_destination["岳阳"] = { path = "node walk hsz_yy" }
hsz_destination["建康府北城"] = { path = "node walk hsz_jk" }
hsz_destination["建康府南城"] = { path = "node walk hsz_jk" }
hsz_destination["无锡"] = { path = "node walk hsz_sz" }
hsz_destination["明州"] = { path = "node walk hsz_mz" }
hsz_destination["杭州提督府"] = { path = "node walk hsz_tdf" }
hsz_destination["江州"] = { path = "node walk hsz_jz" }
hsz_destination["湖州"] = { path = "node walk hsz_hzf" }
hsz_destination["绍兴府"] = { path = "node walk hsz_sx" }
hsz_destination["苏州"] = { path = "node walk hsz_mrf" }
hsz_destination["衢州"] = { path = "node walk hsz_qz1" }
hsz_destination["西湖"] = { path = "node walk hsz_xhab" }
hsz_destination["诸军统制府"] = { path = "node walk hsz_mzj" }
hsz_destination["铜官山"] = { path = "node walk hsz_tgz" }
hsz_destination["镇江"] = { path = "node walk hsz_zj" }
hsz_destination["长沙府"] = { path = "node walk hsz_cs" }

function hsz_go()
  echo("city --&gt; ".._task.city)
  echo(" path ---&gt; :"..hsz_destination[_task.city].path.."\n")
  return send(hsz_destination[_task.city].path)
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>walk 节点</name>
			<packageName></packageName>
			<script>city = {}
city["苏州"] = { room = "沧浪亭",
  adjacent_cities = {
	{city = "归云庄", room = "归云庄大门", path = "guiyun"},
	{city = "建康府", room = "朝阳门", path = "jiankang"},
	{city = "嘉兴", room = "嘉兴城", path = "jiaxing"},
	{city = "姑苏慕容", room = "湖边", path = "murong"},
	{city = "铁岭关", room = "铁岭关", path = "tieling"},
	{city = "无锡", room = "盛巷桥", path = "wuxi"},
	{city = "镇江", room = "广场", path = "zhenjiang"},
  }
}
city["无锡"] = { room = "盛巷桥",
  adjacent_cities = {
	{city = "建康府", room = "朝阳门", path = "jiankang"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
	{city = "义兴县", room = "义兴县城", path = "yixing"},
	{city = "镇江", room = "广场", path = "zhenjiang"},
  }
}

city["归云庄"] = { room = "归云庄大门",
  adjacent_cities = {
	{city = "建康府南", room = "正阳门", path = "jiankang"},
	{city = "姑苏慕容", room = "湖边", path = "murong"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
  }
}

city["建康府"] = { room = "朝阳门",
  adjacent_cities = {
	{city = "建康府西", room = "清凉门", path = "qingliang"},
	{city = "建康府北", room = "神策门", path = "shence"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
	{city = "无锡", room = "盛巷桥", path = "wuxi"},
	{city = "义兴县", room = "义兴县城", path = "yixing"},
	{city = "建康府南", room = "正阳门", path = "zhengyang"},
	{city = "镇江", room = "广场", path = "zhenjiang"},
  }
}

city["嘉兴"] = { room = "嘉兴城",
  adjacent_cities = {
	{city = "湖州府", room = "广场", path = "huzhou"},
	{city = "建康府南", room = "正阳门", path = "jiankang"},
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "陆家庄", room = "陆家庄", path = "lujiazhuang"},
	{city = "姑苏慕容", room = "湖边", path = "murong"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
  }
}

city["姑苏慕容"] = { room = "湖边",
  adjacent_cities = {
	{city = "归云庄", room = "归云庄大门", path = "guiyun"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
  }
}

city["铁岭关"] = { room = "铁岭关",
  adjacent_cities = {
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
	{city = "无锡", room = "盛巷桥", path = "wuxi"},
  }
}

city["镇江"] = { room = "广场",
  adjacent_cities = {
	{city = "建康府", room = "朝阳门", path = "jiankang"},
	{city = "苏州", room = "沧浪亭", path = "suzhou"},
	{city = "无锡", room = "盛巷桥", path = "wuxi"},
	{city = "扬州京口渡", room = "京口渡", path = "yangzhou"},
  }
}

city["扬州京口渡"] = { room = "京口渡",
  adjacent_cities = {
	{city = "镇江", room = "广场", path = "zhenjiang"},
  }
}


city["建康府南"] = { room = "正阳门",
  adjacent_cities = {
	{city = "建康府", room = "朝阳门", path = "chaoyang"},
	{city = "归云庄", room = "归云庄大门", path = "guiyun"},
	{city = "湖州府", room = "广场", path = "huzhou"},
	{city = "嘉兴", room = "嘉兴城", path = "jiaxing"},
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "建康府西", room = "清凉门", path = "qingliang"},
	{city = "建康府北", room = "神策门", path = "shence"},
	{city = "义兴县", room = "义兴县城", path = "yixing"},
  }
}

city["建康府西"] = { room = "清凉门",
  adjacent_cities = {
	{city = "建康府", room = "朝阳门", path = "chaoyang"},
	{city = "建康府北", room = "神策门", path = "shence"},
	{city = "铜官山", room = "铜官镇", path = "tongguan"},
	{city = "建康府南", room = "正阳门", path = "zhengyang"},
  }
}

city["建康府北"] = { room = "神策门",
  adjacent_cities = {
	{city = "建康府", room = "朝阳门", path = "chaoyang"},
	{city = "建康府西", room = "清凉门", path = "qingliang"},
	{city = "长江南岸", room = "燕子矶", path = "yanziji"},
	{city = "建康府南", room = "正阳门", path = "zhengyang"},
  }
}

city["长江南岸"] = { room = "燕子矶",
  adjacent_cities = {
	{city = "建康府北", room = "神策门", path = "jiankang"},
  }
}

city["义兴县"] = { room = "义兴县城",
  adjacent_cities = {
	{city = "无锡", room = "盛巷桥", path = "wuxi"},
  {city = "建康府", room = "朝阳门", path = "jiankang-chaoyang"},
  {city = "建康府南", room = "正阳门", path = "jiankang-zhengyang"},
  }
}

city["湖州府"] = { room = "广场",
  adjacent_cities = {
	{city = "建康府南", room = "正阳门", path = "jiankang"},
	{city = "嘉兴", room = "嘉兴城", path = "jiaxing"},
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "铜官山", room = "铜官镇", path = "tongguan"},
  }
}

city["临安府"] = { room = "大理寺",
  adjacent_cities = {
	{city = "钱塘北渡口", room = "钱塘北渡口", path = "beidukou"},
	{city = "黄山", room = "歙县", path = "huangshan"},
	{city = "湖州府", room = "广场", path = "huzhou"},
	{city = "建康府南", room = "正阳门", path = "jiankang"},
	{city = "嘉兴", room = "嘉兴城", path = "jiaxing"},
	{city = "梅庄", room = "孤山梅庄", path = "meizhuang"},
	{city = "钱塘西渡口", room = "钱塘西渡口", path = "xidukou"},
	{city = "岳王墓", room = "岳飞墓", path = "yuewangmu"},
  }
}

city["钱塘北渡口"] = { room = "钱塘北渡口",
  adjacent_cities = {
	{city = "临安府", room = "大理寺", path = "linan"},
  }
}

city["梅庄"] = { room = "孤山梅庄",
  adjacent_cities = {
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "岳王墓", room = "岳飞墓", path = "yuewangmu"},
  }
}

city["钱塘西渡口"] = { room = "钱塘西渡口",
  adjacent_cities = {
	{city = "临安府", room = "大理寺", path = "linan"},
  }
}

city["黄山"] = { room = "歙县",
  adjacent_cities = {
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "祁门县", room = "祁门县", path = "qimen"},
  }
}

city["岳王墓"] = { room = "岳飞墓",
  adjacent_cities = {
	{city = "临安府", room = "大理寺", path = "linan"},
	{city = "梅庄", room = "孤山梅庄", path = "meizhuang"},
  }
}

city["铜官山"] = { room = "铜官镇",
  adjacent_cities = {
	{city = "湖州府", room = "广场", path = "huzhou"},
	{city = "江州", room = "中央广场", path = "jiangzhou"},
	{city = "建康府西", room = "清凉门", path = "jiankang"},
	{city = "祁门县", room = "祁门县", path = "qimen"},
  }
}

city["江州"] = { room = "中央广场",
  adjacent_cities = {
	{city = "南昌", room = "城中心", path = "nanchang"},
	{city = "祁门县", room = "祁门县", path = "qimen"},
	{city = "铅山县", room = "铅山县", path = "shangrao"},
	{city = "铜官山", room = "铜官镇", path = "tongguan"},
	{city = "信阳", room = "富池口古渡", path = "xinyang"},
	{city = "岳阳", room = "城中心", path = "yueyang"},
  }
}

city["南昌"] = { room = "城中心",
  adjacent_cities = {
	{city = "长沙", room = "走马楼", path = "changsha"},
	{city = "江州", room = "中央广场", path = "jiangzhou"},
	{city = "龙虎山", room = "正一观", path = "longhu"},
	{city = "庐陵", room = "嘉和门", path = "luling"},
	{city = "袁州", room = "袁水北岸", path = "yuanzhou"},
	{city = "岳阳", room = "城中心", path = "yueyang"},
  }
}

city["祁门县"] = { room = "祁门县",
  adjacent_cities = {
	{city = "黄山", room = "歙县", path = "huangshan"},
	{city = "江州", room = "中央广场", path = "jiangzhou"},
	{city = "铜官山", room = "铜官镇", path = "tongguan"},
  }
}

city["铅山县"] = { room = "铅山县",
  adjacent_cities = {
	{city = "江州", room = "中央广场", path = "jiangzhou"},
	{city = "龙虎山", room = "正一观", path = "longhu"},
	{city = "上饶县", room = "中央广场", path = "shangrao"},
  }
}

city["信阳"] = { room = "富池口古渡",
  adjacent_cities = {
	{city = "江州", room = "中央广场", path = "jiangzhou"},
  }
}

city["岳阳"] = { room = "城中心",
  adjacent_cities = {
	{city = "长沙", room = "走马楼", path = "changsha"},
	{city = "江州", room = "中央广场", path = "jiangzhou"},
	{city = "荆州府", room = "陵矶", path = "jingzhou"},
	{city = "南昌", room = "城中心", path = "nanchang"},
  }
}

city["长沙"] = { room = "走马楼",
  adjacent_cities = {
	{city = "衡山", room = "山门", path = "hengshan"},
	{city = "衡州", room = "青草桥头", path = "hengzhou"},
	{city = "南昌", room = "城中心", path = "nanchang"},
	{city = "袁州", room = "袁水北岸", path = "yuanzhou"},
	{city = "岳阳", room = "城中心", path = "yueyang"},
  }
}

city["荆州府"] = { room = "陵矶",
  adjacent_cities = {
	{city = "岳阳", room = "城中心", path = "yueyang"},
  }
}

city["上饶县"] = { room = "中央广场",
  adjacent_cities = {
	{city = "铅山县", room = "铅山县", path = "qianshan"},
	{city = "衢州府", room = "北广场", path = "quzhou"},
	{city = "仙霞岭", room = "关顶", path = "xianxia"},
  }
}

city["衢州府"] = { room = "北广场",
  adjacent_cities = {
	{city = "上饶县", room = "中央广场", path = "shangrao"},
	{city = "金华府", room = "金华府", path = "shaoxing"},
	{city = "乌溪江边", room = "乌溪江边", path = "xianxia"},
  }
}

city["乌溪江边"] = { room = "乌溪江边",
  adjacent_cities = {
	{city = "衢州府", room = "北广场", path = "quzhou"},
  }
}

city["金华府"] = { room = "金华府",
  adjacent_cities = {
	{city = "临安府东", room = "钱塘东渡口", path = "linan"},
	{city = "衢州府", room = "北广场", path = "quzhou"},
	{city = "绍兴府", room = "八字桥", path = "shaoxing"},
	{city = "天台县", room = "市口", path = "tiantai"},
  }
}

city["绍兴府"] = { room = "八字桥",
  adjacent_cities = {
	{city = "金华府", room = "金华府", path = "jinhua"},
	{city = "临安府东", room = "钱塘东渡口", path = "linan"},
	{city = "明州", room = "鼓楼", path = "mingzhou"},
	{city = "天台县", room = "市口", path = "tiantai"},
  }
}

city["临安府东"] = { room = "钱塘东渡口",
  adjacent_cities = {
	{city = "金华府", room = "金华府", path = "jinhua"},
	{city = "明州", room = "鼓楼", path = "mingzhou"},
	{city = "绍兴府", room = "八字桥", path = "shaoxing"},
  }
}

city["明州"] = { room = "鼓楼",
  adjacent_cities = {
	{city = "临安府东", room = "钱塘东渡口", path = "linan"},
	{city = "绍兴府", room = "八字桥", path = "shaoxing"},
	{city = "台州府", room = "灵江西岸", path = "taizhou"},
	{city = "天台县", room = "市口", path = "tiantai"},
	{city = "雁荡山", room = "碧霄峰", path = "yandang"},
  }
}

city["台州府"] = { room = "灵江西岸",
  adjacent_cities = {
	{city = "明州", room = "鼓楼", path = "mingzhou"},
	{city = "天台县", room = "市口", path = "tiantai"},
  }
}

city["天台县"] = { room = "市口",
  adjacent_cities = {
	{city = "金华府", room = "金华府", path = "jinhua"},
	{city = "明州", room = "鼓楼", path = "mingzhou"},
	{city = "绍兴府", room = "八字桥", path = "shaoxing"},
	{city = "台州府", room = "灵江西岸", path = "taizhou"},
	{city = "天台山", room = "弥勒殿", path = "tiantaishan"},
	{city = "雁荡山", room = "碧霄峰", path = "yandang"},
  }
}

city["天台山"] = { room = "弥勒殿",
  adjacent_cities = {
	{city = "天台县", room = "市口", path = "tiantai"},
  }
}

city["雁荡山"] = { room = "碧霄峰",
  adjacent_cities = {
	{city = "处州府", room = "中央广场", path = "chuzhou"},
	{city = "明州", room = "鼓楼", path = "mingzhou"},
	{city = "灵江南岸", room = "灵江南岸", path = "taizhou"},
	{city = "天台县", room = "市口", path = "tiantai"},
	{city = "瓯江北岸", room = "瓯江北岸", path = "wenzhou"},
  }
}

city["瓯江北岸"] = { room = "瓯江北岸",
  adjacent_cities = {
	{city = "处州府", room = "中央广场", path = "chuzhou"},
  }
}

city["处州府"] = { room = "中央广场",
  adjacent_cities = {
	{city = "龙泉镇瓯江北岸", room = "瓯江北岸", path = "longquan"},
	{city = "瓯江北岸", room = "瓯江北岸", path = "wenzhou"},
	{city = "雁荡山", room = "碧霄峰", path = "yandang"},
  }
}

city["龙泉镇瓯江北岸"] = { room = "瓯江北岸",
  adjacent_cities = {
	{city = "处州府", room = "中央广场", path = "chuzhou"},
  }
}

city["龙泉镇瓯江南岸"] = { room = "瓯江南岸",
  adjacent_cities = {
	{city = "龙泉镇", room = "水井", path = "longquan"},
  }
}

city["龙泉镇"] = { room = "水井",
  adjacent_cities = {
	{city = "龙泉镇瓯江南岸", room = "瓯江南岸", path = "chuzhou"},
	{city = "龙虎山", room = "正一观", path = "longhu"},
	{city = "武夷山", room = "九龙窠", path = "wuyi"},
	{city = "仙霞岭", room = "关顶", path = "xianxia"},
  }
}


city["武夷山"] = { room = "九龙窠",
  adjacent_cities = {
	{city = "建宁府北津", room = "北津", path = "jianning"},
	{city = "龙泉镇", room = "水井", path = "longquan"},
	{city = "泉州", room = "城中心", path = "quanzhou"},
  }
}

city["建宁府北津"] = { room = "北津",
  adjacent_cities = {
	{city = "泉州", room = "城中心", path = "quanzhou"},
	{city = "武夷山", room = "九龙窠", path = "wuyi"},
  }
}

city["西镇渡口"] = { room = "西镇",
  adjacent_cities = {
	{city = "建宁府", room = "南街头", path = "jianning"},
  }
}

city["建宁府"] = { room = "南街头",
  adjacent_cities = {
	{city = "福州", room = "城中心", path = "fuzhou"},
	{city = "西镇渡口", room = "西镇", path = "xizhen"},
  }
}

city["福州"] = { room = "城中心",
  adjacent_cities = {
	{city = "建宁府", room = "南街头", path = "jianning"},
	{city = "莆田", room = "中心广场", path = "putian"},
	{city = "泉州", room = "城中心", path = "quanzhou"},
	{city = "温州", room = "集市", path = "wenzhou"},
  }
}

city["莆田"] = { room = "中心广场",
  adjacent_cities = {
	{city = "福州", room = "城中心", path = "fuzhou"},
	{city = "泉州", room = "城中心", path = "quanzhou"},
  }
}

city["泉州"] = { room = "城中心",
  adjacent_cities = {
	{city = "福州", room = "城中心", path = "fuzhou"},
	{city = "建宁府北津", room = "北津", path = "jianning"},
	{city = "晋江东岸", room = "晋江东岸", path = "jinjiang"},
	{city = "南少林", room = "山门", path = "nanshaolin"},
	{city = "莆田", room = "中心广场", path = "putian"},
	{city = "武夷山", room = "九龙窠", path = "wuyi"},
  }
}

city["南少林"] = { room = "山门",
  adjacent_cities = {
	{city = "潮州", room = "中央广场", path = "chaozhou"},
	{city = "泉州", room = "城中心", path = "quanzhou"},
  }
}

city["潮州"] = { room = "中央广场",
  adjacent_cities = {
	{city = "晋江西岸", room = "晋江西岸", path = "jinjiang"},
	{city = "南少林", room = "山门", path = "nanshaolin"},
	{city = "圣峰嶂", room = "山间小路", path = "shengfeng"},
  }
}

city["晋江西岸"] = { room = "晋江西岸",
  adjacent_cities = {
	{city = "潮州", room = "中央广场", path = "chaozhou"},
  }
}

city["晋江东岸"] = { room = "晋江东岸",
  adjacent_cities = {
	{city = "泉州", room = "城中心", path = "quanzhou"},
  }
}

city["圣峰嶂"] = { room = "山间小路",
  adjacent_cities = {
	{city = "潮州", room = "中央广场", path = "chaozhou"},
	{city = "圣峰嶂西部", room = "山间小路", path = "xi"},
  }
}

city["圣峰嶂西部"] = { room = "山间小路",
  adjacent_cities = {
	{city = "圣峰嶂", room = "山间小路", path = "dong"},
	{city = "广州府", room = "市口", path = "guangzhou"},
  }
}

city["广州府"] = { room = "市口",
  adjacent_cities = {
	{city = "老林", room = "老林尽头", path = "laolin"},
	{city = "圣峰嶂", room = "山间小路", path = "shengfeng"},
  }
}

city["老林"] = { room = "老林尽头",
  adjacent_cities = {
	{city = "广州府", room = "市口", path = "guangzhou"},
  }
}

city["衡山"] = { room = "山门",
  adjacent_cities = {
	{city = "长沙", room = "走马楼", path = "changsha"},
	{city = "衡州", room = "青草桥头", path = "hengzhou"},
  }
}

city["衡州"] = { room = "青草桥头",
  adjacent_cities = {
	{city = "长沙", room = "走马楼", path = "changsha"},
	{city = "衡山", room = "山门", path = "hengshan"},
	{city = "苗疆", room = "苗岭边缘", path = "miaojiang"},
	{city = "五岭", room = "湘江渡口", path = "wuling"},
  }
}

city["袁州"] = { room = "袁水北岸",
  adjacent_cities = {
	{city = "长沙", room = "走马楼", path = "changsha"},
	{city = "南昌", room = "城中心", path = "nanchang"},
  }
}


city["苗疆"] = { room = "苗岭边缘",
  adjacent_cities = {
	{city = "衡州", room = "青草桥头", path = "hengyang"},
  }
}

city["五岭"] = { room = "湘江渡口",
  adjacent_cities = {
	{city = "衡州", room = "青草桥头", path = "hengzhou"},
  }
}

city["庐陵"] = { room = "嘉和门",
  adjacent_cities = {
	{city = "龙虎山", room = "正一观", path = "longhu"},
	{city = "南昌", room = "城中心", path = "nanchang"},
	{city = "袁州", room = "鼓楼", path = "yuanzhou"},
	{city = "越城岭山口", room = "山间道", path = "yuechengling"},
  }
}

city["龙虎山"] = { room = "正一观",
  adjacent_cities = {
	{city = "龙泉镇", room = "水井", path = "longquan"},
	{city = "庐陵", room = "嘉和门", path = "luling"},
	{city = "南昌", room = "城中心", path = "nanchang"},
	{city = "上饶县", room = "铅山县", path = "shangrao"},
	{city = "仙霞岭", room = "关顶", path = "xianxia"},
	{city = "袁州", room = "鼓楼", path = "yuanzhou"},
  }
}

city["仙霞岭"] = { room = "关顶",
  adjacent_cities = {
	{city = "龙虎山", room = "正一观", path = "longhu"},
	{city = "龙泉镇", room = "水井", path = "longquan"},
	{city = "衢州府", room = "乌溪江南岸", path = "quzhou"},
	{city = "上饶县", room = "中央广场", path = "shangrao"},
  }
}

city["越城岭山口"] = { room = "山间道",
  adjacent_cities = {
	{city = "庐陵", room = "嘉和门", path = "luling"},
	{city = "衡州湘江东岸", room = "湘江东岸", path = "xiangjiang"},
  }
}

city["衡州湘江东岸"] = { room = "湘江东岸",
  adjacent_cities = {
	{city = "越城岭山口", room = "山间道", path = "luling"},
  }
}</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>孟之经</name>
			<packageName></packageName>
			<script>mzj = {}

local mzj_room = {}

mzj_room["正阳门"] = { path = "node walk mzj_jkzym", back_to_meng = "north;northwest;west;north;north;north;north"}
mzj_room["三山街"] = { path = "node walk mzj_jkssj", back_to_meng = "east;north;north;north;north;east;east;east"}
mzj_room["三山门"] = {path = "node walk mzj_jkssm", back_to_meng = "east;east;north;north;north;north;east;east;east"}
mzj_room["亲军营"] = {path = "node walk mzj_jkqjy", back_to_meng = "northwest;west;north;north;north;north"}

mzj_room["云来客栈"] = {path = "node walk mzj_jkylkz", back_to_meng = "north;east;north;north;east;east;east"}
mzj_room["内桥"] = {path = "node walk mzj_jknq", back_to_meng = "north;north;east;east;east"}
mzj_room["南大街"] = {path = "node walk mzj_jkndj", back_to_meng = "north;north;north;east;east;east"}
mzj_room["圣府"] = {path = "node walk mzj_jksf", back_to_meng = "east;north;north;north;north;north"}

mzj_room["城南官道"] = {path = "node walk mzj_jkcngd3", back_to_meng = "north;north;north;north;north;north;north;east;east;east"}
mzj_room["大中街"] = {path = "node walk mzj_jkdzj", back_to_meng = "east;east;north;north;north;north;north"}
mzj_room["太平门"] = {path = "node walk mzj_jktpm", back_to_meng = "southeast;southeast;west;west;west"}
mzj_room["小巷"] = {path = "node walk mzj_jkxx", back_to_meng = "se;do 3 w"}

mzj_room["建康府"] = {path = "node walk mzj_jkf", back_to_meng = "east;north;north;north;east;east;east"}
mzj_room["建康府南城宠物店"] = {path = "node walk mzj_jkcwd", back_to_meng = "e;n;e;e;e"} 
mzj_room["承恩寺"] = {path = "node walk mzj_jkces", back_to_meng = "west;north;north;north;east;east;east"}
mzj_room["朝阳门"] = {path = "node walk mzj_jkcym", back_to_meng = "w;w;w"}
mzj_room["正阳门"] = {path = "node walk mzj_jkzym", back_to_meng = "north;northwest;west;north;north;north;north"}
mzj_room["淮清桥"] = {path = "node walk mzj_jkhqq", back_to_meng = "do 5 n"}

mzj_room["聚宝门"] = {path = "node walk mzj_jkjbm", back_to_meng = "do 6 n;do 3 e"}
mzj_room["药铺"] = {path = "node walk mzj_jkyp", back_to_meng = "east;east;north;north;east;east;east"}
mzj_room["贡院"] = {path = "node walk mzj_jkgy", back_to_meng = "s;e;do 5 n"}
mzj_room["通济门"] = {path = "node walk mzj_jktjm", back_to_meng = "w;do 5 n"}

mzj_room["金陵镖局"] = {path = "node walk mzj_jkjlbj", back_to_meng = "e;do 5 n;"}
mzj_room["镇淮桥"] = {path = "node walk mzj_jkzhq", back_to_meng = "north;north;north;north;north;east;east;east"}
mzj_room["长街"] = {path = "node walk mzj_jkcj", back_to_meng = "do 3 e"}

function mzj_path_back(room)
  if mzj_room[room] ~= nil then
    return mzj_room[room].back_to_meng
  else
    echo("=== 不存在这个mzj房间\n")
    return nil
  end   
end

function mzj_to_waiting_room(room)
  local path = mzj_room[room].path
  if path == nil then      
    echo(" == 需要补充这个地点 - "..room)
  else
    send(path)  
  end  
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>node 节点 - 任务</name>
			<packageName></packageName>
			<script>node_city = {}

node_city["孟之经"] = {
    short_name = "mzj",
    back_mrf = "node walk mzj_mrf",
    back_pozhen = "node walk mzj_pozhen",
    back_hsz = "node walk mzj_hsz",
    ask_job = "ask meng about job", 
    job_done = "ask meng about finish", 
    job_fail = "ask meng about fail",  
}
node_city["万安塔"] = {
    short_name = "wat",
    ask_job = "set wimpy 0;;jiali 0;;ask ke about 进塔",
    job_done = "qiao luo", 
    job_fail = "qiao luo",
    back_pozhen = "node walk wat_yz",
    back_yangzhou = "node walk wat_yz",
    back_mrf = "node walk wat_yz",
    back_hsz = "node walk wat_yz",  
}
      
node_city["韩世忠"] = {
    short_name = "hsz",
    ask_job = "ask han about job;;unset forced_act;;set wimpy 50;;jiali 0",
    job_done = "ask han about finish", 
    job_fail = "ask han about fail",
    back_pozhen = "node walk hsz_pozhen",
    back_yangzhou = "node walk hsz_zjdk3",
}
         
node_city["正阳门"] = {
    back_mrf = "walk chaoyang",
    back_pozhen = "walk guiyun"
}
        
node_city["清凉门"] = {
    back_mrf = "walk chaoyang",
    back_pozhen = "walk zhengyang"    
}
    
node_city["朝阳门"] = {
    back_mrf = "walk suzhou",
    back_pozhen = "walk zhengyang"
}
           
node_city["神策门"] = {
    back_mrf = "walk chaoyang",
    back_pozhen = "walk zhengyang"    
}
node_city["金华府"] = {
    back_mrf = "walk quzhou",
    back_pozhen = "walk quzhou"    
}
   
node_city["明州"] = {
    short_name = "mz",
    back_mrf = "node walk mz_mrf",
    back_pozhen = "node walk mz_mrf",
    back_hsz = "node walk mz_hsz"    
}
    
node_city["闽中"] = {
    short_name = "fz",
    back_mrf = "node walk fz_mrf",
    back_pozhen = "node walk fz_pozhen",
    back_hsz = "node walk fz_hsz",    
}

node_city["绍兴"] = {
    back_mrf = "walk jinhua",
    back_pozhen = "walk jinhua"    
}

node_city["衢州"] = {
    back_mrf = "walk shangrao",
    back_pozhen = "walk shangrao"    
}
     
node_city["武夷山"] = {
    back_mrf = "walk quanzhou",
    back_pozhen = "walk quanzhou"    
}
   
node_city["泉州"] = {
    short_name = "qz",
    back_mrf = "node walk qz_mrf",
    back_pozhen = "node walk qz_pozhen",
    back_hsz = "node walk qz_hsz2"    
}
    
node_city["龙泉镇"] = {
    back_mrf = "walk wuyi",
    back_pozhen = "walk wuyi"    
}

node_city["潮州"] = {
    short_name = "cz",
    back_mrf = "node walk cz_mrf",
    back_pozhen = "node walk cz_pozhen",
    back_hsz = "node walk cz_hsz",
    ask_job = "ask xing about job", 
    job_done = "ask xing about finish", 
    job_fail = "ask xing about fail",    
}
     
node_city["雁荡山"] = {
    back_mrf = "walk mingzhou",
    back_pozhen = "walk mingzhou"    
}
   
node_city["温州"] = {
    back_mrf = "walk fuzhou",
    back_pozhen = "walk fuzhou"
}
 
node_city["上饶"] = {
    back_mrf = "walk qianshan",
    back_pozhen = "walk qianshan"    
}

node_city["铅山"] = {
    back_mrf = "walk jiangzhou",
    back_pozhen = "walk jiangzhou"    
}
       
node_city["建宁府"] = {
    short_name = "jn",
    back_mrf = "node walk jn_mrf",
    back_pozhen = "node walk jn_pozhen"    
}
node_city["西湖岸边"] = {
    short_name = "xhab",
    back_mrf = "node walk xhab_mrf",
    back_pozhen = "node walk xhab_pozhen",
    back_hsz = "node walk xhab_hsz"    
}
      
node_city["处州府"] = {
    back_mrf = "walk yandang",
    back_pozhen = "walk yandang"  
}

node_city["盛巷桥"] = {
    back_mrf = "walk suzhou",
    back_pozhen = "walk suzhou"    
}

node_city["义兴"] = {
    back_mrf = "walk wuxi",
    back_pozhen = "walk wuxi"
}
  
node_city["沧浪亭"] = {
    short_name = "szclt",
    back_yangzhou = "node walk sz_zjdk",
    back_hua = "node walk sz_zjdk",
    back_hangzhou = "s;;s;;ne;;node walk mrf_hz",
    back_pozhen = "node walk szclt_pozhen"    
}
node_city["湖州"] = {
    short_name = "hzf",
    back_yangzhou = "node walk hzf_mrf",
    back_hua = "node walk hzf_pozhen",
    back_mrf = "node walk hzf_mrf",
    back_pozhen = "node walk hzf_pozhen",    
}

node_city["京口渡"] = {
    short_name = "zjdk",
    ask_job = "ask shao gong about jiang;;enter",
    back_yangzhou = "walk yangzhou",
    back_hangzhou = "node walk zjdk_hz",
    back_pozhen = "node walk zjdk_pozhen",
    back_mrf = "node walk zjdk_mrf",
    back_hsz = "node walk zjdk_hsz",    
}
     
node_city["塘沽口"] = {}
    
node_city["回疆小镇"] = {}
node_city["富贵花圃"] = {
    back_changan = "w;;s;;s;;node walk ly_ca",
    back_yangzhou = "w;;s;;s;;node walk ly_yz"    
}
   
node_city["朱雀大街"] = {
    back_luoyang = "node walk ca_ly",
    back_yangzhou = "node walk ca_yz"    
}

node_city["金光门"] = {
    back_changan = "node walk jgm_ca"
}

node_city["小广场"] = {
    ask_job = "ask hua about job",
    back_changan = "w;;w;;s;;walk changan",
    back_yangzhou = "w;;w;;s;;walk huijiang"    
}
    
node_city["慕容复"] = {
    short_name = "mrf",
    ask_job = "ask pu about job;;unset forced_act;;jiali 0;;set wimpy 40", 
    job_done = "give pu xin", 
    job_fail = "ask pu about fail",
    back_hangzhou = "node walk mrf_hz",
    back_yangzhou = "node walk mrf_zjdk",
    back_pozhen = "node walk mrf_pozhen",
    back_hsz = "node walk mrf_hsz"    
}

node_city["归云庄"] = {
    short_name = "pozhen",
    ask_job = "ask lu about pozhen;;set forced_act;;jiali max;;set wimpy 0", 
    job_done = "ask lu about 破阵奖励;;tell feixuex 治疗", 
    job_fail = "ask lu about 破阵失败",
    back_hangzhou = "node walk pozhen_hz",
    back_yangzhou = "node walk pozhen_zjdk",
    back_mrf = "node walk pozhen_mrf",
    back_hsz = "node walk pozhen_hsz",    
}

node_city["归云庄大门"] = {
    short_name = "gyz",
    back_hangzhou = "node walk gyz_hz",
    back_pozhen = "node walk gyz_lcf",
    back_mrf = "node walk gyz_mrf"    
}
  
node_city["扬子津"] = {
    ask_job = "ask shao gong about jiang;;enter",
    back_yangzhou = "walk yangzhou",    
}

node_city["镇江渡口"] = {
    short_name = "zjdk",
    ask_job = "ask shao gong about jiang;;enter",
    back_yangzhou = "walk yangzhou",
    back_hangzhou = "node walk zjdk_hz",
    back_pozhen = "node walk zjdk_pozhen",
    back_mrf = "node walk zjdk_mrf",
    back_hsz = "node walk zjdk_hsz",    
}

node_city["大理寺"] = {
    short_name = "hz",
    ask_job = "ask zhang about job", 
    job_done = "give zhang core", 
    job_fail = "ask zhang about 失败",
    back_yangzhou = "node walk hz_zjdk",
    back_pozhen = "node walk hz_pozhen",
    back_mrf = "node walk hz_mrf"
}
node_city["孟津渡"] = {
    ask_job = "ask shao gong about 过河;;enter"
}

node_city["扬州"] = {
    short_name = "yz",
    back_changan = "node walk yz_ca",
    back_hua = "node walk yz_qinz",
    back_mrf = "walk zhenjiang",
    back_pozhen = "walk zhenjiang",    
}

node_city["孟津渡对面"] = {
    ask_job = "ask shao gong about 过河;;enter"
}
node_city["代州"] = {
    short_name = "dz",
    back_yangzhou = "node walk dz_jydk"
}

node_city["岳阳"] = {
    short_name = "yy",
    back_hangzhou = "node walk yy_laf"
}
    
node_city["黄河渡口"] = {
    ask_job = "ask shao gong about 过河;;enter"
}
  
node_city["建康"] = {
    short_name = "jk",
    back_hangzhou = "node walk jk_hz",
    back_pozhen = "node walk jk_pozhen",
    back_mrf = "node walk jk_mrf",
    back_hsz = "node walk jkf_hsz",
}

node_city["桃花岛"] = {
    back_hangzhou = "node walk hys_ht",
    back_pozhen = "node walk hys_ht",
    back_mrf = "node walk hys_ht"    
}
  
node_city["燕子坞"] = {
    short_name = "mr",
    back_hangzhou = "node walk mr_hz",
    back_pozhen = "node walk mr_pozhen",
    back_mrf = "node walk mr_mrf",
    back_hsz = "node walk mr_hsz",    
}
  
node_city["提督府"] = {
    short_name = "tdf",
    back_hangzhou = "node walk tdf_hz",
    back_pozhen = "node walk tdf_pozhen",
    back_mrf = "node walk tdf_mrf"
}

node_city["岳王墓"] = {
    short_name = "ywm",
    back_hangzhou = "node walk ywm_hz",
    back_pozhen = "node walk ywm_pozhen",
    back_mrf = "node walk ywm_mrf",
    back_hsz = "node walk ywm_hsz",    
}

node_city["镇江"] = {
    short_name = "zj",
    back_hangzhou = "node walk zj_hz",
    back_pozhen = "node walk zj_pozhen",
    back_mrf = "node walk zj_mrf"    
}
   
node_city["江州"] = {
    short_name = "jz",
    back_hangzhou = "node walk jz_hz",
    back_pozhen = "node walk jz_pozhen",
    back_mrf = "node walk jz_mrf",
    back_hsz = "node walk jz_hsz"    
}
 
node_city["铜官镇"] = {
    short_name = "tgz",
    back_hangzhou = "node walk tgz_hz",
    back_pozhen = "node walk tgz_pozhen",
    back_mrf = "node walk tgz_mrf",
    back_hsz = "node walk tgz_hsz",
}
  
node_city["嘉兴"] = {
    short_name = "jx",
    back_hangzhou = "node walk jx_hz",
    back_pozhen = "node walk jx_pozhen",
    back_mrf = "node walk jx_mrf",
    back_hsz = "node walk jx_hsz",
}
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>util</name>
			<packageName></packageName>
			<script>local function split(str, delimiter)
    local resultTable = {}
    -- The pattern '([^' .. delimiter .. ']+)' matches one or more characters
    -- that are NOT the delimiter, effectively capturing the segments between delimiters.
    for segment in string.gmatch(str, "([^" .. delimiter .. "]+)") do
        table.insert(resultTable, segment)
    end
    return resultTable
end</script>
			<eventHandlerList />
		</Script>
		<Script isActive="no" isFolder="no">
			<name>测绘机器人</name>
			<packageName></packageName>
			<script>-- 测绘机器人（基于 gmcp.GMCP.Move[1]）
-- 生成的地图结构：
-- mapper.mapNodes = {
--   ["房间名|按字典序排序的出口缩写，用逗号分隔"] = {
--     name  = "房间名",
--     exits = { ["dir缩写"] = "目标房间指纹", ... },
--   },
-- }

mapper = mapper or {}
mapper.mappingEnabled = true   -- 默认开启测绘

-------------------------------------------------------
-- 边界设置
-------------------------------------------------------

-- ☆☆ 边界房间名字：这些名字的房间会被当成“边缘”，不会从这里继续向外探索 ☆☆
mapper.boundaryNames = mapper.boundaryNames or {
  ["三阳门"] = true,
}

-------------------------------------------------------
-- 方向相关配置
-------------------------------------------------------

-- GMCP 里可能出现的各种方向写法，统一折叠到内部缩写
mapper.dirAlias = mapper.dirAlias or {
  east="e", west="w", north="n", south="s",
  northeast="ne", northwest="nw",
  southeast="se", southwest="sw",
  up="u", down="d",

  southdown="sd",   southup="su",
  eastdown="ed",    eastup="eu",
  westdown="wd",    westup="wu",
  northup="nu",     northdown="nd",

  northeastup="neu",     northeastdown="ned",
  northwestup="nwu",     northwestdown="nwd",
  southeastup="seu",     southeastdown="sed",
  southwestup="swu",     southwestdown="swd",
  out="out", enter="enter",
}

-- 统一把方向规范成内部缩写
function mapper.normalizeDir(dir)
  return mapper.dirAlias[dir] or dir   -- 没在表里就原样返回
end

-- 反向表：只写“缩写”之间的对应关系
mapper.opposite = {
  n="s", s="n",
  e="w", w="e",
  ne="sw", sw="ne",
  nw="se", se="nw",
  u="d", d="u",

  -- 上下组合
  sd="nu", nu="sd",
  su="nd", nd="su",

  ed="wu", wu="ed",
  eu="wd", wd="eu",

  -- 斜向+上下
  neu="swd", swd="neu",
  ned="swu", swu="ned",
  nwu="sed", sed="nwu",
  nwd="seu", seu="nwd",
  out   = "enter", enter = "out",
}

-------------------------------------------------------
-- 内部存储结构
-------------------------------------------------------

-- fp（fingerprint） = "房间名|出口缩写1,出口缩写2,..."
-- nodes[fp] = {
--   name       = "房间名",
--   exits      = { ["dir缩写"] = "目标房间fp", ... },
--   exitList   = { "dir缩写1", "dir缩写2", ... }  -- 排序后
--   isBoundary = bool,
-- }

mapper.nodes      = mapper.nodes or {}
mapper.currentFP  = mapper.currentFP or nil   -- 当前房间指纹
mapper.pendingDir = mapper.pendingDir or nil  -- 正在走的方向（缩写）
mapper.moveStack  = mapper.moveStack or {}    -- DFS 路径栈（存方向缩写）
mapper.mapping    = mapper.mapping or false   -- 是否正在测绘

-------------------------------------------------------
-- 工具函数
-------------------------------------------------------

local function mprint(msg)
  if cecho then
    cecho("\n&lt;green&gt;[Mapper]&lt;reset&gt; " .. msg .. "\n")
  else
    print("[Mapper] " .. msg)
  end
end

local function sortedCopy(exits)
  local t = {}
  for i, v in ipairs(exits) do
    t[i] = v
  end
  table.sort(t)
  return t
end

-- 指纹： 房间名 | 排序后的出口列表（缩写，用逗号连接）
function mapper.fingerprint(name, exits)
  local sorted = sortedCopy(exits)
  return name .. "|" .. table.concat(sorted, ",")
end

local function nodeCount()
  local c = 0
  for _ in pairs(mapper.nodes) do c = c + 1 end
  return c
end

-------------------------------------------------------
-- GMCP 回调：gmcp.GMCP.Move 更新时调用
-------------------------------------------------------

function mapper.onGMCPMove()
  if not mapper.mappingEnabled then return end   -- ⛔ 暂停测绘
  
  local move = gmcp and gmcp.GMCP and gmcp.GMCP.Move and gmcp.GMCP.Move[1]
  if not move then return end
  if move.result ~= "true" then return end  -- 只处理 result == "true"

  local name = move.short or "未知房间"
  local exits = {}

  if move.dir then
    for _, d in ipairs(move.dir) do
      local nd = mapper.normalizeDir(d)   -- 比如 westup -&gt; wu
      table.insert(exits, nd)
    end
  end

  mapper.onRoom(name, exits)
end

-------------------------------------------------------
-- 处理房间（核心逻辑）
-------------------------------------------------------

function mapper.onRoom(name, exits)
  local fp = mapper.fingerprint(name, exits)
  local node = mapper.nodes[fp]

  local sortedExits = sortedCopy(exits)
  local isBoundary  = mapper.boundaryNames and mapper.boundaryNames[name] or false

  if not node then
    node = {
      name       = name,
      exits      = {},          -- dir缩写 -&gt; 目标fp
      exitList   = sortedExits, -- 已排序的出口缩写列表
      isBoundary = isBoundary,
    }
    mapper.nodes[fp] = node

    mprint(string.format(
      '发现新房间 [%s]%s，出口: %s',
      fp,
      isBoundary and "（边界房间）" or "",
      table.concat(sortedExits, ", ")
    ))
  else
    node.name     = name
    node.exitList = sortedExits
    -- 一旦某次判断为边界，就一直保留标记
    node.isBoundary = node.isBoundary or isBoundary
  end

  -- 如果是从上一个房间走过来的，补全连接关系
  if mapper.currentFP and mapper.pendingDir then
    local prevFP   = mapper.currentFP
    local prevNode = mapper.nodes[prevFP]
    local dir      = mapper.pendingDir -- 缩写

    if prevNode then
      -- 前向链接
      prevNode.exits[dir] = fp
    end

    -- 反向链接
    local backDir = mapper.opposite[dir]
    if backDir then
      local curNode = mapper.nodes[fp]
      if curNode then
        curNode.exits[backDir] = prevFP
      end
    end
  end

  mapper.currentFP  = fp
  mapper.pendingDir = nil

  -- ❗ 注意：这里不再因为边界而停止测绘，继续交给 nextStep 决定怎么走
  if mapper.mapping then
    mapper.nextStep()
  end
end


-------------------------------------------------------
-- DFS 自动走动逻辑（含边界）
-------------------------------------------------------

function mapper.nextStep()
  if not mapper.mapping or not mapper.currentFP then return end

  local node = mapper.nodes[mapper.currentFP]
  if not node then return end

  -- ⭐ 边界房间：不再从这里继续向外探索，只回退
  if node.isBoundary then
    mprint("到达边界房间: " .. node.name .. "（" .. mapper.currentFP .. "），不再从这里向外探索。")
  else
    -- 在 exitList 里找还没有建立链接的方向（只在非边界房间做）
    for _, dir in ipairs(node.exitList or {}) do
      if not node.exits[dir] then
        local nd = mapper.normalizeDir(dir)  -- 理论上已经是缩写，再保险一下
        mapper.pendingDir = nd
        table.insert(mapper.moveStack, nd)   -- 栈里永远存缩写
        mprint("前进方向: " .. nd)
        send(nd)                             -- 给 MUD 发送缩写命令
        return
      end
    end
  end

  -- 走到这里说明：
  -- 1) 当前是边界房间，不能扩张，或者
  -- 2) 当前非边界，但所有出口都已经建立过连接
  -- =&gt; 开始回退

  if #mapper.moveStack == 0 then
    mapper.mapping = false
    mprint("测绘完成！本区域共发现 " .. nodeCount() .. " 个房间。")
    mapper.dumpAsLua()
    return
  end

  local lastDir = table.remove(mapper.moveStack)   -- 缩写
  local backDir = mapper.opposite[lastDir]

  if not backDir then
    mprint("警告：找不到方向 " .. tostring(lastDir) .. " 的反向，停止测绘。")
    mapper.mapping = false
    mapper.dumpAsLua()
    return
  end

  mapper.pendingDir = backDir
  mprint("回退方向: " .. backDir)
  send(backDir)
end



-------------------------------------------------------
-- 对外接口
-------------------------------------------------------

-- 开始测绘
function mapper.start()
  mapper.nodes      = {}
  mapper.currentFP  = nil
  mapper.pendingDir = nil
  mapper.moveStack  = {}
  mapper.mapping    = true

  mprint("开始自动测绘，请不要手动乱走。等待 GMCP 当前房间信息...")

  local move = gmcp and gmcp.GMCP and gmcp.GMCP.Move and gmcp.GMCP.Move[1]
  if move and move.dir and move.short and move.result == "true" then
    mapper.onGMCPMove()
  else
    -- 看你 MUD，用什么命令会重新推送 GMCP.Move
    send("look")
  end
end

-- 停止测绘
function mapper.stop()
  mapper.mapping = false
  mprint("已停止测绘。当前已记录房间数: " .. nodeCount())
end

function mapper.resetRuntimeMap()
  -- 关掉正在测绘
  mapper.mapping        = false
  mapper.mappingEnabled = mapper.mappingEnabled ~= false  -- 保持配置，默认 true

  -- 清空当前这次测绘用到的运行时数据
  mapper.nodes       = {}
  mapper.mapNodes    = {}
  mapper.moveStack   = {}
  mapper.currentFP   = nil
  mapper.pendingDir  = nil
  mapper.lastFP      = nil

  mprint("已清除当前测绘地图数据，可以重新开始测绘。")
end

-- 输出为你想要的 Lua 表结构
function mapper.dumpAsLua()
  mprint("===== 地图 Lua 表结构（mapper.mapNodes） =====")

  local keys = {}
  for fp in pairs(mapper.nodes) do
    table.insert(keys, fp)
  end
  table.sort(keys)

  mapper.mapNodes = {}  -- 真正对外的结构

  if echo then
    echo("\nmapper.mapNodes = {\n")
    for _, fp in ipairs(keys) do
      local node = mapper.nodes[fp]
      mapper.mapNodes[fp] = {
        name  = node.name,
        exits = node.exits,
      }

      local nameEsc = node.name:gsub('"', '\\"')
      echo(string.format('  ["%s"] = {\n', fp))
      echo(string.format('    name = "%s",\n', nameEsc))
      echo('    exits = {\n')

      -- 为了输出顺序稳定一点，排一下方向
      local dirs = {}
      for dir in pairs(node.exits) do
        table.insert(dirs, dir)
      end
      table.sort(dirs)

      for _, dir in ipairs(dirs) do
        local targetFP = node.exits[dir]
        echo(string.format('      ["%s"] = "%s",\n', dir, targetFP))
      end

      echo('    },\n')
      echo('  },\n')
    end
    echo("}\n\n")
  else
    print("mapper.mapNodes = {")
    for _, fp in ipairs(keys) do
      local node = mapper.nodes[fp]
      mapper.mapNodes[fp] = {
        name  = node.name,
        exits = node.exits,
      }

      local nameEsc = node.name:gsub('"', '\\"')
      print(string.format('  ["%s"] = {', fp))
      print(string.format('    name = "%s",', nameEsc))
      print('    exits = {')
      for dir, targetFP in pairs(node.exits) do
        print(string.format('      ["%s"] = "%s",', dir, targetFP))
      end
      print('    },')
      print('  },')
    end
    print("}")
  end

  mprint("===== 结束 =====")
end



-- 保存当前地图到文件
function mapper.save(filename)
  -- 默认保存路径：Mudlet 配置目录下的 mapper_map.lua
  filename = filename or (getMudletHomeDir() .. "/mapper_map.lua")

  -- 如果你更喜欢存到某个子目录，可以改成：
  -- filename = getMudletHomeDir() .. "/maps/jiangnan.lua"

  -- 确保 mapNodes 最新：从 nodes 重建一遍
  mapper.mapNodes = {}

  local keys = {}
  for fp in pairs(mapper.nodes) do
    table.insert(keys, fp)
  end
  table.sort(keys)

  for _, fp in ipairs(keys) do
    local node = mapper.nodes[fp]
    mapper.mapNodes[fp] = {
      name  = node.name,
      exits = node.exits,
    }
  end

  local f, err = io.open(filename, "w")
  if not f then
    mprint("保存失败，无法打开文件: " .. tostring(err))
    return
  end

  -- 写成一个可以直接 dofile 的 Lua 文件
  f:write("mapper = mapper or {}\n")
  f:write("mapper.mapNodes = {\n")

  for _, fp in ipairs(keys) do
    local node = mapper.nodes[fp]
    local nameEsc = node.name:gsub("\\", "\\\\"):gsub('"', '\\"')

    f:write(string.format('  ["%s"] = {\n', fp))
    f:write(string.format('    name = "%s",\n', nameEsc))
    f:write('    exits = {\n')

    -- 出口按方向排序，方便看
    local dirs = {}
    for dir in pairs(node.exits) do
      table.insert(dirs, dir)
    end
    table.sort(dirs)

    for _, dir in ipairs(dirs) do
      local targetFP = node.exits[dir]
      f:write(string.format('      ["%s"] = "%s",\n', dir, targetFP))
    end

    f:write('    },\n')
    f:write('  },\n')
  end

  f:write("}\n")
  f:close()

  mprint("地图已保存到文件: " .. filename)
end

function mapper.showRoom(fp)
  -- fp 可选，没给时用当前房间
  fp = fp or mapper.currentFP
  if not fp then
    cecho("&lt;red&gt;[Mapper] 当前没有 FP（可能还没收到 GMCP）。\n")
    return
  end

  local node = mapper.mapNodes[fp]
  if not node then
    cecho("&lt;red&gt;[Mapper] 地图中没有找到房间：" .. tostring(fp) .. "\n")
    return
  end

  -- 构造 exits 输出
  local lines = {}
  table.insert(lines, string.format('["%s"] = {', fp))
  table.insert(lines, string.format('  name = "%s",', node.name))
  table.insert(lines, '  exits = {')

  -- 排序方向，输出更可读
  local dirs = {}
  for d in pairs(node.exits) do table.insert(dirs, d) end
  table.sort(dirs)

  for _, d in ipairs(dirs) do
    local tgt = node.exits[d]
    table.insert(lines, string.format('    ["%s"] = "%s",', d, tgt))
  end

  table.insert(lines, '  },')
  table.insert(lines, '},')

  cecho("\n&lt;green&gt;" .. table.concat(lines, "\n") .. "\n")
end


-- 注册 GMCP 事件
function mapper.registerGMCP()
  if registerAnonymousEventHandler then
    mapper._gmcpHandlerId = registerAnonymousEventHandler(
      "gmcp.GMCP.Move",
      "mapper.onGMCPMove"
    )
    mprint("已注册 GMCP 事件处理器 gmcp.GMCP.Move。")
  else
    mprint("没有 registerAnonymousEventHandler，需自己用触发器手动调用 mapper.onGMCPMove。")
  end
end

-- 自动注册
if gmcp and registerAnonymousEventHandler then
  mapper.registerGMCP()
end
</script>
			<eventHandlerList />
		</Script>
		<Script isActive="yes" isFolder="no">
			<name>区域导航</name>
			<packageName></packageName>
			<script>-- 自动寻路脚本（多区域 + 别名，支持 goto js.smf）
-- 依赖：
--   1）mapper.currentFP : 当前房间指纹（由你的 mapper 测绘脚本更新）
--   2）地图文件：dofile("&lt;xxx&gt;.lua") 后提供：
--        mapper.region     = { key = "js", name = "江苏" }      -- 可选
--        mapper.mapNodes   = { ... }                            -- 必须
--        mapper.mapAliases = { ["三茅峰"] = "smf", ... }        -- 可选，但建议有
--
-- 使用建议：
--   1）lua nav.loadMap("wuxi1")      -- 加载地图 maps/wuxi1.lua
--   2）在 Mudlet 里建个 alias: ^goto (\S+)$ -&gt; nav.gotoToken(matches[2])
--   3）游戏里输入： goto js.smf     -- js 区域 + smf 别名，例如 三茅峰

nav = nav or {}

-------------------------------------------------------
-- 全局状态
-------------------------------------------------------

-- 已加载的所有区域：
-- nav.regions["js"] = {
--   name       = "江苏",
--   mapNodes   = {...},           -- 这张图的所有房间
--   aliases    = {...},           -- 中文名 -&gt; 缩写
--   aliasIndex = { smf = { "三茅峰|ed,n", ... }, ... }, -- 缩写 -&gt; 指纹列表
-- }
nav.regions = nav.regions or {}

-- 当前是否在自动行走
nav.active            = nav.active or false
nav.route             = nav.route or {}   -- 当前路径：{ {dir, from, to}, ... }
nav.routeIndex        = nav.routeIndex or 0
nav.targetFP          = nav.targetFP or nil
nav.currentRegionKey  = nav.currentRegionKey or nil

-- GMCP 事件 handler id
nav._gmcpHandlerId = nav._gmcpHandlerId or nil

-------------------------------------------------------
-- 工具函数
-------------------------------------------------------

local function nprint(msg)
  if cecho then
    cecho("\n&lt;cyan&gt;[Nav]&lt;reset&gt; " .. msg .. "\n")
  else
    print("[Nav] " .. msg)
  end
end

local function getHome()
  if getMudletHomeDir then
    return getMudletHomeDir()
  else
    return "."
  end
end

-------------------------------------------------------
-- 加载地图文件到 nav.regions
-------------------------------------------------------
function nav.loadMap(regionKey)
  regionKey = tostring(regionKey or "")

  if regionKey == "" then
    nprint('nav.loadMap 需要一个区域 key，比如：nav.loadMap("wx")')
    return
  end

  if not mapper or not mapper.maps or not mapper.maps[regionKey] then
    nprint('在脚本中找不到 mapper.maps["' .. regionKey .. '"]，请确认地图脚本已加载。')
    return
  end

  local m = mapper.maps[regionKey]
  local mapNodes   = m.mapNodes
  local aliases    = m.mapAliases or {}
  local region     = m.region or {}
  local rkey       = region.key or regionKey
  local rname      = region.name or rkey

  if type(mapNodes) ~= "table" then
    nprint('mapper.maps["' .. regionKey .. '"].mapNodes 不是表。')
    return
  end

  -- 建 aliasIndex：缩写 -&gt; 指纹列表
  local aliasIndex = {}
  for fp, node in pairs(mapNodes) do
    local name = node.name
    local alias = aliases[name]
    if alias then
      aliasIndex[alias] = aliasIndex[alias] or {}
      table.insert(aliasIndex[alias], fp)
    end
  end

  nav.regions[rkey] = {
    name       = rname,
    mapNodes   = mapNodes,
    aliases    = aliases,
    aliasIndex = aliasIndex,
  }

  local cNodes, cAliases = 0, 0
  for _ in pairs(mapNodes) do cNodes = cNodes + 1 end
  for _ in pairs(aliases)  do cAliases = cAliases + 1 end

  nprint(string.format(
    '已从脚本加载区域[%s] %s：房间数 %d，别名数 %d',
    rkey, rname, cNodes, cAliases
  ))
end

-------------------------------------------------------
-- 在指定 mapNodes 中 BFS 寻路
-------------------------------------------------------

-- 在指定 mapNodes 中从 startFP 到 targetFP 寻路
local function findPathInMap(mapNodes, startFP, targetFP)
  if not mapNodes[startFP] then
    nprint("起点不在该区域地图中: " .. tostring(startFP))
    return nil
  end
  if not mapNodes[targetFP] then
    nprint("目标不在该区域地图中: " .. tostring(targetFP))
    return nil
  end
  if startFP == targetFP then
    nprint("当前就在目标房间。")
    return {}
  end

  local q = { startFP }
  local head = 1
  local visited = { [startFP] = true }
  local prev = {}   -- fp -&gt; { from=fp2, dir=dir }

  while head &lt;= #q do
    local cur = q[head]; head = head + 1
    if cur == targetFP then break end

    local node = mapNodes[cur]
    if node and node.exits then
      for dir, nextFP in pairs(node.exits) do
        if not visited[nextFP] then
          visited[nextFP] = true
          prev[nextFP] = { from = cur, dir = dir }
          table.insert(q, nextFP)
        end
      end
    end
  end

  if not visited[targetFP] then
    nprint("在该区域内找不到路径。")
    return nil
  end

  -- 回溯构造路径
  local steps = {}
  local fp = targetFP
  while fp ~= startFP do
    local p = prev[fp]
    table.insert(steps, 1, { dir = p.dir, from = p.from, to = fp })
    fp = p.from
  end

  return steps
end

function nav.findPath(mapNodes, startFP, targetFP)
  return findPathInMap(mapNodes, startFP, targetFP)
end

-------------------------------------------------------
-- 路径展示
-------------------------------------------------------

local function printPathInRegion(regionKey, path)
  if not path then return end
  local region = nav.regions[regionKey]
  if not region then
    nprint("区域[" .. tostring(regionKey) .. "] 未找到。")
    return
  end
  local mapNodes = region.mapNodes

  if #path == 0 then
    nprint("路径为空（已经在目标房间）。")
    return
  end

  nprint(string.format(
    "区域[%s] %s：路径长度 %d 步：",
    regionKey, region.name, #path
  ))

  for i, step in ipairs(path) do
    local fromNode = mapNodes[step.from]
    local toNode   = mapNodes[step.to]
    local fromName = fromNode and fromNode.name or step.from
    local toName   = toNode and toNode.name or step.to
    nprint(string.format(
      "  %2d. %-6s  %s  →  %s",
      i, step.dir, fromName, toName
    ))
  end
end

-------------------------------------------------------
-- 自动行走控制
-------------------------------------------------------

function nav._step()
  if not nav.active then return end
  nav.routeIndex = nav.routeIndex + 1
  local step = nav.route[nav.routeIndex]

  if not step then
    nprint("已抵达目标: " .. tostring(nav.targetFP))
    nav.active = false
    return
  end

  nprint("自动行走: 第 " .. nav.routeIndex .. " 步，方向 " .. step.dir)
  send(step.dir)
end


-- GMCP 回调：每次移动成功后调用，推进下一步
function nav.onGMCPMove()
  -- 临时调试：你可以先保留这一行，看是不是每次移动都触发了
 nprint("nav.onGMCPMove 触发, active=" .. tostring(nav.active) .. ", currentFP=" .. tostring(mapper and mapper.currentFP))

  if not nav.active then return end
  if not mapper or not mapper.currentFP then
    return
  end

  local step = nav.route[nav.routeIndex]
  if not step then
    -- 理论上已经走完了
    nav.active = false
    return
  end

  local fp = mapper.currentFP

  -- 如果当前位置既不是本步的 from，也不是 to，才认为真正偏离
  if fp ~= step.from and fp ~= step.to then
    nprint("当前位置偏离预期路径，停止自动行走。当前fp: " .. tostring(fp))
    nav.active = false
    return
  end

  -- 只要 gmcp.GMCP.Move 触发了，就认为当前这一步完成，走下一步
  nav._step()
end


-------------------------------------------------------
-- 对外接口：停止 / 区域内按指纹寻路 / 解析 token
-------------------------------------------------------

-- 停止自动寻路
function nav.stop()
  nav.active           = false
  nav.route            = {}
  nav.routeIndex       = 0
  nav.targetFP         = nil
  nav.currentRegionKey = nil
  nprint("已停止自动行走。")
end

-- 在指定区域、按目标指纹寻路
local function gotoFPInRegion(regionKey, targetFP)
  local region = nav.regions[regionKey]
  if not region then
    nprint("区域[" .. regionKey .. "] 的地图还没加载。先 nav.loadMap(\"...\")。")
    return
  end

  if not mapper or not mapper.currentFP then
    nprint("当前房间指纹未知（mapper.currentFP 为空）。等 GMCP 更新一下，比如敲个 look，再试。")
    return
  end

  local startFP = mapper.currentFP

  if not region.mapNodes[startFP] then
    nprint("当前所在房间不在区域[" .. regionKey .. "]的地图中。")
    return
  end

  local path = findPathInMap(region.mapNodes, startFP, targetFP)
  if not path then return end

  printPathInRegion(regionKey, path)

  if #path == 0 then
    return
  end

  nav.route             = path
  nav.routeIndex        = 0
  nav.targetFP          = targetFP
  nav.currentRegionKey  = regionKey
  nav.active            = true

  nav._step()
end

-- 解析 token：
--   目前只支持： region.alias 形式，例如 "js.smf"
--   以后你可以再扩展无前缀的 smf 写法
function nav.gotoToken(token)
  token = tostring(token)

  local rkey, alias = token:match("^(%w+)%.(%w+)$")
  if not (rkey and alias) then
    nprint("请使用带区域前缀的形式，例如: goto js.smf")
    return
  end

  local region = nav.regions[rkey]
  if not region then
    nprint("区域[" .. rkey .. "] 未加载地图。先 nav.loadMap(\"...\")。")
    return
  end

  local list = region.aliasIndex[alias]
  if not list or #list == 0 then
    nprint(string.format(
      "在区域[%s]中找不到别名[%s] 对应的房间，请检查该地图文件中的 mapper.mapAliases。",
      rkey, alias
    ))
    return
  end

  table.sort(list)
  local targetFP = list[1]
  local node = region.mapNodes[targetFP]

  nprint(string.format(
    "区域[%s] %s：别名[%s] -&gt; [%s] %s",
    rkey, region.name, alias, targetFP, node and node.name or "?"
  ))

  gotoFPInRegion(rkey, targetFP)
end

-- 解析一个位置 token，返回: rkey, fp, node
-- token 支持：
--   1) "cz.hzda"  区域+别名
--   2) "hzda"     只写别名，区域用 defaultRegionKey 或自动推断
--   3) "cz.广济门|eu,nw,se,w"  区域+完整指纹
--   4) "广济门|eu,nw,se,w"     只写指纹，区域用 defaultRegionKey 或自动推断
function nav.resolveLocationToken(token, defaultRegionKey)
  token = tostring(token)

  local rkey, key = token:match("^(%w+)%.(.+)$")
  local regionKey = rkey or defaultRegionKey
  local nameOrFP  = key or token

  -- 如果没给区域，就尝试用“当前区域”或者“唯一的一个区域”
  if not regionKey then
    if nav.currentRegionKey then
      regionKey = nav.currentRegionKey
    else
      -- 尝试从 nav.regions 里找唯一的区域
      local onlyKey
      if nav.regions then
        for k, _ in pairs(nav.regions) do
          if onlyKey and onlyKey ~= k then
            onlyKey = nil  -- 多个区域，没法猜
            break
          end
          onlyKey = k
        end
      end
      if not onlyKey then
        nprint("无法确定区域，请使用 区域.别名 的形式，例如: cz.hzda")
        return nil
      end
      regionKey = onlyKey
    end
  end

  local region = nav.regions and nav.regions[regionKey]
  if not region then
    nprint("区域[" .. regionKey .. "] 未加载地图。")
    return nil
  end

  local mapNodes   = region.mapNodes or region.map_nodes or {}
  local aliasIndex = region.aliasIndex or {}

  local fp

  -- 1) 先按别名查
  local list = aliasIndex[nameOrFP]
  if list and #list &gt; 0 then
    table.sort(list)
    fp = list[1]
  else
    -- 2) 再按完整指纹查
    if mapNodes[nameOrFP] then
      fp = nameOrFP
    end
  end

  if not fp then
    nprint(string.format(
      "在区域[%s]中找不到别名/指纹 [%s]，请检查 mapper.mapAliases 或 mapNodes。",
      regionKey, nameOrFP
    ))
    return nil
  end

  return regionKey, fp, mapNodes[fp]
end

-- 根据区域 rkey，决定从哪个房间出发
function nav.getStartFP(rkey)
  local region = nav.regions and nav.regions[rkey]
  if not region then
    nprint("区域[" .. tostring(rkey) .. "] 未加载地图。")
    return nil
  end

  local mapNodes = region.mapNodes or region.map_nodes or {}

  -- 1) 优先使用 here 设置的当前位置
  if nav.currentRegionKey == rkey and nav.currentFP and mapNodes[nav.currentFP] then
    return nav.currentFP
  end

  -- 2) 退而求其次：尝试用 mapper.currentFP（gmcp 驱动）
  if mapper and mapper.currentFP and mapNodes[mapper.currentFP] then
    nav.currentRegionKey = rkey
    nav.currentFP        = mapper.currentFP
    return mapper.currentFP
  end

  -- 3) 都没有 → 提示用户用 here
  nprint(string.format(
    "不知道你在区域[%s]的哪个房间。\n请先用: here %s.别名    例如: here %s.zdg",
    rkey, rkey, rkey
  ))
  return nil
end

-- 内部工具: 计算并打印从 startFP 到 targetFP 的路径
function nav.showPathInRegion(rkey, startFP, targetFP)
  local region = nav.regions and nav.regions[rkey]
  if not region then
    nprint("区域[" .. tostring(rkey) .. "] 未加载地图。")
    return
  end

  local mapNodes = region.mapNodes or region.map_nodes or {}
  local targetNode = mapNodes[targetFP]

  local path = nav.findPath(mapNodes, startFP, targetFP)
  if not path then
    nprint(string.format(
      "[Nav] 找不到从 [%s] 到 [%s] 的路径。",
      startFP, targetFP
    ))
    return
  end

  local dirs = {}
  for _, step in ipairs(path) do
    table.insert(dirs, step.dir)
  end
  local seq = table.concat(dirs, ";")

  nprint(string.format(
    "[Nav] 区域[%s]：从 [%s] 到 [%s] %s，共 %d 步。",
    rkey,
    startFP,
    targetFP,
    targetNode and targetNode.name or "",
    #dirs
  ))
  nprint("[Nav] 路径方向序列: " .. seq)
end

-- 对外命令: path A B  /  path B
function nav.pathCommand(arg1, arg2)
  if not arg1 or arg1 == "" then
    nprint("用法: path 目标   或   path 起点 终点")
    return
  end

  -- 去掉空串
  if arg2 == "" then arg2 = nil end

  if arg2 then
    ------------------------------------------------
    -- 情况一: 有 A 和 B，算 A -&gt; B
    ------------------------------------------------
    local fromR, fromFP = nav.resolveLocationToken(arg1, nav.currentRegionKey)
    if not fromR then return end

    local toR, toFP = nav.resolveLocationToken(arg2, fromR)
    if not toR then return end

    if fromR ~= toR then
      nprint(string.format(
        "[Nav] 暂不支持跨区域寻路：[%s] -&gt; [%s]",
        fromR, toR
      ))
      return
    end

    nav.showPathInRegion(fromR, fromFP, toFP)
  else
    ------------------------------------------------
    -- 情况二: 只有 B，用“当前位置”作为起点
    ------------------------------------------------
    local toR, toFP = nav.resolveLocationToken(arg1, nav.currentRegionKey)
    if not toR then return end

    local startFP = nav.getStartFP(toR)
    if not startFP then return end

    nav.showPathInRegion(toR, startFP, toFP)
  end
end


-------------------------------------------------------
-- 注册 GMCP 事件（跟你的 mapper 一样监听 gmcp.GMCP.Move）
-------------------------------------------------------

function nav.registerGMCP()
  if registerAnonymousEventHandler then
    nav._gmcpHandlerId = registerAnonymousEventHandler(
      "gmcp.GMCP.Move",
      "nav.onGMCPMove"
    )
    nprint("已注册 GMCP 事件处理器 gmcp.GMCP.Move。")
  else
    nprint("没有 registerAnonymousEventHandler，需自己用触发器手动调用 nav.onGMCPMove。")
  end
end

-- 自动注册
--if gmcp and registerAnonymousEventHandler then
  nav.registerGMCP()
--end
</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>区域地图</name>
			<packageName></packageName>
			<script></script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>wx</name>
				<packageName></packageName>
				<script>mapper = mapper or {}

mapper.maps = mapper.maps or {} 

mapper.maps["wx"]= {

  region = {
    key  = "wx",      -- 区域代号，用在 goto wx.xxx 里
    name = "无锡",    -- 纯注释/显示用
  },

  mapNodes = {
    ["三茅峰|ed,n"] = {
      name = "三茅峰",
      exits = {
        ["ed"] = "惠山|ed,nd,sd,wu",
        ["n"] = "阳山|s,sw",
      },
    },
    ["东大街|ne,nw,s,se,w"] = {
      name = "东大街",
      exits = {
        ["ne"] = "石皮巷|e,sw",
        ["nw"] = "城隍庙|se",
        ["s"] = "北禅寺|n,s",
        ["se"] = "大市桥|n,nw,se",
        ["w"] = "西大街|e,n,nw,su",
      },
    },
    ["东门|e,wu"] = {
      name = "东门",
      exits = {
        ["e"] = "城外土路|se,w",
        ["wu"] = "营桥|ed,n,wd",
      },
    },
    ["书院街|e,nw,s"] = {
      name = "书院街",
      exits = {
        ["e"] = "城头街|su,w",
        ["nw"] = "打铁桥|e,nw,se",
        ["s"] = "捕快营|enter,n,s,wu",
      },
    },
    ["仓桥|ed,nw"] = {
      name = "仓桥",
      exits = {
        ["ed"] = "捕快营|enter,n,s,wu",
        ["nw"] = "道场巷|se",
      },
    },
    ["北禅寺|n,s"] = {
      name = "北禅寺",
      exits = {
        ["n"] = "东大街|ne,nw,s,se,w",
        ["s"] = "北禅寺巷|e,n,w",
      },
    },
    ["北禅寺巷|e,n,w"] = {
      name = "北禅寺巷",
      exits = {
        ["e"] = "南大街|e,ne,nw,se,w",
        ["n"] = "北禅寺|n,s",
        ["w"] = "北禅寺巷|e,nu,w",
      },
    },
    ["北禅寺巷|e,nu,w"] = {
      name = "北禅寺巷",
      exits = {
        ["e"] = "北禅寺巷|e,n,w",
        ["nu"] = "西桥|nd,sd",
        ["w"] = "庙巷|e,n,s",
      },
    },
    ["北门|n,se"] = {
      name = "北门",
      exits = {
        ["n"] = "杏子林|nw,s,se",
        ["se"] = "打铁桥|e,nw,se",
      },
    },
    ["医馆|n"] = {
      name = "医馆",
      exits = {
        ["n"] = "槐树巷|nw,s,w",
      },
    },
    ["南大街|e,ne,nw,se,w"] = {
      name = "南大街",
      exits = {
        ["e"] = "槐树巷|e,nw,s,w",
        ["ne"] = "欢喜巷|e,n,se,sw",
        ["nw"] = "大市桥|n,nw,se",
        ["se"] = "南市桥|nw,sw,w",
        ["w"] = "北禅寺巷|e,n,w",
      },
    },
    ["南市桥|nw,sw,w"] = {
      name = "南市桥",
      exits = {
        ["nw"] = "南大街|e,ne,nw,se,w",
        ["sw"] = "南市桥巷|ne,se",
        ["w"] = "无锡马车行|e",
      },
    },
    ["南市桥巷|ne,se"] = {
      name = "南市桥巷",
      exits = {
        ["ne"] = "南市桥|nw,sw,w",
        ["se"] = "南门|e,nw",
      },
    },
    ["南门|e,nw"] = {
      name = "南门",
      exits = {
        ["nw"] = "南市桥巷|ne,se",
      },
    },
    ["土路|ne,se"] = {
      name = "土路",
      exits = {
        ["ne"] = "惠山寺|nw,sw",
        ["se"] = "西门|nw,se,sw",
      },
    },
    ["城外土路|se,w"] = {
      name = "城外土路",
      exits = {
        ["w"] = "东门|e,wu",
      },
    },
    ["城头街|su,w"] = {
      name = "城头街",
      exits = {
        ["su"] = "黄泥桥|nd,sd",
        ["w"] = "书院街|e,nw,s",
      },
    },
    ["城守营|nw,s"] = {
      name = "城守营",
      exits = {
        ["nw"] = "硝皮巷|nu,s,se",
        ["s"] = "营桥|ed,n,wd",
      },
    },
    ["城隍庙|se"] = {
      name = "城隍庙",
      exits = {
        ["se"] = "东大街|ne,nw,s,se,w",
      },
    },
    ["大厅|out"] = {
      name = "大厅",
      exits = {
        ["out"] = "捕快营|enter,n,s,wu",
      },
    },
    ["大市桥|n,nw,se"] = {
      name = "大市桥",
      exits = {
        ["n"] = "观前街|e,nw,s,w",
        ["nw"] = "东大街|ne,nw,s,se,w",
        ["se"] = "南大街|e,ne,nw,se,w",
      },
    },
    ["太湖湖边|ne"] = {
      name = "太湖湖边",
      exits = {
        ["ne"] = "雪浪山|ne,sw",
      },
    },
    ["山脚下|e,nu,s"] = {
      name = "山脚下",
      exits = {
        ["e"] = "惠山泉|w",
        ["nu"] = "惠山|ed,nd,sd,wu",
        ["s"] = "山路|n,se",
      },
    },
    ["山路|n,se"] = {
      name = "山路",
      exits = {
        ["n"] = "山脚下|e,nu,s",
        ["se"] = "惠山寺|nw,sw",
      },
    },
    ["山路|nd,su"] = {
      name = "山路",
      exits = {
        ["nd"] = "常州|n,nw,se,su,sw",
        ["su"] = "惠山|ed,nd,sd,wu",
      },
    },
    ["常州|n,nw,se,su,sw"] = {
      name = "常州",
      exits = {
        ["se"] = "锡山脚下|nw,se",
        ["su"] = "山路|nd,su",
      },
    },
    ["庙巷|e,n,s"] = {
      name = "庙巷",
      exits = {
        ["e"] = "北禅寺巷|e,nu,w",
        ["n"] = "当铺|s",
        ["s"] = "钱庄|n",
      },
    },
    ["府衙|enter,n,s"] = {
      name = "府衙",
      exits = {
        ["enter"] = "西大街|e,n,nw,su",
        ["n"] = "连元街|e,s",
        ["s"] = "西大街|e,n,nw,su",
      },
    },
    ["当铺|s"] = {
      name = "当铺",
      exits = {
        ["s"] = "庙巷|e,n,s",
      },
    },
    ["惠山|ed,nd,sd,wu"] = {
      name = "惠山",
      exits = {
        ["ed"] = "春申涧|wu",
        ["nd"] = "山路|nd,su",
        ["sd"] = "山脚下|e,nu,s",
        ["wu"] = "三茅峰|ed,n",
      },
    },
    ["惠山寺|nw,sw"] = {
      name = "惠山寺",
      exits = {
        ["nw"] = "山路|n,se",
        ["sw"] = "土路|ne,se",
      },
    },
    ["惠山泉|w"] = {
      name = "惠山泉",
      exits = {
        ["w"] = "山脚下|e,nu,s",
      },
    },
    ["打铁桥|e,nw,se"] = {
      name = "打铁桥",
      exits = {
        ["e"] = "打铁铺|w",
        ["nw"] = "北门|n,se",
        ["se"] = "书院街|e,nw,s",
      },
    },
    ["打铁铺|w"] = {
      name = "打铁铺",
      exits = {
        ["w"] = "打铁桥|e,nw,se",
      },
    },
    ["捕快营|enter,n,s,wu"] = {
      name = "捕快营",
      exits = {
        ["enter"] = "大厅|out",
        ["n"] = "书院街|e,nw,s",
        ["s"] = "盛巷桥|n,se,w",
        ["wu"] = "仓桥|ed,nw",
      },
    },
    ["无锡马车行|e"] = {
      name = "无锡马车行",
      exits = {
        ["e"] = "南市桥|nw,sw,w",
      },
    },
    ["春申涧|wu"] = {
      name = "春申涧",
      exits = {
        ["wu"] = "惠山|ed,nd,sd,wu",
      },
    },
    ["杂货铺|n"] = {
      name = "杂货铺",
      exits = {
        ["n"] = "槐树巷|e,nw,s,w",
      },
    },
    ["杏子林|nw,s,se"] = {
      name = "杏子林",
      exits = {
        ["nw"] = "锡山脚下|nw,se",
        ["s"] = "北门|n,se",
        ["se"] = "青石官道|ne,nw,s",
      },
    },
    ["松鹤楼|s"] = {
      name = "松鹤楼",
      exits = {
        ["s"] = "欢喜巷|e,n,se,sw",
      },
    },
    ["槐树巷|e,nw,s,w"] = {
      name = "槐树巷",
      exits = {
        ["e"] = "槐树巷|nw,s,w",
        ["nw"] = "欢喜巷|e,n,se,sw",
        ["s"] = "杂货铺|n",
        ["w"] = "南大街|e,ne,nw,se,w",
      },
    },
    ["槐树巷|nw,s,w"] = {
      name = "槐树巷",
      exits = {
        ["nw"] = "欢喜巷|n,se,w",
        ["s"] = "医馆|n",
        ["w"] = "槐树巷|e,nw,s,w",
      },
    },
    ["欢喜巷|e,n,se,sw"] = {
      name = "欢喜巷",
      exits = {
        ["e"] = "欢喜巷|n,se,w",
        ["n"] = "松鹤楼|s",
        ["se"] = "槐树巷|e,nw,s,w",
        ["sw"] = "南大街|e,ne,nw,se,w",
      },
    },
    ["欢喜巷|n,se,w"] = {
      name = "欢喜巷",
      exits = {
        ["n"] = "长风镖局|s",
        ["se"] = "槐树巷|nw,s,w",
        ["w"] = "欢喜巷|e,n,se,sw",
      },
    },
    ["洞虚宫|s"] = {
      name = "洞虚宫",
      exits = {
        ["s"] = "观前街|e,n,w",
      },
    },
    ["盛巷|eu,n,w"] = {
      name = "盛巷",
      exits = {
        ["eu"] = "营桥|ed,n,wd",
        ["n"] = "硝皮巷|nu,s,se",
        ["w"] = "观前街|e,n,w",
      },
    },
    ["盛巷桥|n,se,w"] = {
      name = "盛巷桥",
      exits = {
        ["n"] = "捕快营|enter,n,s,wu",
        ["se"] = "观前街|e,nw,s,w",
        ["w"] = "连元街|e,w",
      },
    },
    ["石皮巷|e,sw"] = {
      name = "石皮巷",
      exits = {
        ["e"] = "观前街|e,nw,s,w",
        ["sw"] = "东大街|ne,nw,s,se,w",
      },
    },
    ["硝皮巷|nu,s,se"] = {
      name = "硝皮巷",
      exits = {
        ["nu"] = "黄泥桥|nd,sd",
        ["s"] = "盛巷|eu,n,w",
        ["se"] = "城守营|nw,s",
      },
    },
    ["营桥|ed,n,wd"] = {
      name = "营桥",
      exits = {
        ["ed"] = "东门|e,wu",
        ["n"] = "城守营|nw,s",
        ["wd"] = "盛巷|eu,n,w",
      },
    },
    ["西大街|e,n,nw,su"] = {
      name = "西大街",
      exits = {
        ["e"] = "东大街|ne,nw,s,se,w",
        ["n"] = "府衙|enter,n,s",
        ["nw"] = "西门|nw,se,sw",
        ["su"] = "西桥|nd,sd",
      },
    },
    ["西桥|nd,sd"] = {
      name = "西桥",
      exits = {
        ["nd"] = "西大街|e,n,nw,su",
        ["sd"] = "北禅寺巷|e,nu,w",
      },
    },
    ["西门|nw,se,sw"] = {
      name = "西门",
      exits = {
        ["nw"] = "土路|ne,se",
        ["se"] = "西大街|e,n,nw,su",
        ["sw"] = "雪浪山|ne,sw",
      },
    },
    ["观前街|e,n,w"] = {
      name = "观前街",
      exits = {
        ["e"] = "盛巷|eu,n,w",
        ["n"] = "洞虚宫|s",
        ["w"] = "观前街|e,nw,s,w",
      },
    },
    ["观前街|e,nw,s,w"] = {
      name = "观前街",
      exits = {
        ["e"] = "观前街|e,n,w",
        ["nw"] = "盛巷桥|n,se,w",
        ["s"] = "大市桥|n,nw,se",
        ["w"] = "石皮巷|e,sw",
      },
    },
    ["连元街|e,s"] = {
      name = "连元街",
      exits = {
        ["e"] = "连元街|e,w",
        ["s"] = "府衙|enter,n,s",
      },
    },
    ["连元街|e,w"] = {
      name = "连元街",
      exits = {
        ["e"] = "盛巷桥|n,se,w",
        ["w"] = "连元街|e,s",
      },
    },
    ["道场巷|se"] = {
      name = "道场巷",
      exits = {
        ["se"] = "仓桥|ed,nw",
      },
    },
    ["钱庄|n"] = {
      name = "钱庄",
      exits = {
        ["n"] = "庙巷|e,n,s",
      },
    },
    ["锡山脚下|nw,se"] = {
      name = "锡山脚下",
      exits = {
        ["nw"] = "常州|n,nw,se,su,sw",
        ["se"] = "杏子林|nw,s,se",
      },
    },
    ["长风镖局|s"] = {
      name = "长风镖局",
      exits = {
        ["s"] = "欢喜巷|n,se,w",
      },
    },
    ["阳山|s,sw"] = {
      name = "阳山",
      exits = {
        ["s"] = "三茅峰|ed,n",
      },
    },
    ["雪浪山|ne,sw"] = {
      name = "雪浪山",
      exits = {
        ["ne"] = "西门|nw,se,sw",
        ["sw"] = "太湖湖边|ne",
      },
    },
    ["青石官道|ne,nw,s"] = {
      name = "青石官道",
      exits = {
        ["nw"] = "杏子林|nw,s,se",
      },
    },
    ["黄泥桥|nd,sd"] = {
      name = "黄泥桥",
      exits = {
        ["nd"] = "城头街|su,w",
        ["sd"] = "硝皮巷|nu,s,se",
      },
    },
  },
  
  mapAliases = {
    ["三茅峰"]     = "smf",
    ["东大街"]     = "ddj",
    ["东门"]       = "dm",
    ["书院街"]     = "syj",
    ["仓桥"]       = "cq",
    ["北禅寺"]     = "bcs",
    ["北禅寺巷"]   = "bcsx",
    ["北门"]       = "bm",
    ["医馆"]       = "yg",
    ["南大街"]     = "ndj",
    ["南市桥"]     = "nsq",
    ["南市桥巷"]   = "nsqx",
    ["南门"]       = "nm",
    ["土路"]       = "tl",
    ["城外土路"]   = "cwtl",
    ["城头街"]     = "ctj",
    ["城守营"]     = "csy",
    ["城隍庙"]     = "chm",
    ["大厅"]       = "dt",
    ["大市桥"]     = "dsq",
    ["太湖湖边"]   = "thhb",
    ["山脚下"]     = "sjx",
    ["山路"]       = "sl",
    ["常州"]       = "cz",
    ["庙巷"]       = "mx",
    ["府衙"]       = "fy",
    ["当铺"]       = "dp",
    ["惠山"]       = "hs",
    ["惠山寺"]     = "hss",
    ["惠山泉"]     = "hsq",
    ["打铁桥"]     = "dtq",
    ["打铁铺"]     = "dtp",
    ["捕快营"]     = "bky",
    ["无锡马车行"] = "wx",   -- 无锡 = wx
    ["春申涧"]     = "csj",
    ["杂货铺"]     = "zhp",
    ["杏子林"]     = "xzl",
    ["松鹤楼"]     = "shl",
    ["槐树巷"]     = "hsx",
    ["欢喜巷"]     = "hxx",
    ["洞虚宫"]     = "dxg",
    ["盛巷"]       = "sx",
    ["盛巷桥"]     = "sxq",
    ["石皮巷"]     = "spx",
    ["硝皮巷"]     = "xpx",
    ["营桥"]       = "yq",
    ["西大街"]     = "xdj",
    ["西桥"]       = "xq",
    ["西门"]       = "xm",
    ["观前街"]     = "gqj",
    ["连元街"]     = "lyj",
    ["道场巷"]     = "dcx",
    ["钱庄"]       = "qz",
    ["锡山脚下"]   = "xsjx",
    ["长风镖局"]   = "cfbj",
    ["阳山"]       = "ys",
    ["雪浪山"]     = "xls",
    ["青石官道"]   = "qsgd",
    ["黄泥桥"]     = "hnq",
  }

}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>cz</name>
				<packageName></packageName>
				<script>-- 潮州地图

mapper = mapper or {}
mapper.maps = mapper.maps or {}

mapper.maps["cz"] = {

  region = {
    key  = "cz",      -- 区域代号，用在 goto cz.xxx 里
    name = "潮州",    -- 区域中文名
  },

  mapNodes = {

    ["鼓楼|n,s"] = {
      name = "鼓楼",
      exits = {
        ["n"] = "北门|s",
        ["s"] = "太平桥|e,n,s,w",
        ["w"] = "太平桥|e,n,s,w",
      },
    },

    ["东大街|e,s,w"] = {
      name = "东大街",
      exits = {
        ["e"] = "广济门|eu,nw,se,w",
        ["s"] = "中央广场|e,n,s,w",
        ["w"] = "中央广场|e,n,s,w",
      },
    },

    ["义安楼|se"] = {
      name = "义安楼",
      exits = {
        ["se"] = "广济桥|ed,ne,nw,wd",
      },
    },

    ["南安|eu,sw"] = {
      name = "南安",
      exits = {
        ["sw"] = "同安|e,ne,su",
      },
    },

    ["南靖|se,sw"] = {
      name = "南靖",
      exits = {
        ["se"] = "漳州|eu,nw,w",
        ["sw"] = "平和|e,ne,sw",
      },
    },

    ["同安|e,ne,su"] = {
      name = "同安",
      exits = {
        ["e"]  = "晋江|ed,w",
        ["ne"] = "南安|eu,sw",
        ["su"] = "山路|nd,wd",
      },
    },

    ["山路|nd,wd"] = {
      name = "山路",
      exits = {
        ["nd"] = "同安|e,ne,su",
        ["wd"] = "漳州|eu,nw,w",
      },
    },

    ["山路|ne,sw"] = {
      name = "山路",
      exits = {
        ["ne"] = "平和|e,ne,sw",
        ["sw"] = "韩江东岸|ne,wu",
      },
    },

    ["平和|e,ne,sw"] = {
      name = "平和",
      exits = {
        ["e"]  = "漳州|eu,nw,w",
        ["ne"] = "南靖|se,sw",
        ["sw"] = "山路|ne,sw",
      },
    },

    ["广济桥|ed,ne,nw,wd"] = {
      name = "广济桥",
      exits = {
        ["ed"] = "韩江东岸|ne,wu",
        ["ne"] = "翠红阁|sw",
        ["nw"] = "义安楼|se",
        ["wd"] = "广济门|eu,nw,se,w",
      },
    },

    ["广济门|eu,nw,se,w"] = {
      name = "广济门",
      exits = {
        ["eu"] = "广济桥|ed,ne,nw,wd",
        ["nw"] = "韩江边|se",
        ["se"] = "韩江西岸|nw",
        ["w"]  = "东大街|e,s,w",
      },
    },

    ["晋江|ed,w"] = {
      name = "晋江",
      exits = {
        ["ed"] = "晋江西岸|wu",
        ["w"]  = "同安|e,ne,su",
      },
    },

    ["晋江西岸|wu"] = {
      name = "晋江西岸",
      exits = {
        ["wu"] = "晋江|ed,w",
      },
    },

    ["漳州|eu,nw,w"] = {
      name = "漳州",
      exits = {
        ["eu"] = "山路|nd,wd",
        ["nw"] = "南靖|se,sw",
        ["w"]  = "平和|e,ne,sw",
      },
    },

    ["翠红阁|sw"] = {
      name = "翠红阁",
      exits = {
        ["sw"] = "广济桥|ed,ne,nw,wd",
      },
    },

    ["韩江东岸|ne,wu"] = {
      name = "韩江东岸",
      exits = {
        ["ne"] = "山路|ne,sw",
        ["wu"] = "广济桥|ed,ne,nw,wd",
      },
    },

    ["韩江西岸|nw"] = {
      name = "韩江西岸",
      exits = {
        ["nw"] = "广济门|eu,nw,se,w",
      },
    },

    ["韩江边|se"] = {
      name = "韩江边",
      exits = {
        ["se"] = "广济门|eu,nw,se,w",
      },
    },

    ["中央广场|e,n,s,w"] = {
      name = "中央广场",
      exits = {
        ["e"] = "东大街|e,s,w",
        ["n"] = "北大街|n,s",
        ["s"] = "南大街|n,s,w",
        ["w"] = "西大街|e,n,s,w",
      },
    },

    ["凤啸门|s"] = {
      name = "凤啸门",
      exits = {
        ["s"] = "相思桥|e,n,s",
      },
    },

    ["北大街|n,s"] = {
      name = "北大街",
      exits = {
        ["n"] = "太平桥|e,n,s,w",
        ["s"] = "中央广场|e,n,s,w",
      },
    },

    ["北门|s"] = {
      name = "北门",
      exits = {
        ["s"] = "鼓楼|n,s",
      },
    },

    ["医灵堂|e"] = {
      name = "医灵堂",
      exits = {
        ["e"] = "南大街1|n,s,w",
      },
    },

    ["南大街|n,s,w"] = {
      name = "南大街",
      exits = {
        ["n"] = "中央广场|e,n,s,w",
        ["s"] = "南大街|n,s,w",
        ["w"] = "开元寺|e,n",
      },
    },

    ["南大街1|n,s,w"] = {
      name = "南大街1",
      exits = {
        ["n"] = "南大街|n,s,w",
        ["w"] = "医灵堂|e",
      },
    },

    ["太平桥|e,n,s,w"] = {
      name = "太平桥",
      exits = {
        ["e"] = "州治|e",
        ["n"] = "鼓楼|n,s",
        ["s"] = "北大街|n,s",
        ["w"] = "相思桥|e,n,s",
      },
    },

    ["开元寺|e,n"] = {
      name = "开元寺",
      exits = {
        ["e"] = "南大街|n,s,w",
        ["n"] = "西大街|e,n,s,w",
      },
    },

    ["当铺|n,s"] = {
      name = "当铺",
      exits = {
        ["n"] = "相思桥|e,n,s",
        ["s"] = "西大街|e,n,s,w",
      },
    },

    ["相思桥|e,n,s"] = {
      name = "相思桥",
      exits = {
        ["e"] = "太平桥|e,n,s,w",
        ["n"] = "凤啸门|s",
        ["s"] = "当铺|n,s",
      },
    },

    ["西大街|e,n,s,w"] = {
      name = "西大街",
      exits = {
        ["e"] = "中央广场|e,n,s,w",
        ["n"] = "当铺|n,s",
        ["s"] = "开元寺|e,n",
        ["w"] = "西大街1|e,n,s,w",
      },
    },

    ["西大街1|e,n,s,w"] = {
      name = "西大街1",
      exits = {
        ["e"] = "西大街|e,n,s,w",
        ["n"] = "钱庄|s",
        ["s"] = "潮州车行|n",
        ["w"] = "西门|e,s,w",
      },
    },

    ["潮州车行|n"] = {
      name = "潮州车行",
      exits = {
        ["n"] = "西大街1|e,n,s,w",
      },
    },

    ["钱庄|s"] = {
      name = "钱庄",
      exits = {
        ["s"] = "西大街1|e,n,s,w",
      },
    },

    ["西门|e,s,w"] = {
      name = "西门",
      exits = {
        ["e"] = "西大街1|e,n,s,w",
        ["s"] = "潮州城外|n",
        ["w"] = "海边|e",
      },
    },
    
    ["小路|ne,s"] = {
      name = "小路",
      exits = {
        ["ne"] = "三阳门|n,sw,w",
        ["s"] = "龟屿|n,se",
      },
    },
  
    ["海边|nw"] = {
      name = "海边",
      exits = {
        ["nw"] = "龟屿|n,se",
      },
    },
  
    ["龟屿|n,se"] = {
      name = "龟屿",
      exits = {
        ["n"] = "小路|ne,s",
        ["se"] = "海边|nw",
      },
    },
  
    ["三阳门|n,sw,w"] = {
      name = "三阳门",
      exits = {
        ["n"] = "南大街1|n,s,w",
        ["sw"] = "小路|ne,s",
        ["w"] = "官道|e,w",
      },
    },

  }, -- mapNodes 结束
  
  mapAliases = {
    ["鼓楼"]       = "gl",
    ["东大街"]     = "ddj",
    ["义安楼"]     = "yal",
    ["南安"]       = "na",
    ["南靖"]       = "nj",
    ["同安"]       = "ta",
    ["山路"]       = "sl",
    ["平和"]       = "ph",
    ["广济桥"]     = "gjq",
    ["广济门"]     = "gjm",
    ["晋江"]       = "jj",
    ["晋江西岸"]   = "jjxa",
    ["漳州"]       = "zz",
    ["翠红阁"]     = "chg",
    ["韩江东岸"]   = "hjda",
    ["韩江西岸"]   = "hjxa",
    ["韩江边"]     = "hjb",
    ["中央广场"]   = "zygc",
    ["凤啸门"]     = "fxm",
    ["北大街"]     = "bdj",
    ["北门"]       = "bm",
    ["医灵堂"]     = "ylt",
    ["南大街"]     = "ndj",
    ["南大街1"]    = "ndj1",
    ["太平桥"]     = "tpq",
    ["开元寺"]     = "kys",
    ["当铺"]       = "dp",
    ["相思桥"]     = "xsq",
    ["西大街"]     = "xdj",
    ["西大街1"]    = "xdj1",
    ["潮州车行"]   = "czcx",
    ["钱庄"]       = "qz",
    ["西门"]       = "xm",
    ["小路"]       = "xl",
    ["海边"]       = "hb",
    ["龟屿"]       = "gy",
    ["三阳门"]     = "sym",
  }


} -- mapper.maps["cz"] 结束
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<VariablePackage>
		<HiddenVariables>
			<name>eat_interval</name>
		</HiddenVariables>
		<VariableGroup>
			<name>murong_task</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>current_mrf_location</name>
				<keyType>4</keyType>
				<value>node walk tgz_mrf</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>murong_target_city</name>
				<keyType>4</keyType>
				<value>衢州</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>murong_target_room</name>
				<keyType>4</keyType>
				<value>城南大街</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>hp_constants</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>tineng_good</name>
				<keyType>4</keyType>
				<value>体能良好</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>need_sleep</name>
				<keyType>4</keyType>
				<value>需要睡眠</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>short_of_xue</name>
				<keyType>4</keyType>
				<value>血不足</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>short_of_neili</name>
				<keyType>4</keyType>
				<value>内力不足</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>thirthty</name>
				<keyType>4</keyType>
				<value>"饥渴状态"</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>hunger</name>
				<keyType>4</keyType>
				<value>"饥饿状态"</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>short_of_shen</name>
				<keyType>4</keyType>
				<value>神不足</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>skill_info</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>sword_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>dodge_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>taiji_quan_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>force_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>taiji_sword_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>cuff_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>parry_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>tiyunzong_level</name>
				<keyType>4</keyType>
				<value>50</value>
				<valueType>3</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>current_luren</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>cloth_color</name>
				<keyType>4</keyType>
				<value>3</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>shoes_color_type</name>
				<keyType>4</keyType>
				<value>深色</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>gender</name>
				<keyType>4</keyType>
				<value>她</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>age</name>
				<keyType>4</keyType>
				<value>二十</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>gender_type</name>
				<keyType>4</keyType>
				<value>女</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>chinese_name</name>
				<keyType>4</keyType>
				<value>萧霄娅</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>shoes_color</name>
				<keyType>4</keyType>
				<value>4</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>cloth_type</name>
				<keyType>4</keyType>
				<value>布衣</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>cloth</name>
				<keyType>4</keyType>
				<value>百褶裙</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>full_name</name>
				<keyType>4</keyType>
				<value>xiao xiaoya</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>cloth_color_type</name>
				<keyType>4</keyType>
				<value>深色</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>skill_learning_set</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>1</name>
				<keyType>3</keyType>
				<value>lingwu cuff</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>2</name>
				<keyType>3</keyType>
				<value>lingwu dodge</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>3</name>
				<keyType>3</keyType>
				<value>lingwu force</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>4</name>
				<keyType>3</keyType>
				<value>lingwu parry</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>5</name>
				<keyType>3</keyType>
				<value>lingwu sword</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>6</name>
				<keyType>3</keyType>
				<value>lian cuff 40</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>7</name>
				<keyType>3</keyType>
				<value>do 10 lian dodge 1</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>8</name>
				<keyType>3</keyType>
				<value>lian sword 20</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>hp_info</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>base_xue</name>
				<keyType>4</keyType>
				<value>693</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>base_neili</name>
				<keyType>4</keyType>
				<value>1093</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>food</name>
				<keyType>4</keyType>
				<value>184</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>current_shen</name>
				<keyType>4</keyType>
				<value>464</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>max_shen</name>
				<keyType>4</keyType>
				<value>464</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>water</name>
				<keyType>4</keyType>
				<value>68</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>max_neili</name>
				<keyType>4</keyType>
				<value>2014</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>current_jingli</name>
				<keyType>4</keyType>
				<value>1982</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>current_xue</name>
				<keyType>4</keyType>
				<value>693</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>current_neili</name>
				<keyType>4</keyType>
				<value>1432</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>base_jingli</name>
				<keyType>4</keyType>
				<value>991</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>base_shen</name>
				<keyType>4</keyType>
				<value>464</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>max_xue</name>
				<keyType>4</keyType>
				<value>693</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>maps</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
		</VariableGroup>
		<VariableGroup>
			<name>skill_constants</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>current_learning_skills</name>
				<keyType>4</keyType>
				<value>lingwu cuff</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>need_improve_basic_cannot_lian</name>
				<keyType>4</keyType>
				<value>你需要提高基本功，不然练得再多也没有用。</value>
				<valueType>4</valueType>
			</Variable>
			<Variable>
				<name>learning_index</name>
				<keyType>4</keyType>
				<value>2</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>basic_skill_higher_cannot_lingwu</name>
				<keyType>4</keyType>
				<value>你的基本功夫比你的高级功夫还高！</value>
				<valueType>4</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>stat</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
			<Variable>
				<name>qi</name>
				<keyType>4</keyType>
				<value>3767</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>water</name>
				<keyType>4</keyType>
				<value>296</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>jing</name>
				<keyType>4</keyType>
				<value>1981</value>
				<valueType>3</valueType>
			</Variable>
			<Variable>
				<name>food</name>
				<keyType>4</keyType>
				<value>282</value>
				<valueType>3</valueType>
			</Variable>
		</VariableGroup>
		<VariableGroup>
			<name>luren_set</name>
			<keyType>4</keyType>
			<value></value>
			<valueType>5</valueType>
		</VariableGroup>
		<Variable>
			<name>current_learning_skills</name>
			<keyType>4</keyType>
			<value>lingwu dodge</value>
			<valueType>4</valueType>
		</Variable>
	</VariablePackage>
</MudletPackage>
